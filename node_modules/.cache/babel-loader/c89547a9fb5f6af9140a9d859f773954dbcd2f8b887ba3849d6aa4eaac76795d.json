{"ast":null,"code":"// A simple implementation of make-array\nfunction makeArray(subject) {\n  return Array.isArray(subject) ? subject : [subject];\n}\nconst EMPTY = '';\nconst SPACE = ' ';\nconst ESCAPE = '\\\\';\nconst REGEX_TEST_BLANK_LINE = /^\\s+$/;\nconst REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\\\]|^)\\\\$/;\nconst REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/;\nconst REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\\\#/;\nconst REGEX_SPLITALL_CRLF = /\\r?\\n/g;\n// /foo,\n// ./foo,\n// ../foo,\n// .\n// ..\nconst REGEX_TEST_INVALID_PATH = /^\\.*\\/|^\\.+$/;\nconst SLASH = '/';\n\n// Do not use ternary expression here, since \"istanbul ignore next\" is buggy\nlet TMP_KEY_IGNORE = 'node-ignore';\n/* istanbul ignore else */\nif (typeof Symbol !== 'undefined') {\n  TMP_KEY_IGNORE = Symbol.for('node-ignore');\n}\nconst KEY_IGNORE = TMP_KEY_IGNORE;\nconst define = (object, key, value) => Object.defineProperty(object, key, {\n  value\n});\nconst REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;\nconst RETURN_FALSE = () => false;\n\n// Sanitize the range of a regular expression\n// The cases are complicated, see test cases for details\nconst sanitizeRange = range => range.replace(REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match\n// Invalid range (out of order) which is ok for gitignore rules but\n//   fatal for JavaScript regular expression, so eliminate it.\n: EMPTY);\n\n// See fixtures #59\nconst cleanRangeBackSlash = slashes => {\n  const {\n    length\n  } = slashes;\n  return slashes.slice(0, length - length % 2);\n};\n\n// > If the pattern ends with a slash,\n// > it is removed for the purpose of the following description,\n// > but it would only find a match with a directory.\n// > In other words, foo/ will match a directory foo and paths underneath it,\n// > but will not match a regular file or a symbolic link foo\n// >  (this is consistent with the way how pathspec works in general in Git).\n// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'\n// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call\n//      you could use option `mark: true` with `glob`\n\n// '`foo/`' should not continue with the '`..`'\nconst REPLACERS = [\n// > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\n[\n// (a\\ ) -> (a )\n// (a  ) -> (a)\n// (a \\ ) -> (a  )\n/\\\\?\\s+$/, match => match.indexOf('\\\\') === 0 ? SPACE : EMPTY],\n// replace (\\ ) with ' '\n[/\\\\\\s/g, () => SPACE],\n// Escape metacharacters\n// which is written down by users but means special for regular expressions.\n\n// > There are 12 characters with special meanings:\n// > - the backslash \\,\n// > - the caret ^,\n// > - the dollar sign $,\n// > - the period or dot .,\n// > - the vertical bar or pipe symbol |,\n// > - the question mark ?,\n// > - the asterisk or star *,\n// > - the plus sign +,\n// > - the opening parenthesis (,\n// > - the closing parenthesis ),\n// > - and the opening square bracket [,\n// > - the opening curly brace {,\n// > These special characters are often called \"metacharacters\".\n[/[\\\\$.|*+(){^]/g, match => `\\\\${match}`], [\n// > a question mark (?) matches a single character\n/(?!\\\\)\\?/g, () => '[^/]'],\n// leading slash\n[\n// > A leading slash matches the beginning of the pathname.\n// > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\n// A leading slash matches the beginning of the pathname\n/^\\//, () => '^'],\n// replace special metacharacter slash after the leading slash\n[/\\//g, () => '\\\\/'], [\n// > A leading \"**\" followed by a slash means match in all directories.\n// > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\n// > the same as pattern \"foo\".\n// > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly\n// >   under directory \"foo\".\n// Notice that the '*'s have been replaced as '\\\\*'\n/^\\^*\\\\\\*\\\\\\*\\\\\\//,\n// '**/foo' <-> 'foo'\n() => '^(?:.*\\\\/)?'],\n// starting\n[\n// there will be no leading '/'\n//   (which has been replaced by section \"leading slash\")\n// If starts with '**', adding a '^' to the regular expression also works\n/^(?=[^^])/, function startingReplacer() {\n  // If has a slash `/` at the beginning or middle\n  return !/\\/(?!$)/.test(this)\n  // > Prior to 2.22.1\n  // > If the pattern does not contain a slash /,\n  // >   Git treats it as a shell glob pattern\n  // Actually, if there is only a trailing slash,\n  //   git also treats it as a shell glob pattern\n\n  // After 2.22.1 (compatible but clearer)\n  // > If there is a separator at the beginning or middle (or both)\n  // > of the pattern, then the pattern is relative to the directory\n  // > level of the particular .gitignore file itself.\n  // > Otherwise the pattern may also match at any level below\n  // > the .gitignore level.\n  ? '(?:^|\\\\/)'\n\n  // > Otherwise, Git treats the pattern as a shell glob suitable for\n  // >   consumption by fnmatch(3)\n  : '^';\n}],\n// two globstars\n[\n// Use lookahead assertions so that we could match more than one `'/**'`\n/\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g,\n// Zero, one or several directories\n// should not use '*', or it will be replaced by the next replacer\n\n// Check if it is not the last `'/**'`\n(_, index, str) => index + 6 < str.length\n\n// case: /**/\n// > A slash followed by two consecutive asterisks then a slash matches\n// >   zero or more directories.\n// > For example, \"a/**/b\" matches \"a/b\", \"a/x/b\", \"a/x/y/b\" and so on.\n// '/**/'\n? '(?:\\\\/[^\\\\/]+)*'\n\n// case: /**\n// > A trailing `\"/**\"` matches everything inside.\n\n// #21: everything inside but it should not include the current folder\n: '\\\\/.+'],\n// normal intermediate wildcards\n[\n// Never replace escaped '*'\n// ignore rule '\\*' will match the path '*'\n\n// 'abc.*/' -> go\n// 'abc.*'  -> skip this rule,\n//    coz trailing single wildcard will be handed by [trailing wildcard]\n/(^|[^\\\\]+)(\\\\\\*)+(?=.+)/g,\n// '*.js' matches '.js'\n// '*.js' doesn't match 'abc'\n(_, p1, p2) => {\n  // 1.\n  // > An asterisk \"*\" matches anything except a slash.\n  // 2.\n  // > Other consecutive asterisks are considered regular asterisks\n  // > and will match according to the previous rules.\n  const unescaped = p2.replace(/\\\\\\*/g, '[^\\\\/]*');\n  return p1 + unescaped;\n}], [\n// unescape, revert step 3 except for back slash\n// For example, if a user escape a '\\\\*',\n// after step 3, the result will be '\\\\\\\\\\\\*'\n/\\\\\\\\\\\\(?=[$.|*+(){^])/g, () => ESCAPE], [\n// '\\\\\\\\' -> '\\\\'\n/\\\\\\\\/g, () => ESCAPE], [\n// > The range notation, e.g. [a-zA-Z],\n// > can be used to match one of the characters in a range.\n\n// `\\` is escaped by step 3\n/(\\\\)?\\[([^\\]/]*?)(\\\\*)($|\\])/g, (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE\n// '\\\\[bar]' -> '\\\\\\\\[bar\\\\]'\n? `\\\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === ']' ? endEscape.length % 2 === 0\n// A normal case, and it is a range notation\n// '[bar]'\n// '[bar\\\\\\\\]'\n? `[${sanitizeRange(range)}${endEscape}]`\n// Invalid range notaton\n// '[bar\\\\]' -> '[bar\\\\\\\\]'\n: '[]' : '[]'],\n// ending\n[\n// 'js' will not match 'js.'\n// 'ab' will not match 'abc'\n/(?:[^*])$/,\n// WTF!\n// https://git-scm.com/docs/gitignore\n// changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)\n// which re-fixes #24, #38\n\n// > If there is a separator at the end of the pattern then the pattern\n// > will only match directories, otherwise the pattern can match both\n// > files and directories.\n\n// 'js*' will not match 'a.js'\n// 'js/' will not match 'a.js'\n// 'js' will match 'a.js' and 'a.js/'\nmatch => /\\/$/.test(match)\n// foo/ will not match 'foo'\n? `${match}$`\n// foo matches 'foo' and 'foo/'\n: `${match}(?=$|\\\\/$)`],\n// trailing wildcard\n[/(\\^|\\\\\\/)?\\\\\\*$/, (_, p1) => {\n  const prefix = p1\n  // '\\^':\n  // '/*' does not match EMPTY\n  // '/*' does not match everything\n\n  // '\\\\\\/':\n  // 'abc/*' does not match 'abc/'\n  ? `${p1}[^/]+`\n\n  // 'a*' matches 'a'\n  // 'a*' matches 'aa'\n  : '[^/]*';\n  return `${prefix}(?=$|\\\\/$)`;\n}]];\n\n// A simple cache, because an ignore rule only has only one certain meaning\nconst regexCache = Object.create(null);\n\n// @param {pattern}\nconst makeRegex = (pattern, ignoreCase) => {\n  let source = regexCache[pattern];\n  if (!source) {\n    source = REPLACERS.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);\n    regexCache[pattern] = source;\n  }\n  return ignoreCase ? new RegExp(source, 'i') : new RegExp(source);\n};\nconst isString = subject => typeof subject === 'string';\n\n// > A blank line matches no files, so it can serve as a separator for readability.\nconst checkPattern = pattern => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern)\n\n// > A line starting with # serves as a comment.\n&& pattern.indexOf('#') !== 0;\nconst splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF);\nclass IgnoreRule {\n  constructor(origin, pattern, negative, regex) {\n    this.origin = origin;\n    this.pattern = pattern;\n    this.negative = negative;\n    this.regex = regex;\n  }\n}\nconst createRule = (pattern, ignoreCase) => {\n  const origin = pattern;\n  let negative = false;\n\n  // > An optional prefix \"!\" which negates the pattern;\n  if (pattern.indexOf('!') === 0) {\n    negative = true;\n    pattern = pattern.substr(1);\n  }\n  pattern = pattern\n  // > Put a backslash (\"\\\") in front of the first \"!\" for patterns that\n  // >   begin with a literal \"!\", for example, `\"\\!important!.txt\"`.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')\n  // > Put a backslash (\"\\\") in front of the first hash for patterns that\n  // >   begin with a hash.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#');\n  const regex = makeRegex(pattern, ignoreCase);\n  return new IgnoreRule(origin, pattern, negative, regex);\n};\nconst throwError = (message, Ctor) => {\n  throw new Ctor(message);\n};\nconst checkPath = (path, originalPath, doThrow) => {\n  if (!isString(path)) {\n    return doThrow(`path must be a string, but got \\`${originalPath}\\``, TypeError);\n  }\n\n  // We don't know if we should ignore EMPTY, so throw\n  if (!path) {\n    return doThrow(`path must not be empty`, TypeError);\n  }\n\n  // Check if it is a relative path\n  if (checkPath.isNotRelative(path)) {\n    const r = '`path.relative()`d';\n    return doThrow(`path should be a ${r} string, but got \"${originalPath}\"`, RangeError);\n  }\n  return true;\n};\nconst isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path);\ncheckPath.isNotRelative = isNotRelative;\ncheckPath.convert = p => p;\nclass Ignore {\n  constructor({\n    ignorecase = true,\n    ignoreCase = ignorecase,\n    allowRelativePaths = false\n  } = {}) {\n    define(this, KEY_IGNORE, true);\n    this._rules = [];\n    this._ignoreCase = ignoreCase;\n    this._allowRelativePaths = allowRelativePaths;\n    this._initCache();\n  }\n  _initCache() {\n    this._ignoreCache = Object.create(null);\n    this._testCache = Object.create(null);\n  }\n  _addPattern(pattern) {\n    // #32\n    if (pattern && pattern[KEY_IGNORE]) {\n      this._rules = this._rules.concat(pattern._rules);\n      this._added = true;\n      return;\n    }\n    if (checkPattern(pattern)) {\n      const rule = createRule(pattern, this._ignoreCase);\n      this._added = true;\n      this._rules.push(rule);\n    }\n  }\n\n  // @param {Array<string> | string | Ignore} pattern\n  add(pattern) {\n    this._added = false;\n    makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);\n\n    // Some rules have just added to the ignore,\n    // making the behavior changed.\n    if (this._added) {\n      this._initCache();\n    }\n    return this;\n  }\n\n  // legacy\n  addPattern(pattern) {\n    return this.add(pattern);\n  }\n\n  //          |           ignored : unignored\n  // negative |   0:0   |   0:1   |   1:0   |   1:1\n  // -------- | ------- | ------- | ------- | --------\n  //     0    |  TEST   |  TEST   |  SKIP   |    X\n  //     1    |  TESTIF |  SKIP   |  TEST   |    X\n\n  // - SKIP: always skip\n  // - TEST: always test\n  // - TESTIF: only test if checkUnignored\n  // - X: that never happen\n\n  // @param {boolean} whether should check if the path is unignored,\n  //   setting `checkUnignored` to `false` could reduce additional\n  //   path matching.\n\n  // @returns {TestResult} true if a file is ignored\n  _testOne(path, checkUnignored) {\n    let ignored = false;\n    let unignored = false;\n    this._rules.forEach(rule => {\n      const {\n        negative\n      } = rule;\n      if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {\n        return;\n      }\n      const matched = rule.regex.test(path);\n      if (matched) {\n        ignored = !negative;\n        unignored = negative;\n      }\n    });\n    return {\n      ignored,\n      unignored\n    };\n  }\n\n  // @returns {TestResult}\n  _test(originalPath, cache, checkUnignored, slices) {\n    const path = originalPath\n    // Supports nullable path\n    && checkPath.convert(originalPath);\n    checkPath(path, originalPath, this._allowRelativePaths ? RETURN_FALSE : throwError);\n    return this._t(path, cache, checkUnignored, slices);\n  }\n  _t(path, cache, checkUnignored, slices) {\n    if (path in cache) {\n      return cache[path];\n    }\n    if (!slices) {\n      // path/to/a.js\n      // ['path', 'to', 'a.js']\n      slices = path.split(SLASH);\n    }\n    slices.pop();\n\n    // If the path has no parent directory, just test it\n    if (!slices.length) {\n      return cache[path] = this._testOne(path, checkUnignored);\n    }\n    const parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);\n\n    // If the path contains a parent directory, check the parent first\n    return cache[path] = parent.ignored\n    // > It is not possible to re-include a file if a parent directory of\n    // >   that file is excluded.\n    ? parent : this._testOne(path, checkUnignored);\n  }\n  ignores(path) {\n    return this._test(path, this._ignoreCache, false).ignored;\n  }\n  createFilter() {\n    return path => !this.ignores(path);\n  }\n  filter(paths) {\n    return makeArray(paths).filter(this.createFilter());\n  }\n\n  // @returns {TestResult}\n  test(path) {\n    return this._test(path, this._testCache, true);\n  }\n}\nconst factory = options => new Ignore(options);\nconst isPathValid = path => checkPath(path && checkPath.convert(path), path, RETURN_FALSE);\nfactory.isPathValid = isPathValid;\n\n// Fixes typescript\nfactory.default = factory;\nmodule.exports = factory;\n\n// Windows\n// --------------------------------------------------------------\n/* istanbul ignore if */\nif (\n// Detect `process` so that it can run in browsers.\ntypeof process !== 'undefined' && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === 'win32')) {\n  /* eslint no-control-regex: \"off\" */\n  const makePosix = str => /^\\\\\\\\\\?\\\\/.test(str) || /[\"<>|\\u0000-\\u001F]+/u.test(str) ? str : str.replace(/\\\\/g, '/');\n  checkPath.convert = makePosix;\n\n  // 'C:\\\\foo'     <- 'C:\\\\foo' has been converted to 'C:/'\n  // 'd:\\\\foo'\n  const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\\//i;\n  checkPath.isNotRelative = path => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);\n}","map":{"version":3,"names":["makeArray","subject","Array","isArray","EMPTY","SPACE","ESCAPE","REGEX_TEST_BLANK_LINE","REGEX_INVALID_TRAILING_BACKSLASH","REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION","REGEX_REPLACE_LEADING_EXCAPED_HASH","REGEX_SPLITALL_CRLF","REGEX_TEST_INVALID_PATH","SLASH","TMP_KEY_IGNORE","Symbol","for","KEY_IGNORE","define","object","key","value","Object","defineProperty","REGEX_REGEXP_RANGE","RETURN_FALSE","sanitizeRange","range","replace","match","from","to","charCodeAt","cleanRangeBackSlash","slashes","length","slice","REPLACERS","indexOf","startingReplacer","test","_","index","str","p1","p2","unescaped","leadEscape","endEscape","close","prefix","regexCache","create","makeRegex","pattern","ignoreCase","source","reduce","prev","current","bind","RegExp","isString","checkPattern","splitPattern","split","IgnoreRule","constructor","origin","negative","regex","createRule","substr","throwError","message","Ctor","checkPath","path","originalPath","doThrow","TypeError","isNotRelative","r","RangeError","convert","p","Ignore","ignorecase","allowRelativePaths","_rules","_ignoreCase","_allowRelativePaths","_initCache","_ignoreCache","_testCache","_addPattern","concat","_added","rule","push","add","forEach","addPattern","_testOne","checkUnignored","ignored","unignored","matched","_test","cache","slices","_t","pop","parent","join","ignores","createFilter","filter","paths","factory","options","isPathValid","default","module","exports","process","env","IGNORE_TEST_WIN32","platform","makePosix","REGIX_IS_WINDOWS_PATH_ABSOLUTE"],"sources":["C:/Users/HarshitSrivastava/Desktop/Practice/React/Project2/my-app/node_modules/ignore/index.js"],"sourcesContent":["// A simple implementation of make-array\nfunction makeArray (subject) {\n  return Array.isArray(subject)\n    ? subject\n    : [subject]\n}\n\nconst EMPTY = ''\nconst SPACE = ' '\nconst ESCAPE = '\\\\'\nconst REGEX_TEST_BLANK_LINE = /^\\s+$/\nconst REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\\\]|^)\\\\$/\nconst REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/\nconst REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\\\#/\nconst REGEX_SPLITALL_CRLF = /\\r?\\n/g\n// /foo,\n// ./foo,\n// ../foo,\n// .\n// ..\nconst REGEX_TEST_INVALID_PATH = /^\\.*\\/|^\\.+$/\n\nconst SLASH = '/'\n\n// Do not use ternary expression here, since \"istanbul ignore next\" is buggy\nlet TMP_KEY_IGNORE = 'node-ignore'\n/* istanbul ignore else */\nif (typeof Symbol !== 'undefined') {\n  TMP_KEY_IGNORE = Symbol.for('node-ignore')\n}\nconst KEY_IGNORE = TMP_KEY_IGNORE\n\nconst define = (object, key, value) =>\n  Object.defineProperty(object, key, {value})\n\nconst REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g\n\nconst RETURN_FALSE = () => false\n\n// Sanitize the range of a regular expression\n// The cases are complicated, see test cases for details\nconst sanitizeRange = range => range.replace(\n  REGEX_REGEXP_RANGE,\n  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0)\n    ? match\n    // Invalid range (out of order) which is ok for gitignore rules but\n    //   fatal for JavaScript regular expression, so eliminate it.\n    : EMPTY\n)\n\n// See fixtures #59\nconst cleanRangeBackSlash = slashes => {\n  const {length} = slashes\n  return slashes.slice(0, length - length % 2)\n}\n\n// > If the pattern ends with a slash,\n// > it is removed for the purpose of the following description,\n// > but it would only find a match with a directory.\n// > In other words, foo/ will match a directory foo and paths underneath it,\n// > but will not match a regular file or a symbolic link foo\n// >  (this is consistent with the way how pathspec works in general in Git).\n// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'\n// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call\n//      you could use option `mark: true` with `glob`\n\n// '`foo/`' should not continue with the '`..`'\nconst REPLACERS = [\n\n  // > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\n  [\n    // (a\\ ) -> (a )\n    // (a  ) -> (a)\n    // (a \\ ) -> (a  )\n    /\\\\?\\s+$/,\n    match => match.indexOf('\\\\') === 0\n      ? SPACE\n      : EMPTY\n  ],\n\n  // replace (\\ ) with ' '\n  [\n    /\\\\\\s/g,\n    () => SPACE\n  ],\n\n  // Escape metacharacters\n  // which is written down by users but means special for regular expressions.\n\n  // > There are 12 characters with special meanings:\n  // > - the backslash \\,\n  // > - the caret ^,\n  // > - the dollar sign $,\n  // > - the period or dot .,\n  // > - the vertical bar or pipe symbol |,\n  // > - the question mark ?,\n  // > - the asterisk or star *,\n  // > - the plus sign +,\n  // > - the opening parenthesis (,\n  // > - the closing parenthesis ),\n  // > - and the opening square bracket [,\n  // > - the opening curly brace {,\n  // > These special characters are often called \"metacharacters\".\n  [\n    /[\\\\$.|*+(){^]/g,\n    match => `\\\\${match}`\n  ],\n\n  [\n    // > a question mark (?) matches a single character\n    /(?!\\\\)\\?/g,\n    () => '[^/]'\n  ],\n\n  // leading slash\n  [\n\n    // > A leading slash matches the beginning of the pathname.\n    // > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\n    // A leading slash matches the beginning of the pathname\n    /^\\//,\n    () => '^'\n  ],\n\n  // replace special metacharacter slash after the leading slash\n  [\n    /\\//g,\n    () => '\\\\/'\n  ],\n\n  [\n    // > A leading \"**\" followed by a slash means match in all directories.\n    // > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\n    // > the same as pattern \"foo\".\n    // > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly\n    // >   under directory \"foo\".\n    // Notice that the '*'s have been replaced as '\\\\*'\n    /^\\^*\\\\\\*\\\\\\*\\\\\\//,\n\n    // '**/foo' <-> 'foo'\n    () => '^(?:.*\\\\/)?'\n  ],\n\n  // starting\n  [\n    // there will be no leading '/'\n    //   (which has been replaced by section \"leading slash\")\n    // If starts with '**', adding a '^' to the regular expression also works\n    /^(?=[^^])/,\n    function startingReplacer () {\n      // If has a slash `/` at the beginning or middle\n      return !/\\/(?!$)/.test(this)\n        // > Prior to 2.22.1\n        // > If the pattern does not contain a slash /,\n        // >   Git treats it as a shell glob pattern\n        // Actually, if there is only a trailing slash,\n        //   git also treats it as a shell glob pattern\n\n        // After 2.22.1 (compatible but clearer)\n        // > If there is a separator at the beginning or middle (or both)\n        // > of the pattern, then the pattern is relative to the directory\n        // > level of the particular .gitignore file itself.\n        // > Otherwise the pattern may also match at any level below\n        // > the .gitignore level.\n        ? '(?:^|\\\\/)'\n\n        // > Otherwise, Git treats the pattern as a shell glob suitable for\n        // >   consumption by fnmatch(3)\n        : '^'\n    }\n  ],\n\n  // two globstars\n  [\n    // Use lookahead assertions so that we could match more than one `'/**'`\n    /\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g,\n\n    // Zero, one or several directories\n    // should not use '*', or it will be replaced by the next replacer\n\n    // Check if it is not the last `'/**'`\n    (_, index, str) => index + 6 < str.length\n\n      // case: /**/\n      // > A slash followed by two consecutive asterisks then a slash matches\n      // >   zero or more directories.\n      // > For example, \"a/**/b\" matches \"a/b\", \"a/x/b\", \"a/x/y/b\" and so on.\n      // '/**/'\n      ? '(?:\\\\/[^\\\\/]+)*'\n\n      // case: /**\n      // > A trailing `\"/**\"` matches everything inside.\n\n      // #21: everything inside but it should not include the current folder\n      : '\\\\/.+'\n  ],\n\n  // normal intermediate wildcards\n  [\n    // Never replace escaped '*'\n    // ignore rule '\\*' will match the path '*'\n\n    // 'abc.*/' -> go\n    // 'abc.*'  -> skip this rule,\n    //    coz trailing single wildcard will be handed by [trailing wildcard]\n    /(^|[^\\\\]+)(\\\\\\*)+(?=.+)/g,\n\n    // '*.js' matches '.js'\n    // '*.js' doesn't match 'abc'\n    (_, p1, p2) => {\n      // 1.\n      // > An asterisk \"*\" matches anything except a slash.\n      // 2.\n      // > Other consecutive asterisks are considered regular asterisks\n      // > and will match according to the previous rules.\n      const unescaped = p2.replace(/\\\\\\*/g, '[^\\\\/]*')\n      return p1 + unescaped\n    }\n  ],\n\n  [\n    // unescape, revert step 3 except for back slash\n    // For example, if a user escape a '\\\\*',\n    // after step 3, the result will be '\\\\\\\\\\\\*'\n    /\\\\\\\\\\\\(?=[$.|*+(){^])/g,\n    () => ESCAPE\n  ],\n\n  [\n    // '\\\\\\\\' -> '\\\\'\n    /\\\\\\\\/g,\n    () => ESCAPE\n  ],\n\n  [\n    // > The range notation, e.g. [a-zA-Z],\n    // > can be used to match one of the characters in a range.\n\n    // `\\` is escaped by step 3\n    /(\\\\)?\\[([^\\]/]*?)(\\\\*)($|\\])/g,\n    (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE\n      // '\\\\[bar]' -> '\\\\\\\\[bar\\\\]'\n      ? `\\\\[${range}${cleanRangeBackSlash(endEscape)}${close}`\n      : close === ']'\n        ? endEscape.length % 2 === 0\n          // A normal case, and it is a range notation\n          // '[bar]'\n          // '[bar\\\\\\\\]'\n          ? `[${sanitizeRange(range)}${endEscape}]`\n          // Invalid range notaton\n          // '[bar\\\\]' -> '[bar\\\\\\\\]'\n          : '[]'\n        : '[]'\n  ],\n\n  // ending\n  [\n    // 'js' will not match 'js.'\n    // 'ab' will not match 'abc'\n    /(?:[^*])$/,\n\n    // WTF!\n    // https://git-scm.com/docs/gitignore\n    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)\n    // which re-fixes #24, #38\n\n    // > If there is a separator at the end of the pattern then the pattern\n    // > will only match directories, otherwise the pattern can match both\n    // > files and directories.\n\n    // 'js*' will not match 'a.js'\n    // 'js/' will not match 'a.js'\n    // 'js' will match 'a.js' and 'a.js/'\n    match => /\\/$/.test(match)\n      // foo/ will not match 'foo'\n      ? `${match}$`\n      // foo matches 'foo' and 'foo/'\n      : `${match}(?=$|\\\\/$)`\n  ],\n\n  // trailing wildcard\n  [\n    /(\\^|\\\\\\/)?\\\\\\*$/,\n    (_, p1) => {\n      const prefix = p1\n        // '\\^':\n        // '/*' does not match EMPTY\n        // '/*' does not match everything\n\n        // '\\\\\\/':\n        // 'abc/*' does not match 'abc/'\n        ? `${p1}[^/]+`\n\n        // 'a*' matches 'a'\n        // 'a*' matches 'aa'\n        : '[^/]*'\n\n      return `${prefix}(?=$|\\\\/$)`\n    }\n  ],\n]\n\n// A simple cache, because an ignore rule only has only one certain meaning\nconst regexCache = Object.create(null)\n\n// @param {pattern}\nconst makeRegex = (pattern, ignoreCase) => {\n  let source = regexCache[pattern]\n\n  if (!source) {\n    source = REPLACERS.reduce(\n      (prev, current) => prev.replace(current[0], current[1].bind(pattern)),\n      pattern\n    )\n    regexCache[pattern] = source\n  }\n\n  return ignoreCase\n    ? new RegExp(source, 'i')\n    : new RegExp(source)\n}\n\nconst isString = subject => typeof subject === 'string'\n\n// > A blank line matches no files, so it can serve as a separator for readability.\nconst checkPattern = pattern => pattern\n  && isString(pattern)\n  && !REGEX_TEST_BLANK_LINE.test(pattern)\n  && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern)\n\n  // > A line starting with # serves as a comment.\n  && pattern.indexOf('#') !== 0\n\nconst splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF)\n\nclass IgnoreRule {\n  constructor (\n    origin,\n    pattern,\n    negative,\n    regex\n  ) {\n    this.origin = origin\n    this.pattern = pattern\n    this.negative = negative\n    this.regex = regex\n  }\n}\n\nconst createRule = (pattern, ignoreCase) => {\n  const origin = pattern\n  let negative = false\n\n  // > An optional prefix \"!\" which negates the pattern;\n  if (pattern.indexOf('!') === 0) {\n    negative = true\n    pattern = pattern.substr(1)\n  }\n\n  pattern = pattern\n  // > Put a backslash (\"\\\") in front of the first \"!\" for patterns that\n  // >   begin with a literal \"!\", for example, `\"\\!important!.txt\"`.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')\n  // > Put a backslash (\"\\\") in front of the first hash for patterns that\n  // >   begin with a hash.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#')\n\n  const regex = makeRegex(pattern, ignoreCase)\n\n  return new IgnoreRule(\n    origin,\n    pattern,\n    negative,\n    regex\n  )\n}\n\nconst throwError = (message, Ctor) => {\n  throw new Ctor(message)\n}\n\nconst checkPath = (path, originalPath, doThrow) => {\n  if (!isString(path)) {\n    return doThrow(\n      `path must be a string, but got \\`${originalPath}\\``,\n      TypeError\n    )\n  }\n\n  // We don't know if we should ignore EMPTY, so throw\n  if (!path) {\n    return doThrow(`path must not be empty`, TypeError)\n  }\n\n  // Check if it is a relative path\n  if (checkPath.isNotRelative(path)) {\n    const r = '`path.relative()`d'\n    return doThrow(\n      `path should be a ${r} string, but got \"${originalPath}\"`,\n      RangeError\n    )\n  }\n\n  return true\n}\n\nconst isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path)\n\ncheckPath.isNotRelative = isNotRelative\ncheckPath.convert = p => p\n\nclass Ignore {\n  constructor ({\n    ignorecase = true,\n    ignoreCase = ignorecase,\n    allowRelativePaths = false\n  } = {}) {\n    define(this, KEY_IGNORE, true)\n\n    this._rules = []\n    this._ignoreCase = ignoreCase\n    this._allowRelativePaths = allowRelativePaths\n    this._initCache()\n  }\n\n  _initCache () {\n    this._ignoreCache = Object.create(null)\n    this._testCache = Object.create(null)\n  }\n\n  _addPattern (pattern) {\n    // #32\n    if (pattern && pattern[KEY_IGNORE]) {\n      this._rules = this._rules.concat(pattern._rules)\n      this._added = true\n      return\n    }\n\n    if (checkPattern(pattern)) {\n      const rule = createRule(pattern, this._ignoreCase)\n      this._added = true\n      this._rules.push(rule)\n    }\n  }\n\n  // @param {Array<string> | string | Ignore} pattern\n  add (pattern) {\n    this._added = false\n\n    makeArray(\n      isString(pattern)\n        ? splitPattern(pattern)\n        : pattern\n    ).forEach(this._addPattern, this)\n\n    // Some rules have just added to the ignore,\n    // making the behavior changed.\n    if (this._added) {\n      this._initCache()\n    }\n\n    return this\n  }\n\n  // legacy\n  addPattern (pattern) {\n    return this.add(pattern)\n  }\n\n  //          |           ignored : unignored\n  // negative |   0:0   |   0:1   |   1:0   |   1:1\n  // -------- | ------- | ------- | ------- | --------\n  //     0    |  TEST   |  TEST   |  SKIP   |    X\n  //     1    |  TESTIF |  SKIP   |  TEST   |    X\n\n  // - SKIP: always skip\n  // - TEST: always test\n  // - TESTIF: only test if checkUnignored\n  // - X: that never happen\n\n  // @param {boolean} whether should check if the path is unignored,\n  //   setting `checkUnignored` to `false` could reduce additional\n  //   path matching.\n\n  // @returns {TestResult} true if a file is ignored\n  _testOne (path, checkUnignored) {\n    let ignored = false\n    let unignored = false\n\n    this._rules.forEach(rule => {\n      const {negative} = rule\n      if (\n        unignored === negative && ignored !== unignored\n        || negative && !ignored && !unignored && !checkUnignored\n      ) {\n        return\n      }\n\n      const matched = rule.regex.test(path)\n\n      if (matched) {\n        ignored = !negative\n        unignored = negative\n      }\n    })\n\n    return {\n      ignored,\n      unignored\n    }\n  }\n\n  // @returns {TestResult}\n  _test (originalPath, cache, checkUnignored, slices) {\n    const path = originalPath\n      // Supports nullable path\n      && checkPath.convert(originalPath)\n\n    checkPath(\n      path,\n      originalPath,\n      this._allowRelativePaths\n        ? RETURN_FALSE\n        : throwError\n    )\n\n    return this._t(path, cache, checkUnignored, slices)\n  }\n\n  _t (path, cache, checkUnignored, slices) {\n    if (path in cache) {\n      return cache[path]\n    }\n\n    if (!slices) {\n      // path/to/a.js\n      // ['path', 'to', 'a.js']\n      slices = path.split(SLASH)\n    }\n\n    slices.pop()\n\n    // If the path has no parent directory, just test it\n    if (!slices.length) {\n      return cache[path] = this._testOne(path, checkUnignored)\n    }\n\n    const parent = this._t(\n      slices.join(SLASH) + SLASH,\n      cache,\n      checkUnignored,\n      slices\n    )\n\n    // If the path contains a parent directory, check the parent first\n    return cache[path] = parent.ignored\n      // > It is not possible to re-include a file if a parent directory of\n      // >   that file is excluded.\n      ? parent\n      : this._testOne(path, checkUnignored)\n  }\n\n  ignores (path) {\n    return this._test(path, this._ignoreCache, false).ignored\n  }\n\n  createFilter () {\n    return path => !this.ignores(path)\n  }\n\n  filter (paths) {\n    return makeArray(paths).filter(this.createFilter())\n  }\n\n  // @returns {TestResult}\n  test (path) {\n    return this._test(path, this._testCache, true)\n  }\n}\n\nconst factory = options => new Ignore(options)\n\nconst isPathValid = path =>\n  checkPath(path && checkPath.convert(path), path, RETURN_FALSE)\n\nfactory.isPathValid = isPathValid\n\n// Fixes typescript\nfactory.default = factory\n\nmodule.exports = factory\n\n// Windows\n// --------------------------------------------------------------\n/* istanbul ignore if */\nif (\n  // Detect `process` so that it can run in browsers.\n  typeof process !== 'undefined'\n  && (\n    process.env && process.env.IGNORE_TEST_WIN32\n    || process.platform === 'win32'\n  )\n) {\n  /* eslint no-control-regex: \"off\" */\n  const makePosix = str => /^\\\\\\\\\\?\\\\/.test(str)\n  || /[\"<>|\\u0000-\\u001F]+/u.test(str)\n    ? str\n    : str.replace(/\\\\/g, '/')\n\n  checkPath.convert = makePosix\n\n  // 'C:\\\\foo'     <- 'C:\\\\foo' has been converted to 'C:/'\n  // 'd:\\\\foo'\n  const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\\//i\n  checkPath.isNotRelative = path =>\n    REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path)\n    || isNotRelative(path)\n}\n"],"mappings":"AAAA;AACA,SAASA,SAASA,CAAEC,OAAO,EAAE;EAC3B,OAAOC,KAAK,CAACC,OAAO,CAACF,OAAO,CAAC,GACzBA,OAAO,GACP,CAACA,OAAO,CAAC;AACf;AAEA,MAAMG,KAAK,GAAG,EAAE;AAChB,MAAMC,KAAK,GAAG,GAAG;AACjB,MAAMC,MAAM,GAAG,IAAI;AACnB,MAAMC,qBAAqB,GAAG,OAAO;AACrC,MAAMC,gCAAgC,GAAG,gBAAgB;AACzD,MAAMC,yCAAyC,GAAG,MAAM;AACxD,MAAMC,kCAAkC,GAAG,MAAM;AACjD,MAAMC,mBAAmB,GAAG,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA,MAAMC,uBAAuB,GAAG,cAAc;AAE9C,MAAMC,KAAK,GAAG,GAAG;;AAEjB;AACA,IAAIC,cAAc,GAAG,aAAa;AAClC;AACA,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE;EACjCD,cAAc,GAAGC,MAAM,CAACC,GAAG,CAAC,aAAa,CAAC;AAC5C;AACA,MAAMC,UAAU,GAAGH,cAAc;AAEjC,MAAMI,MAAM,GAAGA,CAACC,MAAM,EAAEC,GAAG,EAAEC,KAAK,KAChCC,MAAM,CAACC,cAAc,CAACJ,MAAM,EAAEC,GAAG,EAAE;EAACC;AAAK,CAAC,CAAC;AAE7C,MAAMG,kBAAkB,GAAG,kBAAkB;AAE7C,MAAMC,YAAY,GAAGA,CAAA,KAAM,KAAK;;AAEhC;AACA;AACA,MAAMC,aAAa,GAAGC,KAAK,IAAIA,KAAK,CAACC,OAAO,CAC1CJ,kBAAkB,EAClB,CAACK,KAAK,EAAEC,IAAI,EAAEC,EAAE,KAAKD,IAAI,CAACE,UAAU,CAAC,CAAC,CAAC,IAAID,EAAE,CAACC,UAAU,CAAC,CAAC,CAAC,GACvDH;AACF;AACA;AAAA,EACEzB,KACN,CAAC;;AAED;AACA,MAAM6B,mBAAmB,GAAGC,OAAO,IAAI;EACrC,MAAM;IAACC;EAAM,CAAC,GAAGD,OAAO;EACxB,OAAOA,OAAO,CAACE,KAAK,CAAC,CAAC,EAAED,MAAM,GAAGA,MAAM,GAAG,CAAC,CAAC;AAC9C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAME,SAAS,GAAG;AAEhB;AACA;AACE;AACA;AACA;AACA,SAAS,EACTR,KAAK,IAAIA,KAAK,CAACS,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,GAC9BjC,KAAK,GACLD,KAAK,CACV;AAED;AACA,CACE,OAAO,EACP,MAAMC,KAAK,CACZ;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CACE,gBAAgB,EAChBwB,KAAK,IAAK,KAAIA,KAAM,EAAC,CACtB,EAED;AACE;AACA,WAAW,EACX,MAAM,MAAM,CACb;AAED;AACA;AAEE;AACA;AACA;AACA,KAAK,EACL,MAAM,GAAG,CACV;AAED;AACA,CACE,KAAK,EACL,MAAM,KAAK,CACZ,EAED;AACE;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAElB;AACA,MAAM,aAAa,CACpB;AAED;AACA;AACE;AACA;AACA;AACA,WAAW,EACX,SAASU,gBAAgBA,CAAA,EAAI;EAC3B;EACA,OAAO,CAAC,SAAS,CAACC,IAAI,CAAC,IAAI;EACzB;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EAAA,EACE;;EAEF;EACA;EAAA,EACE,GAAG;AACT,CAAC,CACF;AAED;AACA;AACE;AACA,yBAAyB;AAEzB;AACA;;AAEA;AACA,CAACC,CAAC,EAAEC,KAAK,EAAEC,GAAG,KAAKD,KAAK,GAAG,CAAC,GAAGC,GAAG,CAACR;;AAEjC;AACA;AACA;AACA;AACA;AAAA,EACE;;AAEF;AACA;;AAEA;AAAA,EACE,OAAO,CACZ;AAED;AACA;AACE;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAE1B;AACA;AACA,CAACM,CAAC,EAAEG,EAAE,EAAEC,EAAE,KAAK;EACb;EACA;EACA;EACA;EACA;EACA,MAAMC,SAAS,GAAGD,EAAE,CAACjB,OAAO,CAAC,OAAO,EAAE,SAAS,CAAC;EAChD,OAAOgB,EAAE,GAAGE,SAAS;AACvB,CAAC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"},"metadata":{},"sourceType":"script","externalDependencies":[]}