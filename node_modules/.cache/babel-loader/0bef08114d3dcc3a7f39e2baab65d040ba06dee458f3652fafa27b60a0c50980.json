{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __markAsModule = target => __defProp(target, \"__esModule\", {\n  value: true\n});\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {\n    exports: {}\n  }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __reExport = (target, module, copyDefault, desc) => {\n  if (module && typeof module === \"object\" || typeof module === \"function\") {\n    for (let key of __getOwnPropNames(module)) if (!__hasOwnProp.call(target, key) && (copyDefault || key !== \"default\")) __defProp(target, key, {\n      get: () => module[key],\n      enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable\n    });\n  }\n  return target;\n};\nvar __toCommonJS = /* @__PURE__ */(cache2 => {\n  return (module, temp) => {\n    return cache2 && cache2.get(module) || (temp = __reExport(__markAsModule({}), module, 1), cache2 && cache2.set(module, temp), temp);\n  };\n})(typeof WeakMap !== \"undefined\" ? /* @__PURE__ */new WeakMap() : 0);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/lib/args/pathspec.ts\nfunction pathspec(...paths) {\n  const key = new String(paths);\n  cache.set(key, paths);\n  return key;\n}\nfunction isPathSpec(path) {\n  return path instanceof String && cache.has(path);\n}\nfunction toPaths(pathSpec) {\n  return cache.get(pathSpec) || [];\n}\nvar cache;\nvar init_pathspec = __esm({\n  \"src/lib/args/pathspec.ts\"() {\n    cache = /* @__PURE__ */new WeakMap();\n  }\n});\n\n// src/lib/errors/git-error.ts\nvar GitError;\nvar init_git_error = __esm({\n  \"src/lib/errors/git-error.ts\"() {\n    GitError = class extends Error {\n      constructor(task, message) {\n        super(message);\n        this.task = task;\n        Object.setPrototypeOf(this, new.target.prototype);\n      }\n    };\n  }\n});\n\n// src/lib/errors/git-response-error.ts\nvar GitResponseError;\nvar init_git_response_error = __esm({\n  \"src/lib/errors/git-response-error.ts\"() {\n    init_git_error();\n    GitResponseError = class extends GitError {\n      constructor(git, message) {\n        super(void 0, message || String(git));\n        this.git = git;\n      }\n    };\n  }\n});\n\n// src/lib/errors/task-configuration-error.ts\nvar TaskConfigurationError;\nvar init_task_configuration_error = __esm({\n  \"src/lib/errors/task-configuration-error.ts\"() {\n    init_git_error();\n    TaskConfigurationError = class extends GitError {\n      constructor(message) {\n        super(void 0, message);\n      }\n    };\n  }\n});\n\n// src/lib/utils/util.ts\nimport { exists, FOLDER } from \"@kwsites/file-exists\";\nfunction asFunction(source) {\n  return typeof source === \"function\" ? source : NOOP;\n}\nfunction isUserFunction(source) {\n  return typeof source === \"function\" && source !== NOOP;\n}\nfunction splitOn(input, char) {\n  const index = input.indexOf(char);\n  if (index <= 0) {\n    return [input, \"\"];\n  }\n  return [input.substr(0, index), input.substr(index + 1)];\n}\nfunction first(input, offset = 0) {\n  return isArrayLike(input) && input.length > offset ? input[offset] : void 0;\n}\nfunction last(input, offset = 0) {\n  if (isArrayLike(input) && input.length > offset) {\n    return input[input.length - 1 - offset];\n  }\n}\nfunction isArrayLike(input) {\n  return !!(input && typeof input.length === \"number\");\n}\nfunction toLinesWithContent(input = \"\", trimmed2 = true, separator = \"\\n\") {\n  return input.split(separator).reduce((output, line) => {\n    const lineContent = trimmed2 ? line.trim() : line;\n    if (lineContent) {\n      output.push(lineContent);\n    }\n    return output;\n  }, []);\n}\nfunction forEachLineWithContent(input, callback) {\n  return toLinesWithContent(input, true).map(line => callback(line));\n}\nfunction folderExists(path) {\n  return exists(path, FOLDER);\n}\nfunction append(target, item) {\n  if (Array.isArray(target)) {\n    if (!target.includes(item)) {\n      target.push(item);\n    }\n  } else {\n    target.add(item);\n  }\n  return item;\n}\nfunction including(target, item) {\n  if (Array.isArray(target) && !target.includes(item)) {\n    target.push(item);\n  }\n  return target;\n}\nfunction remove(target, item) {\n  if (Array.isArray(target)) {\n    const index = target.indexOf(item);\n    if (index >= 0) {\n      target.splice(index, 1);\n    }\n  } else {\n    target.delete(item);\n  }\n  return item;\n}\nfunction asArray(source) {\n  return Array.isArray(source) ? source : [source];\n}\nfunction asStringArray(source) {\n  return asArray(source).map(String);\n}\nfunction asNumber(source, onNaN = 0) {\n  if (source == null) {\n    return onNaN;\n  }\n  const num = parseInt(source, 10);\n  return isNaN(num) ? onNaN : num;\n}\nfunction prefixedArray(input, prefix) {\n  const output = [];\n  for (let i = 0, max = input.length; i < max; i++) {\n    output.push(prefix, input[i]);\n  }\n  return output;\n}\nfunction bufferToString(input) {\n  return (Array.isArray(input) ? Buffer.concat(input) : input).toString(\"utf-8\");\n}\nfunction pick(source, properties) {\n  return Object.assign({}, ...properties.map(property => property in source ? {\n    [property]: source[property]\n  } : {}));\n}\nfunction delay(duration = 0) {\n  return new Promise(done => setTimeout(done, duration));\n}\nvar NULL, NOOP, objectToString;\nvar init_util = __esm({\n  \"src/lib/utils/util.ts\"() {\n    NULL = \"\\0\";\n    NOOP = () => {};\n    objectToString = Object.prototype.toString.call.bind(Object.prototype.toString);\n  }\n});\n\n// src/lib/utils/argument-filters.ts\nfunction filterType(input, filter, def) {\n  if (filter(input)) {\n    return input;\n  }\n  return arguments.length > 2 ? def : void 0;\n}\nfunction filterPrimitives(input, omit) {\n  const type = isPathSpec(input) ? \"string\" : typeof input;\n  return /number|string|boolean/.test(type) && (!omit || !omit.includes(type));\n}\nfunction filterPlainObject(input) {\n  return !!input && objectToString(input) === \"[object Object]\";\n}\nfunction filterFunction(input) {\n  return typeof input === \"function\";\n}\nvar filterArray, filterString, filterStringArray, filterStringOrStringArray, filterHasLength;\nvar init_argument_filters = __esm({\n  \"src/lib/utils/argument-filters.ts\"() {\n    init_util();\n    init_pathspec();\n    filterArray = input => {\n      return Array.isArray(input);\n    };\n    filterString = input => {\n      return typeof input === \"string\";\n    };\n    filterStringArray = input => {\n      return Array.isArray(input) && input.every(filterString);\n    };\n    filterStringOrStringArray = input => {\n      return filterString(input) || Array.isArray(input) && input.every(filterString);\n    };\n    filterHasLength = input => {\n      if (input == null || \"number|boolean|function\".includes(typeof input)) {\n        return false;\n      }\n      return Array.isArray(input) || typeof input === \"string\" || typeof input.length === \"number\";\n    };\n  }\n});\n\n// src/lib/utils/exit-codes.ts\nvar ExitCodes;\nvar init_exit_codes = __esm({\n  \"src/lib/utils/exit-codes.ts\"() {\n    ExitCodes = /* @__PURE__ */(ExitCodes2 => {\n      ExitCodes2[ExitCodes2[\"SUCCESS\"] = 0] = \"SUCCESS\";\n      ExitCodes2[ExitCodes2[\"ERROR\"] = 1] = \"ERROR\";\n      ExitCodes2[ExitCodes2[\"NOT_FOUND\"] = -2] = \"NOT_FOUND\";\n      ExitCodes2[ExitCodes2[\"UNCLEAN\"] = 128] = \"UNCLEAN\";\n      return ExitCodes2;\n    })(ExitCodes || {});\n  }\n});\n\n// src/lib/utils/git-output-streams.ts\nvar GitOutputStreams;\nvar init_git_output_streams = __esm({\n  \"src/lib/utils/git-output-streams.ts\"() {\n    GitOutputStreams = class {\n      constructor(stdOut, stdErr) {\n        this.stdOut = stdOut;\n        this.stdErr = stdErr;\n      }\n      asStrings() {\n        return new GitOutputStreams(this.stdOut.toString(\"utf8\"), this.stdErr.toString(\"utf8\"));\n      }\n    };\n  }\n});\n\n// src/lib/utils/line-parser.ts\nvar LineParser, RemoteLineParser;\nvar init_line_parser = __esm({\n  \"src/lib/utils/line-parser.ts\"() {\n    LineParser = class {\n      constructor(regExp, useMatches) {\n        this.matches = [];\n        this.parse = (line, target) => {\n          this.resetMatches();\n          if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {\n            return false;\n          }\n          return this.useMatches(target, this.prepareMatches()) !== false;\n        };\n        this._regExp = Array.isArray(regExp) ? regExp : [regExp];\n        if (useMatches) {\n          this.useMatches = useMatches;\n        }\n      }\n      useMatches(target, match) {\n        throw new Error(`LineParser:useMatches not implemented`);\n      }\n      resetMatches() {\n        this.matches.length = 0;\n      }\n      prepareMatches() {\n        return this.matches;\n      }\n      addMatch(reg, index, line) {\n        const matched = line && reg.exec(line);\n        if (matched) {\n          this.pushMatch(index, matched);\n        }\n        return !!matched;\n      }\n      pushMatch(_index, matched) {\n        this.matches.push(...matched.slice(1));\n      }\n    };\n    RemoteLineParser = class extends LineParser {\n      addMatch(reg, index, line) {\n        return /^remote:\\s/.test(String(line)) && super.addMatch(reg, index, line);\n      }\n      pushMatch(index, matched) {\n        if (index > 0 || matched.length > 1) {\n          super.pushMatch(index, matched);\n        }\n      }\n    };\n  }\n});\n\n// src/lib/utils/simple-git-options.ts\nfunction createInstanceConfig(...options) {\n  const baseDir = process.cwd();\n  const config = Object.assign(__spreadValues({\n    baseDir\n  }, defaultOptions), ...options.filter(o => typeof o === \"object\" && o));\n  config.baseDir = config.baseDir || baseDir;\n  config.trimmed = config.trimmed === true;\n  return config;\n}\nvar defaultOptions;\nvar init_simple_git_options = __esm({\n  \"src/lib/utils/simple-git-options.ts\"() {\n    defaultOptions = {\n      binary: \"git\",\n      maxConcurrentProcesses: 5,\n      config: [],\n      trimmed: false\n    };\n  }\n});\n\n// src/lib/utils/task-options.ts\nfunction appendTaskOptions(options, commands = []) {\n  if (!filterPlainObject(options)) {\n    return commands;\n  }\n  return Object.keys(options).reduce((commands2, key) => {\n    const value = options[key];\n    if (isPathSpec(value)) {\n      commands2.push(value);\n    } else if (filterPrimitives(value, [\"boolean\"])) {\n      commands2.push(key + \"=\" + value);\n    } else {\n      commands2.push(key);\n    }\n    return commands2;\n  }, commands);\n}\nfunction getTrailingOptions(args, initialPrimitive = 0, objectOnly = false) {\n  const command = [];\n  for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {\n    if (\"string|number\".includes(typeof args[i])) {\n      command.push(String(args[i]));\n    }\n  }\n  appendTaskOptions(trailingOptionsArgument(args), command);\n  if (!objectOnly) {\n    command.push(...trailingArrayArgument(args));\n  }\n  return command;\n}\nfunction trailingArrayArgument(args) {\n  const hasTrailingCallback = typeof last(args) === \"function\";\n  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterArray, []);\n}\nfunction trailingOptionsArgument(args) {\n  const hasTrailingCallback = filterFunction(last(args));\n  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);\n}\nfunction trailingFunctionArgument(args, includeNoop = true) {\n  const callback = asFunction(last(args));\n  return includeNoop || isUserFunction(callback) ? callback : void 0;\n}\nvar init_task_options = __esm({\n  \"src/lib/utils/task-options.ts\"() {\n    init_argument_filters();\n    init_util();\n    init_pathspec();\n  }\n});\n\n// src/lib/utils/task-parser.ts\nfunction callTaskParser(parser3, streams) {\n  return parser3(streams.stdOut, streams.stdErr);\n}\nfunction parseStringResponse(result, parsers12, texts, trim = true) {\n  asArray(texts).forEach(text => {\n    for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {\n      const line = (offset = 0) => {\n        if (i + offset >= max) {\n          return;\n        }\n        return lines[i + offset];\n      };\n      parsers12.some(({\n        parse\n      }) => parse(line, result));\n    }\n  });\n  return result;\n}\nvar init_task_parser = __esm({\n  \"src/lib/utils/task-parser.ts\"() {\n    init_util();\n  }\n});\n\n// src/lib/utils/index.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  ExitCodes: () => ExitCodes,\n  GitOutputStreams: () => GitOutputStreams,\n  LineParser: () => LineParser,\n  NOOP: () => NOOP,\n  NULL: () => NULL,\n  RemoteLineParser: () => RemoteLineParser,\n  append: () => append,\n  appendTaskOptions: () => appendTaskOptions,\n  asArray: () => asArray,\n  asFunction: () => asFunction,\n  asNumber: () => asNumber,\n  asStringArray: () => asStringArray,\n  bufferToString: () => bufferToString,\n  callTaskParser: () => callTaskParser,\n  createInstanceConfig: () => createInstanceConfig,\n  delay: () => delay,\n  filterArray: () => filterArray,\n  filterFunction: () => filterFunction,\n  filterHasLength: () => filterHasLength,\n  filterPlainObject: () => filterPlainObject,\n  filterPrimitives: () => filterPrimitives,\n  filterString: () => filterString,\n  filterStringArray: () => filterStringArray,\n  filterStringOrStringArray: () => filterStringOrStringArray,\n  filterType: () => filterType,\n  first: () => first,\n  folderExists: () => folderExists,\n  forEachLineWithContent: () => forEachLineWithContent,\n  getTrailingOptions: () => getTrailingOptions,\n  including: () => including,\n  isUserFunction: () => isUserFunction,\n  last: () => last,\n  objectToString: () => objectToString,\n  parseStringResponse: () => parseStringResponse,\n  pick: () => pick,\n  prefixedArray: () => prefixedArray,\n  remove: () => remove,\n  splitOn: () => splitOn,\n  toLinesWithContent: () => toLinesWithContent,\n  trailingFunctionArgument: () => trailingFunctionArgument,\n  trailingOptionsArgument: () => trailingOptionsArgument\n});\nvar init_utils = __esm({\n  \"src/lib/utils/index.ts\"() {\n    init_argument_filters();\n    init_exit_codes();\n    init_git_output_streams();\n    init_line_parser();\n    init_simple_git_options();\n    init_task_options();\n    init_task_parser();\n    init_util();\n  }\n});\n\n// src/lib/tasks/check-is-repo.ts\nvar check_is_repo_exports = {};\n__export(check_is_repo_exports, {\n  CheckRepoActions: () => CheckRepoActions,\n  checkIsBareRepoTask: () => checkIsBareRepoTask,\n  checkIsRepoRootTask: () => checkIsRepoRootTask,\n  checkIsRepoTask: () => checkIsRepoTask\n});\nfunction checkIsRepoTask(action) {\n  switch (action) {\n    case \"bare\" /* BARE */:\n      return checkIsBareRepoTask();\n    case \"root\" /* IS_REPO_ROOT */:\n      return checkIsRepoRootTask();\n  }\n  const commands = [\"rev-parse\", \"--is-inside-work-tree\"];\n  return {\n    commands,\n    format: \"utf-8\",\n    onError,\n    parser\n  };\n}\nfunction checkIsRepoRootTask() {\n  const commands = [\"rev-parse\", \"--git-dir\"];\n  return {\n    commands,\n    format: \"utf-8\",\n    onError,\n    parser(path) {\n      return /^\\.(git)?$/.test(path.trim());\n    }\n  };\n}\nfunction checkIsBareRepoTask() {\n  const commands = [\"rev-parse\", \"--is-bare-repository\"];\n  return {\n    commands,\n    format: \"utf-8\",\n    onError,\n    parser\n  };\n}\nfunction isNotRepoMessage(error) {\n  return /(Not a git repository|Kein Git-Repository)/i.test(String(error));\n}\nvar CheckRepoActions, onError, parser;\nvar init_check_is_repo = __esm({\n  \"src/lib/tasks/check-is-repo.ts\"() {\n    init_utils();\n    CheckRepoActions = /* @__PURE__ */(CheckRepoActions2 => {\n      CheckRepoActions2[\"BARE\"] = \"bare\";\n      CheckRepoActions2[\"IN_TREE\"] = \"tree\";\n      CheckRepoActions2[\"IS_REPO_ROOT\"] = \"root\";\n      return CheckRepoActions2;\n    })(CheckRepoActions || {});\n    onError = ({\n      exitCode\n    }, error, done, fail) => {\n      if (exitCode === 128 /* UNCLEAN */ && isNotRepoMessage(error)) {\n        return done(Buffer.from(\"false\"));\n      }\n      fail(error);\n    };\n    parser = text => {\n      return text.trim() === \"true\";\n    };\n  }\n});\n\n// src/lib/responses/CleanSummary.ts\nfunction cleanSummaryParser(dryRun, text) {\n  const summary = new CleanResponse(dryRun);\n  const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;\n  toLinesWithContent(text).forEach(line => {\n    const removed = line.replace(regexp, \"\");\n    summary.paths.push(removed);\n    (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);\n  });\n  return summary;\n}\nvar CleanResponse, removalRegexp, dryRunRemovalRegexp, isFolderRegexp;\nvar init_CleanSummary = __esm({\n  \"src/lib/responses/CleanSummary.ts\"() {\n    init_utils();\n    CleanResponse = class {\n      constructor(dryRun) {\n        this.dryRun = dryRun;\n        this.paths = [];\n        this.files = [];\n        this.folders = [];\n      }\n    };\n    removalRegexp = /^[a-z]+\\s*/i;\n    dryRunRemovalRegexp = /^[a-z]+\\s+[a-z]+\\s*/i;\n    isFolderRegexp = /\\/$/;\n  }\n});\n\n// src/lib/tasks/task.ts\nvar task_exports = {};\n__export(task_exports, {\n  EMPTY_COMMANDS: () => EMPTY_COMMANDS,\n  adhocExecTask: () => adhocExecTask,\n  configurationErrorTask: () => configurationErrorTask,\n  isBufferTask: () => isBufferTask,\n  isEmptyTask: () => isEmptyTask,\n  straightThroughBufferTask: () => straightThroughBufferTask,\n  straightThroughStringTask: () => straightThroughStringTask\n});\nfunction adhocExecTask(parser3) {\n  return {\n    commands: EMPTY_COMMANDS,\n    format: \"empty\",\n    parser: parser3\n  };\n}\nfunction configurationErrorTask(error) {\n  return {\n    commands: EMPTY_COMMANDS,\n    format: \"empty\",\n    parser() {\n      throw typeof error === \"string\" ? new TaskConfigurationError(error) : error;\n    }\n  };\n}\nfunction straightThroughStringTask(commands, trimmed2 = false) {\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return trimmed2 ? String(text).trim() : text;\n    }\n  };\n}\nfunction straightThroughBufferTask(commands) {\n  return {\n    commands,\n    format: \"buffer\",\n    parser(buffer) {\n      return buffer;\n    }\n  };\n}\nfunction isBufferTask(task) {\n  return task.format === \"buffer\";\n}\nfunction isEmptyTask(task) {\n  return task.format === \"empty\" || !task.commands.length;\n}\nvar EMPTY_COMMANDS;\nvar init_task = __esm({\n  \"src/lib/tasks/task.ts\"() {\n    init_task_configuration_error();\n    EMPTY_COMMANDS = [];\n  }\n});\n\n// src/lib/tasks/clean.ts\nvar clean_exports = {};\n__export(clean_exports, {\n  CONFIG_ERROR_INTERACTIVE_MODE: () => CONFIG_ERROR_INTERACTIVE_MODE,\n  CONFIG_ERROR_MODE_REQUIRED: () => CONFIG_ERROR_MODE_REQUIRED,\n  CONFIG_ERROR_UNKNOWN_OPTION: () => CONFIG_ERROR_UNKNOWN_OPTION,\n  CleanOptions: () => CleanOptions,\n  cleanTask: () => cleanTask,\n  cleanWithOptionsTask: () => cleanWithOptionsTask,\n  isCleanOptionsArray: () => isCleanOptionsArray\n});\nfunction cleanWithOptionsTask(mode, customArgs) {\n  const {\n    cleanMode,\n    options,\n    valid\n  } = getCleanOptions(mode);\n  if (!cleanMode) {\n    return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);\n  }\n  if (!valid.options) {\n    return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));\n  }\n  options.push(...customArgs);\n  if (options.some(isInteractiveMode)) {\n    return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);\n  }\n  return cleanTask(cleanMode, options);\n}\nfunction cleanTask(mode, customArgs) {\n  const commands = [\"clean\", `-${mode}`, ...customArgs];\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return cleanSummaryParser(mode === \"n\" /* DRY_RUN */, text);\n    }\n  };\n}\nfunction isCleanOptionsArray(input) {\n  return Array.isArray(input) && input.every(test => CleanOptionValues.has(test));\n}\nfunction getCleanOptions(input) {\n  let cleanMode;\n  let options = [];\n  let valid = {\n    cleanMode: false,\n    options: true\n  };\n  input.replace(/[^a-z]i/g, \"\").split(\"\").forEach(char => {\n    if (isCleanMode(char)) {\n      cleanMode = char;\n      valid.cleanMode = true;\n    } else {\n      valid.options = valid.options && isKnownOption(options[options.length] = `-${char}`);\n    }\n  });\n  return {\n    cleanMode,\n    options,\n    valid\n  };\n}\nfunction isCleanMode(cleanMode) {\n  return cleanMode === \"f\" /* FORCE */ || cleanMode === \"n\" /* DRY_RUN */;\n}\nfunction isKnownOption(option) {\n  return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));\n}\nfunction isInteractiveMode(option) {\n  if (/^-[^\\-]/.test(option)) {\n    return option.indexOf(\"i\") > 0;\n  }\n  return option === \"--interactive\";\n}\nvar CONFIG_ERROR_INTERACTIVE_MODE, CONFIG_ERROR_MODE_REQUIRED, CONFIG_ERROR_UNKNOWN_OPTION, CleanOptions, CleanOptionValues;\nvar init_clean = __esm({\n  \"src/lib/tasks/clean.ts\"() {\n    init_CleanSummary();\n    init_utils();\n    init_task();\n    CONFIG_ERROR_INTERACTIVE_MODE = \"Git clean interactive mode is not supported\";\n    CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter (\"n\" or \"f\") is required';\n    CONFIG_ERROR_UNKNOWN_OPTION = \"Git clean unknown option found in: \";\n    CleanOptions = /* @__PURE__ */(CleanOptions2 => {\n      CleanOptions2[\"DRY_RUN\"] = \"n\";\n      CleanOptions2[\"FORCE\"] = \"f\";\n      CleanOptions2[\"IGNORED_INCLUDED\"] = \"x\";\n      CleanOptions2[\"IGNORED_ONLY\"] = \"X\";\n      CleanOptions2[\"EXCLUDING\"] = \"e\";\n      CleanOptions2[\"QUIET\"] = \"q\";\n      CleanOptions2[\"RECURSIVE\"] = \"d\";\n      return CleanOptions2;\n    })(CleanOptions || {});\n    CleanOptionValues = /* @__PURE__ */new Set([\"i\", ...asStringArray(Object.values(CleanOptions))]);\n  }\n});\n\n// src/lib/responses/ConfigList.ts\nfunction configListParser(text) {\n  const config = new ConfigList();\n  for (const item of configParser(text)) {\n    config.addValue(item.file, String(item.key), item.value);\n  }\n  return config;\n}\nfunction configGetParser(text, key) {\n  let value = null;\n  const values = [];\n  const scopes = /* @__PURE__ */new Map();\n  for (const item of configParser(text, key)) {\n    if (item.key !== key) {\n      continue;\n    }\n    values.push(value = item.value);\n    if (!scopes.has(item.file)) {\n      scopes.set(item.file, []);\n    }\n    scopes.get(item.file).push(value);\n  }\n  return {\n    key,\n    paths: Array.from(scopes.keys()),\n    scopes,\n    value,\n    values\n  };\n}\nfunction configFilePath(filePath) {\n  return filePath.replace(/^(file):/, \"\");\n}\nfunction* configParser(text, requestedKey = null) {\n  const lines = text.split(\"\\0\");\n  for (let i = 0, max = lines.length - 1; i < max;) {\n    const file = configFilePath(lines[i++]);\n    let value = lines[i++];\n    let key = requestedKey;\n    if (value.includes(\"\\n\")) {\n      const line = splitOn(value, \"\\n\");\n      key = line[0];\n      value = line[1];\n    }\n    yield {\n      file,\n      key,\n      value\n    };\n  }\n}\nvar ConfigList;\nvar init_ConfigList = __esm({\n  \"src/lib/responses/ConfigList.ts\"() {\n    init_utils();\n    ConfigList = class {\n      constructor() {\n        this.files = [];\n        this.values = /* @__PURE__ */Object.create(null);\n      }\n      get all() {\n        if (!this._all) {\n          this._all = this.files.reduce((all, file) => {\n            return Object.assign(all, this.values[file]);\n          }, {});\n        }\n        return this._all;\n      }\n      addFile(file) {\n        if (!(file in this.values)) {\n          const latest = last(this.files);\n          this.values[file] = latest ? Object.create(this.values[latest]) : {};\n          this.files.push(file);\n        }\n        return this.values[file];\n      }\n      addValue(file, key, value) {\n        const values = this.addFile(file);\n        if (!values.hasOwnProperty(key)) {\n          values[key] = value;\n        } else if (Array.isArray(values[key])) {\n          values[key].push(value);\n        } else {\n          values[key] = [values[key], value];\n        }\n        this._all = void 0;\n      }\n    };\n  }\n});\n\n// src/lib/tasks/config.ts\nfunction asConfigScope(scope, fallback) {\n  if (typeof scope === \"string\" && GitConfigScope.hasOwnProperty(scope)) {\n    return scope;\n  }\n  return fallback;\n}\nfunction addConfigTask(key, value, append2, scope) {\n  const commands = [\"config\", `--${scope}`];\n  if (append2) {\n    commands.push(\"--add\");\n  }\n  commands.push(key, value);\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return text;\n    }\n  };\n}\nfunction getConfigTask(key, scope) {\n  const commands = [\"config\", \"--null\", \"--show-origin\", \"--get-all\", key];\n  if (scope) {\n    commands.splice(1, 0, `--${scope}`);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return configGetParser(text, key);\n    }\n  };\n}\nfunction listConfigTask(scope) {\n  const commands = [\"config\", \"--list\", \"--show-origin\", \"--null\"];\n  if (scope) {\n    commands.push(`--${scope}`);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return configListParser(text);\n    }\n  };\n}\nfunction config_default() {\n  return {\n    addConfig(key, value, ...rest) {\n      return this._runTask(addConfigTask(key, value, rest[0] === true, asConfigScope(rest[1], \"local\" /* local */)), trailingFunctionArgument(arguments));\n    },\n    getConfig(key, scope) {\n      return this._runTask(getConfigTask(key, asConfigScope(scope, void 0)), trailingFunctionArgument(arguments));\n    },\n    listConfig(...rest) {\n      return this._runTask(listConfigTask(asConfigScope(rest[0], void 0)), trailingFunctionArgument(arguments));\n    }\n  };\n}\nvar GitConfigScope;\nvar init_config = __esm({\n  \"src/lib/tasks/config.ts\"() {\n    init_ConfigList();\n    init_utils();\n    GitConfigScope = /* @__PURE__ */(GitConfigScope2 => {\n      GitConfigScope2[\"system\"] = \"system\";\n      GitConfigScope2[\"global\"] = \"global\";\n      GitConfigScope2[\"local\"] = \"local\";\n      GitConfigScope2[\"worktree\"] = \"worktree\";\n      return GitConfigScope2;\n    })(GitConfigScope || {});\n  }\n});\n\n// src/lib/tasks/grep.ts\nfunction grepQueryBuilder(...params) {\n  return new GrepQuery().param(...params);\n}\nfunction parseGrep(grep) {\n  const paths = /* @__PURE__ */new Set();\n  const results = {};\n  forEachLineWithContent(grep, input => {\n    const [path, line, preview] = input.split(NULL);\n    paths.add(path);\n    (results[path] = results[path] || []).push({\n      line: asNumber(line),\n      path,\n      preview\n    });\n  });\n  return {\n    paths,\n    results\n  };\n}\nfunction grep_default() {\n  return {\n    grep(searchTerm) {\n      const then = trailingFunctionArgument(arguments);\n      const options = getTrailingOptions(arguments);\n      for (const option of disallowedOptions) {\n        if (options.includes(option)) {\n          return this._runTask(configurationErrorTask(`git.grep: use of \"${option}\" is not supported.`), then);\n        }\n      }\n      if (typeof searchTerm === \"string\") {\n        searchTerm = grepQueryBuilder().param(searchTerm);\n      }\n      const commands = [\"grep\", \"--null\", \"-n\", \"--full-name\", ...options, ...searchTerm];\n      return this._runTask({\n        commands,\n        format: \"utf-8\",\n        parser(stdOut) {\n          return parseGrep(stdOut);\n        }\n      }, then);\n    }\n  };\n}\nvar disallowedOptions, Query, _a, GrepQuery;\nvar init_grep = __esm({\n  \"src/lib/tasks/grep.ts\"() {\n    init_utils();\n    init_task();\n    disallowedOptions = [\"-h\"];\n    Query = Symbol(\"grepQuery\");\n    GrepQuery = class {\n      constructor() {\n        this[_a] = [];\n      }\n      *[(_a = Query, Symbol.iterator)]() {\n        for (const query of this[Query]) {\n          yield query;\n        }\n      }\n      and(...and) {\n        and.length && this[Query].push(\"--and\", \"(\", ...prefixedArray(and, \"-e\"), \")\");\n        return this;\n      }\n      param(...param) {\n        this[Query].push(...prefixedArray(param, \"-e\"));\n        return this;\n      }\n    };\n  }\n});\n\n// src/lib/tasks/reset.ts\nvar reset_exports = {};\n__export(reset_exports, {\n  ResetMode: () => ResetMode,\n  getResetMode: () => getResetMode,\n  resetTask: () => resetTask\n});\nfunction resetTask(mode, customArgs) {\n  const commands = [\"reset\"];\n  if (isValidResetMode(mode)) {\n    commands.push(`--${mode}`);\n  }\n  commands.push(...customArgs);\n  return straightThroughStringTask(commands);\n}\nfunction getResetMode(mode) {\n  if (isValidResetMode(mode)) {\n    return mode;\n  }\n  switch (typeof mode) {\n    case \"string\":\n    case \"undefined\":\n      return \"soft\" /* SOFT */;\n  }\n  return;\n}\nfunction isValidResetMode(mode) {\n  return ResetModes.includes(mode);\n}\nvar ResetMode, ResetModes;\nvar init_reset = __esm({\n  \"src/lib/tasks/reset.ts\"() {\n    init_task();\n    ResetMode = /* @__PURE__ */(ResetMode2 => {\n      ResetMode2[\"MIXED\"] = \"mixed\";\n      ResetMode2[\"SOFT\"] = \"soft\";\n      ResetMode2[\"HARD\"] = \"hard\";\n      ResetMode2[\"MERGE\"] = \"merge\";\n      ResetMode2[\"KEEP\"] = \"keep\";\n      return ResetMode2;\n    })(ResetMode || {});\n    ResetModes = Array.from(Object.values(ResetMode));\n  }\n});\n\n// src/lib/git-logger.ts\nimport debug from \"debug\";\nfunction createLog() {\n  return debug(\"simple-git\");\n}\nfunction prefixedLogger(to, prefix, forward) {\n  if (!prefix || !String(prefix).replace(/\\s*/, \"\")) {\n    return !forward ? to : (message, ...args) => {\n      to(message, ...args);\n      forward(message, ...args);\n    };\n  }\n  return (message, ...args) => {\n    to(`%s ${message}`, prefix, ...args);\n    if (forward) {\n      forward(message, ...args);\n    }\n  };\n}\nfunction childLoggerName(name, childDebugger, {\n  namespace: parentNamespace\n}) {\n  if (typeof name === \"string\") {\n    return name;\n  }\n  const childNamespace = childDebugger && childDebugger.namespace || \"\";\n  if (childNamespace.startsWith(parentNamespace)) {\n    return childNamespace.substr(parentNamespace.length + 1);\n  }\n  return childNamespace || parentNamespace;\n}\nfunction createLogger(label, verbose, initialStep, infoDebugger = createLog()) {\n  const labelPrefix = label && `[${label}]` || \"\";\n  const spawned = [];\n  const debugDebugger = typeof verbose === \"string\" ? infoDebugger.extend(verbose) : verbose;\n  const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);\n  return step(initialStep);\n  function sibling(name, initial) {\n    return append(spawned, createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger));\n  }\n  function step(phase) {\n    const stepPrefix = phase && `[${phase}]` || \"\";\n    const debug2 = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;\n    const info = prefixedLogger(infoDebugger, `${labelPrefix} ${stepPrefix}`, debug2);\n    return Object.assign(debugDebugger ? debug2 : info, {\n      label,\n      sibling,\n      info,\n      step\n    });\n  }\n}\nvar init_git_logger = __esm({\n  \"src/lib/git-logger.ts\"() {\n    init_utils();\n    debug.formatters.L = value => String(filterHasLength(value) ? value.length : \"-\");\n    debug.formatters.B = value => {\n      if (Buffer.isBuffer(value)) {\n        return value.toString(\"utf8\");\n      }\n      return objectToString(value);\n    };\n  }\n});\n\n// src/lib/runners/tasks-pending-queue.ts\nvar _TasksPendingQueue, TasksPendingQueue;\nvar init_tasks_pending_queue = __esm({\n  \"src/lib/runners/tasks-pending-queue.ts\"() {\n    init_git_error();\n    init_git_logger();\n    _TasksPendingQueue = class {\n      constructor(logLabel = \"GitExecutor\") {\n        this.logLabel = logLabel;\n        this._queue = /* @__PURE__ */new Map();\n      }\n      withProgress(task) {\n        return this._queue.get(task);\n      }\n      createProgress(task) {\n        const name = _TasksPendingQueue.getName(task.commands[0]);\n        const logger = createLogger(this.logLabel, name);\n        return {\n          task,\n          logger,\n          name\n        };\n      }\n      push(task) {\n        const progress = this.createProgress(task);\n        progress.logger(\"Adding task to the queue, commands = %o\", task.commands);\n        this._queue.set(task, progress);\n        return progress;\n      }\n      fatal(err) {\n        for (const [task, {\n          logger\n        }] of Array.from(this._queue.entries())) {\n          if (task === err.task) {\n            logger.info(`Failed %o`, err);\n            logger(`Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`);\n          } else {\n            logger.info(`A fatal exception occurred in a previous task, the queue has been purged: %o`, err.message);\n          }\n          this.complete(task);\n        }\n        if (this._queue.size !== 0) {\n          throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);\n        }\n      }\n      complete(task) {\n        const progress = this.withProgress(task);\n        if (progress) {\n          this._queue.delete(task);\n        }\n      }\n      attempt(task) {\n        const progress = this.withProgress(task);\n        if (!progress) {\n          throw new GitError(void 0, \"TasksPendingQueue: attempt called for an unknown task\");\n        }\n        progress.logger(\"Starting task\");\n        return progress;\n      }\n      static getName(name = \"empty\") {\n        return `task:${name}:${++_TasksPendingQueue.counter}`;\n      }\n    };\n    TasksPendingQueue = _TasksPendingQueue;\n    TasksPendingQueue.counter = 0;\n  }\n});\n\n// src/lib/runners/git-executor-chain.ts\nimport { spawn } from \"child_process\";\nfunction pluginContext(task, commands) {\n  return {\n    method: first(task.commands) || \"\",\n    commands\n  };\n}\nfunction onErrorReceived(target, logger) {\n  return err => {\n    logger(`[ERROR] child process exception %o`, err);\n    target.push(Buffer.from(String(err.stack), \"ascii\"));\n  };\n}\nfunction onDataReceived(target, name, logger, output) {\n  return buffer => {\n    logger(`%s received %L bytes`, name, buffer);\n    output(`%B`, buffer);\n    target.push(buffer);\n  };\n}\nvar GitExecutorChain;\nvar init_git_executor_chain = __esm({\n  \"src/lib/runners/git-executor-chain.ts\"() {\n    init_git_error();\n    init_task();\n    init_utils();\n    init_tasks_pending_queue();\n    GitExecutorChain = class {\n      constructor(_executor, _scheduler, _plugins) {\n        this._executor = _executor;\n        this._scheduler = _scheduler;\n        this._plugins = _plugins;\n        this._chain = Promise.resolve();\n        this._queue = new TasksPendingQueue();\n      }\n      get binary() {\n        return this._executor.binary;\n      }\n      get cwd() {\n        return this._cwd || this._executor.cwd;\n      }\n      set cwd(cwd) {\n        this._cwd = cwd;\n      }\n      get env() {\n        return this._executor.env;\n      }\n      get outputHandler() {\n        return this._executor.outputHandler;\n      }\n      chain() {\n        return this;\n      }\n      push(task) {\n        this._queue.push(task);\n        return this._chain = this._chain.then(() => this.attemptTask(task));\n      }\n      attemptTask(task) {\n        return __async(this, null, function* () {\n          const onScheduleComplete = yield this._scheduler.next();\n          const onQueueComplete = () => this._queue.complete(task);\n          try {\n            const {\n              logger\n            } = this._queue.attempt(task);\n            return yield isEmptyTask(task) ? this.attemptEmptyTask(task, logger) : this.attemptRemoteTask(task, logger);\n          } catch (e) {\n            throw this.onFatalException(task, e);\n          } finally {\n            onQueueComplete();\n            onScheduleComplete();\n          }\n        });\n      }\n      onFatalException(task, e) {\n        const gitError = e instanceof GitError ? Object.assign(e, {\n          task\n        }) : new GitError(task, e && String(e));\n        this._chain = Promise.resolve();\n        this._queue.fatal(gitError);\n        return gitError;\n      }\n      attemptRemoteTask(task, logger) {\n        return __async(this, null, function* () {\n          const args = this._plugins.exec(\"spawn.args\", [...task.commands], pluginContext(task, task.commands));\n          const raw = yield this.gitResponse(task, this.binary, args, this.outputHandler, logger.step(\"SPAWN\"));\n          const outputStreams = yield this.handleTaskData(task, args, raw, logger.step(\"HANDLE\"));\n          logger(`passing response to task's parser as a %s`, task.format);\n          if (isBufferTask(task)) {\n            return callTaskParser(task.parser, outputStreams);\n          }\n          return callTaskParser(task.parser, outputStreams.asStrings());\n        });\n      }\n      attemptEmptyTask(task, logger) {\n        return __async(this, null, function* () {\n          logger(`empty task bypassing child process to call to task's parser`);\n          return task.parser(this);\n        });\n      }\n      handleTaskData(task, args, result, logger) {\n        const {\n          exitCode,\n          rejection,\n          stdOut,\n          stdErr\n        } = result;\n        return new Promise((done, fail) => {\n          logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);\n          const {\n            error\n          } = this._plugins.exec(\"task.error\", {\n            error: rejection\n          }, __spreadValues(__spreadValues({}, pluginContext(task, args)), result));\n          if (error && task.onError) {\n            logger.info(`exitCode=%s handling with custom error handler`);\n            return task.onError(result, error, newStdOut => {\n              logger.info(`custom error handler treated as success`);\n              logger(`custom error returned a %s`, objectToString(newStdOut));\n              done(new GitOutputStreams(Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut, Buffer.concat(stdErr)));\n            }, fail);\n          }\n          if (error) {\n            logger.info(`handling as error: exitCode=%s stdErr=%s rejection=%o`, exitCode, stdErr.length, rejection);\n            return fail(error);\n          }\n          logger.info(`retrieving task output complete`);\n          done(new GitOutputStreams(Buffer.concat(stdOut), Buffer.concat(stdErr)));\n        });\n      }\n      gitResponse(task, command, args, outputHandler, logger) {\n        return __async(this, null, function* () {\n          const outputLogger = logger.sibling(\"output\");\n          const spawnOptions = this._plugins.exec(\"spawn.options\", {\n            cwd: this.cwd,\n            env: this.env,\n            windowsHide: true\n          }, pluginContext(task, task.commands));\n          return new Promise(done => {\n            const stdOut = [];\n            const stdErr = [];\n            logger.info(`%s %o`, command, args);\n            logger(\"%O\", spawnOptions);\n            let rejection = this._beforeSpawn(task, args);\n            if (rejection) {\n              return done({\n                stdOut,\n                stdErr,\n                exitCode: 9901,\n                rejection\n              });\n            }\n            this._plugins.exec(\"spawn.before\", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {\n              kill(reason) {\n                rejection = reason || rejection;\n              }\n            }));\n            const spawned = spawn(command, args, spawnOptions);\n            spawned.stdout.on(\"data\", onDataReceived(stdOut, \"stdOut\", logger, outputLogger.step(\"stdOut\")));\n            spawned.stderr.on(\"data\", onDataReceived(stdErr, \"stdErr\", logger, outputLogger.step(\"stdErr\")));\n            spawned.on(\"error\", onErrorReceived(stdErr, logger));\n            if (outputHandler) {\n              logger(`Passing child process stdOut/stdErr to custom outputHandler`);\n              outputHandler(command, spawned.stdout, spawned.stderr, [...args]);\n            }\n            this._plugins.exec(\"spawn.after\", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {\n              spawned,\n              close(exitCode, reason) {\n                done({\n                  stdOut,\n                  stdErr,\n                  exitCode,\n                  rejection: rejection || reason\n                });\n              },\n              kill(reason) {\n                if (spawned.killed) {\n                  return;\n                }\n                rejection = reason;\n                spawned.kill(\"SIGINT\");\n              }\n            }));\n          });\n        });\n      }\n      _beforeSpawn(task, args) {\n        let rejection;\n        this._plugins.exec(\"spawn.before\", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {\n          kill(reason) {\n            rejection = reason || rejection;\n          }\n        }));\n        return rejection;\n      }\n    };\n  }\n});\n\n// src/lib/runners/git-executor.ts\nvar git_executor_exports = {};\n__export(git_executor_exports, {\n  GitExecutor: () => GitExecutor\n});\nvar GitExecutor;\nvar init_git_executor = __esm({\n  \"src/lib/runners/git-executor.ts\"() {\n    init_git_executor_chain();\n    GitExecutor = class {\n      constructor(binary = \"git\", cwd, _scheduler, _plugins) {\n        this.binary = binary;\n        this.cwd = cwd;\n        this._scheduler = _scheduler;\n        this._plugins = _plugins;\n        this._chain = new GitExecutorChain(this, this._scheduler, this._plugins);\n      }\n      chain() {\n        return new GitExecutorChain(this, this._scheduler, this._plugins);\n      }\n      push(task) {\n        return this._chain.push(task);\n      }\n    };\n  }\n});\n\n// src/lib/task-callback.ts\nfunction taskCallback(task, response, callback = NOOP) {\n  const onSuccess = data => {\n    callback(null, data);\n  };\n  const onError2 = err => {\n    if ((err == null ? void 0 : err.task) === task) {\n      callback(err instanceof GitResponseError ? addDeprecationNoticeToError(err) : err, void 0);\n    }\n  };\n  response.then(onSuccess, onError2);\n}\nfunction addDeprecationNoticeToError(err) {\n  let log = name => {\n    console.warn(`simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`);\n    log = NOOP;\n  };\n  return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));\n  function descriptorReducer(all, name) {\n    if (name in err) {\n      return all;\n    }\n    all[name] = {\n      enumerable: false,\n      configurable: false,\n      get() {\n        log(name);\n        return err.git[name];\n      }\n    };\n    return all;\n  }\n}\nvar init_task_callback = __esm({\n  \"src/lib/task-callback.ts\"() {\n    init_git_response_error();\n    init_utils();\n  }\n});\n\n// src/lib/tasks/change-working-directory.ts\nfunction changeWorkingDirectoryTask(directory, root) {\n  return adhocExecTask(instance => {\n    if (!folderExists(directory)) {\n      throw new Error(`Git.cwd: cannot change to non-directory \"${directory}\"`);\n    }\n    return (root || instance).cwd = directory;\n  });\n}\nvar init_change_working_directory = __esm({\n  \"src/lib/tasks/change-working-directory.ts\"() {\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/checkout.ts\nfunction checkoutTask(args) {\n  const commands = [\"checkout\", ...args];\n  if (commands[1] === \"-b\" && commands.includes(\"-B\")) {\n    commands[1] = remove(commands, \"-B\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction checkout_default() {\n  return {\n    checkout() {\n      return this._runTask(checkoutTask(getTrailingOptions(arguments, 1)), trailingFunctionArgument(arguments));\n    },\n    checkoutBranch(branchName, startPoint) {\n      return this._runTask(checkoutTask([\"-b\", branchName, startPoint, ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));\n    },\n    checkoutLocalBranch(branchName) {\n      return this._runTask(checkoutTask([\"-b\", branchName, ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));\n    }\n  };\n}\nvar init_checkout = __esm({\n  \"src/lib/tasks/checkout.ts\"() {\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/parsers/parse-commit.ts\nfunction parseCommitResult(stdOut) {\n  const result = {\n    author: null,\n    branch: \"\",\n    commit: \"\",\n    root: false,\n    summary: {\n      changes: 0,\n      insertions: 0,\n      deletions: 0\n    }\n  };\n  return parseStringResponse(result, parsers, stdOut);\n}\nvar parsers;\nvar init_parse_commit = __esm({\n  \"src/lib/parsers/parse-commit.ts\"() {\n    init_utils();\n    parsers = [new LineParser(/^\\[([^\\s]+)( \\([^)]+\\))? ([^\\]]+)/, (result, [branch, root, commit]) => {\n      result.branch = branch;\n      result.commit = commit;\n      result.root = !!root;\n    }), new LineParser(/\\s*Author:\\s(.+)/i, (result, [author]) => {\n      const parts = author.split(\"<\");\n      const email = parts.pop();\n      if (!email || !email.includes(\"@\")) {\n        return;\n      }\n      result.author = {\n        email: email.substr(0, email.length - 1),\n        name: parts.join(\"<\").trim()\n      };\n    }), new LineParser(/(\\d+)[^,]*(?:,\\s*(\\d+)[^,]*)(?:,\\s*(\\d+))/g, (result, [changes, insertions, deletions]) => {\n      result.summary.changes = parseInt(changes, 10) || 0;\n      result.summary.insertions = parseInt(insertions, 10) || 0;\n      result.summary.deletions = parseInt(deletions, 10) || 0;\n    }), new LineParser(/^(\\d+)[^,]*(?:,\\s*(\\d+)[^(]+\\(([+-]))?/, (result, [changes, lines, direction]) => {\n      result.summary.changes = parseInt(changes, 10) || 0;\n      const count = parseInt(lines, 10) || 0;\n      if (direction === \"-\") {\n        result.summary.deletions = count;\n      } else if (direction === \"+\") {\n        result.summary.insertions = count;\n      }\n    })];\n  }\n});\n\n// src/lib/tasks/commit.ts\nfunction commitTask(message, files, customArgs) {\n  const commands = [\"-c\", \"core.abbrev=40\", \"commit\", ...prefixedArray(message, \"-m\"), ...files, ...customArgs];\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: parseCommitResult\n  };\n}\nfunction commit_default() {\n  return {\n    commit(message, ...rest) {\n      const next = trailingFunctionArgument(arguments);\n      const task = rejectDeprecatedSignatures(message) || commitTask(asArray(message), asArray(filterType(rest[0], filterStringOrStringArray, [])), [...filterType(rest[1], filterArray, []), ...getTrailingOptions(arguments, 0, true)]);\n      return this._runTask(task, next);\n    }\n  };\n  function rejectDeprecatedSignatures(message) {\n    return !filterStringOrStringArray(message) && configurationErrorTask(`git.commit: requires the commit message to be supplied as a string/string[]`);\n  }\n}\nvar init_commit = __esm({\n  \"src/lib/tasks/commit.ts\"() {\n    init_parse_commit();\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/first-commit.ts\nfunction first_commit_default() {\n  return {\n    firstCommit() {\n      return this._runTask(straightThroughStringTask([\"rev-list\", \"--max-parents=0\", \"HEAD\"], true), trailingFunctionArgument(arguments));\n    }\n  };\n}\nvar init_first_commit = __esm({\n  \"src/lib/tasks/first-commit.ts\"() {\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/hash-object.ts\nfunction hashObjectTask(filePath, write) {\n  const commands = [\"hash-object\", filePath];\n  if (write) {\n    commands.push(\"-w\");\n  }\n  return straightThroughStringTask(commands, true);\n}\nvar init_hash_object = __esm({\n  \"src/lib/tasks/hash-object.ts\"() {\n    init_task();\n  }\n});\n\n// src/lib/responses/InitSummary.ts\nfunction parseInit(bare, path, text) {\n  const response = String(text).trim();\n  let result;\n  if (result = initResponseRegex.exec(response)) {\n    return new InitSummary(bare, path, false, result[1]);\n  }\n  if (result = reInitResponseRegex.exec(response)) {\n    return new InitSummary(bare, path, true, result[1]);\n  }\n  let gitDir = \"\";\n  const tokens = response.split(\" \");\n  while (tokens.length) {\n    const token = tokens.shift();\n    if (token === \"in\") {\n      gitDir = tokens.join(\" \");\n      break;\n    }\n  }\n  return new InitSummary(bare, path, /^re/i.test(response), gitDir);\n}\nvar InitSummary, initResponseRegex, reInitResponseRegex;\nvar init_InitSummary = __esm({\n  \"src/lib/responses/InitSummary.ts\"() {\n    InitSummary = class {\n      constructor(bare, path, existing, gitDir) {\n        this.bare = bare;\n        this.path = path;\n        this.existing = existing;\n        this.gitDir = gitDir;\n      }\n    };\n    initResponseRegex = /^Init.+ repository in (.+)$/;\n    reInitResponseRegex = /^Rein.+ in (.+)$/;\n  }\n});\n\n// src/lib/tasks/init.ts\nfunction hasBareCommand(command) {\n  return command.includes(bareCommand);\n}\nfunction initTask(bare = false, path, customArgs) {\n  const commands = [\"init\", ...customArgs];\n  if (bare && !hasBareCommand(commands)) {\n    commands.splice(1, 0, bareCommand);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return parseInit(commands.includes(\"--bare\"), path, text);\n    }\n  };\n}\nvar bareCommand;\nvar init_init = __esm({\n  \"src/lib/tasks/init.ts\"() {\n    init_InitSummary();\n    bareCommand = \"--bare\";\n  }\n});\n\n// src/lib/args/log-format.ts\nfunction logFormatFromCommand(customArgs) {\n  for (let i = 0; i < customArgs.length; i++) {\n    const format = logFormatRegex.exec(customArgs[i]);\n    if (format) {\n      return `--${format[1]}`;\n    }\n  }\n  return \"\" /* NONE */;\n}\nfunction isLogFormat(customArg) {\n  return logFormatRegex.test(customArg);\n}\nvar logFormatRegex;\nvar init_log_format = __esm({\n  \"src/lib/args/log-format.ts\"() {\n    logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;\n  }\n});\n\n// src/lib/responses/DiffSummary.ts\nvar DiffSummary;\nvar init_DiffSummary = __esm({\n  \"src/lib/responses/DiffSummary.ts\"() {\n    DiffSummary = class {\n      constructor() {\n        this.changed = 0;\n        this.deletions = 0;\n        this.insertions = 0;\n        this.files = [];\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-diff-summary.ts\nfunction getDiffParser(format = \"\" /* NONE */) {\n  const parser3 = diffSummaryParsers[format];\n  return stdOut => parseStringResponse(new DiffSummary(), parser3, stdOut, false);\n}\nvar statParser, numStatParser, nameOnlyParser, nameStatusParser, diffSummaryParsers;\nvar init_parse_diff_summary = __esm({\n  \"src/lib/parsers/parse-diff-summary.ts\"() {\n    init_log_format();\n    init_DiffSummary();\n    init_utils();\n    statParser = [new LineParser(/(.+)\\s+\\|\\s+(\\d+)(\\s+[+\\-]+)?$/, (result, [file, changes, alterations = \"\"]) => {\n      result.files.push({\n        file: file.trim(),\n        changes: asNumber(changes),\n        insertions: alterations.replace(/[^+]/g, \"\").length,\n        deletions: alterations.replace(/[^-]/g, \"\").length,\n        binary: false\n      });\n    }), new LineParser(/(.+) \\|\\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/, (result, [file, before, after]) => {\n      result.files.push({\n        file: file.trim(),\n        before: asNumber(before),\n        after: asNumber(after),\n        binary: true\n      });\n    }), new LineParser(/(\\d+) files? changed\\s*((?:, \\d+ [^,]+){0,2})/, (result, [changed, summary]) => {\n      const inserted = /(\\d+) i/.exec(summary);\n      const deleted = /(\\d+) d/.exec(summary);\n      result.changed = asNumber(changed);\n      result.insertions = asNumber(inserted == null ? void 0 : inserted[1]);\n      result.deletions = asNumber(deleted == null ? void 0 : deleted[1]);\n    })];\n    numStatParser = [new LineParser(/(\\d+)\\t(\\d+)\\t(.+)$/, (result, [changesInsert, changesDelete, file]) => {\n      const insertions = asNumber(changesInsert);\n      const deletions = asNumber(changesDelete);\n      result.changed++;\n      result.insertions += insertions;\n      result.deletions += deletions;\n      result.files.push({\n        file,\n        changes: insertions + deletions,\n        insertions,\n        deletions,\n        binary: false\n      });\n    }), new LineParser(/-\\t-\\t(.+)$/, (result, [file]) => {\n      result.changed++;\n      result.files.push({\n        file,\n        after: 0,\n        before: 0,\n        binary: true\n      });\n    })];\n    nameOnlyParser = [new LineParser(/(.+)$/, (result, [file]) => {\n      result.changed++;\n      result.files.push({\n        file,\n        changes: 0,\n        insertions: 0,\n        deletions: 0,\n        binary: false\n      });\n    })];\n    nameStatusParser = [new LineParser(/([ACDMRTUXB])\\s*(.+)$/, (result, [_status, file]) => {\n      result.changed++;\n      result.files.push({\n        file,\n        changes: 0,\n        insertions: 0,\n        deletions: 0,\n        binary: false\n      });\n    })];\n    diffSummaryParsers = {\n      [\"\" /* NONE */]: statParser,\n      [\"--stat\" /* STAT */]: statParser,\n      [\"--numstat\" /* NUM_STAT */]: numStatParser,\n      [\"--name-status\" /* NAME_STATUS */]: nameStatusParser,\n      [\"--name-only\" /* NAME_ONLY */]: nameOnlyParser\n    };\n  }\n});\n\n// src/lib/parsers/parse-list-log-summary.ts\nfunction lineBuilder(tokens, fields) {\n  return fields.reduce((line, field, index) => {\n    line[field] = tokens[index] || \"\";\n    return line;\n  }, /* @__PURE__ */Object.create({\n    diff: null\n  }));\n}\nfunction createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames, logFormat = \"\" /* NONE */) {\n  const parseDiffResult = getDiffParser(logFormat);\n  return function (stdOut) {\n    const all = toLinesWithContent(stdOut, true, START_BOUNDARY).map(function (item) {\n      const lineDetail = item.trim().split(COMMIT_BOUNDARY);\n      const listLogLine = lineBuilder(lineDetail[0].trim().split(splitter), fields);\n      if (lineDetail.length > 1 && !!lineDetail[1].trim()) {\n        listLogLine.diff = parseDiffResult(lineDetail[1]);\n      }\n      return listLogLine;\n    });\n    return {\n      all,\n      latest: all.length && all[0] || null,\n      total: all.length\n    };\n  };\n}\nvar START_BOUNDARY, COMMIT_BOUNDARY, SPLITTER, defaultFieldNames;\nvar init_parse_list_log_summary = __esm({\n  \"src/lib/parsers/parse-list-log-summary.ts\"() {\n    init_utils();\n    init_parse_diff_summary();\n    init_log_format();\n    START_BOUNDARY = \"\\xF2\\xF2\\xF2\\xF2\\xF2\\xF2 \";\n    COMMIT_BOUNDARY = \" \\xF2\\xF2\";\n    SPLITTER = \" \\xF2 \";\n    defaultFieldNames = [\"hash\", \"date\", \"message\", \"refs\", \"author_name\", \"author_email\"];\n  }\n});\n\n// src/lib/tasks/diff.ts\nvar diff_exports = {};\n__export(diff_exports, {\n  diffSummaryTask: () => diffSummaryTask,\n  validateLogFormatConfig: () => validateLogFormatConfig\n});\nfunction diffSummaryTask(customArgs) {\n  let logFormat = logFormatFromCommand(customArgs);\n  const commands = [\"diff\"];\n  if (logFormat === \"\" /* NONE */) {\n    logFormat = \"--stat\" /* STAT */;\n    commands.push(\"--stat=4096\");\n  }\n  commands.push(...customArgs);\n  return validateLogFormatConfig(commands) || {\n    commands,\n    format: \"utf-8\",\n    parser: getDiffParser(logFormat)\n  };\n}\nfunction validateLogFormatConfig(customArgs) {\n  const flags = customArgs.filter(isLogFormat);\n  if (flags.length > 1) {\n    return configurationErrorTask(`Summary flags are mutually exclusive - pick one of ${flags.join(\",\")}`);\n  }\n  if (flags.length && customArgs.includes(\"-z\")) {\n    return configurationErrorTask(`Summary flag ${flags} parsing is not compatible with null termination option '-z'`);\n  }\n}\nvar init_diff = __esm({\n  \"src/lib/tasks/diff.ts\"() {\n    init_log_format();\n    init_parse_diff_summary();\n    init_task();\n  }\n});\n\n// src/lib/tasks/log.ts\nfunction prettyFormat(format, splitter) {\n  const fields = [];\n  const formatStr = [];\n  Object.keys(format).forEach(field => {\n    fields.push(field);\n    formatStr.push(String(format[field]));\n  });\n  return [fields, formatStr.join(splitter)];\n}\nfunction userOptions(input) {\n  return Object.keys(input).reduce((out, key) => {\n    if (!(key in excludeOptions)) {\n      out[key] = input[key];\n    }\n    return out;\n  }, {});\n}\nfunction parseLogOptions(opt = {}, customArgs = []) {\n  const splitter = filterType(opt.splitter, filterString, SPLITTER);\n  const format = !filterPrimitives(opt.format) && opt.format ? opt.format : {\n    hash: \"%H\",\n    date: opt.strictDate === false ? \"%ai\" : \"%aI\",\n    message: \"%s\",\n    refs: \"%D\",\n    body: opt.multiLine ? \"%B\" : \"%b\",\n    author_name: opt.mailMap !== false ? \"%aN\" : \"%an\",\n    author_email: opt.mailMap !== false ? \"%aE\" : \"%ae\"\n  };\n  const [fields, formatStr] = prettyFormat(format, splitter);\n  const suffix = [];\n  const command = [`--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`, ...customArgs];\n  const maxCount = opt.n || opt[\"max-count\"] || opt.maxCount;\n  if (maxCount) {\n    command.push(`--max-count=${maxCount}`);\n  }\n  if (opt.from || opt.to) {\n    const rangeOperator = opt.symmetric !== false ? \"...\" : \"..\";\n    suffix.push(`${opt.from || \"\"}${rangeOperator}${opt.to || \"\"}`);\n  }\n  if (filterString(opt.file)) {\n    command.push(\"--follow\", pathspec(opt.file));\n  }\n  appendTaskOptions(userOptions(opt), command);\n  return {\n    fields,\n    splitter,\n    commands: [...command, ...suffix]\n  };\n}\nfunction logTask(splitter, fields, customArgs) {\n  const parser3 = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));\n  return {\n    commands: [\"log\", ...customArgs],\n    format: \"utf-8\",\n    parser: parser3\n  };\n}\nfunction log_default() {\n  return {\n    log(...rest) {\n      const next = trailingFunctionArgument(arguments);\n      const options = parseLogOptions(trailingOptionsArgument(arguments), filterType(arguments[0], filterArray));\n      const task = rejectDeprecatedSignatures(...rest) || validateLogFormatConfig(options.commands) || createLogTask(options);\n      return this._runTask(task, next);\n    }\n  };\n  function createLogTask(options) {\n    return logTask(options.splitter, options.fields, options.commands);\n  }\n  function rejectDeprecatedSignatures(from, to) {\n    return filterString(from) && filterString(to) && configurationErrorTask(`git.log(string, string) should be replaced with git.log({ from: string, to: string })`);\n  }\n}\nvar excludeOptions;\nvar init_log = __esm({\n  \"src/lib/tasks/log.ts\"() {\n    init_log_format();\n    init_pathspec();\n    init_parse_list_log_summary();\n    init_utils();\n    init_task();\n    init_diff();\n    excludeOptions = /* @__PURE__ */(excludeOptions2 => {\n      excludeOptions2[excludeOptions2[\"--pretty\"] = 0] = \"--pretty\";\n      excludeOptions2[excludeOptions2[\"max-count\"] = 1] = \"max-count\";\n      excludeOptions2[excludeOptions2[\"maxCount\"] = 2] = \"maxCount\";\n      excludeOptions2[excludeOptions2[\"n\"] = 3] = \"n\";\n      excludeOptions2[excludeOptions2[\"file\"] = 4] = \"file\";\n      excludeOptions2[excludeOptions2[\"format\"] = 5] = \"format\";\n      excludeOptions2[excludeOptions2[\"from\"] = 6] = \"from\";\n      excludeOptions2[excludeOptions2[\"to\"] = 7] = \"to\";\n      excludeOptions2[excludeOptions2[\"splitter\"] = 8] = \"splitter\";\n      excludeOptions2[excludeOptions2[\"symmetric\"] = 9] = \"symmetric\";\n      excludeOptions2[excludeOptions2[\"mailMap\"] = 10] = \"mailMap\";\n      excludeOptions2[excludeOptions2[\"multiLine\"] = 11] = \"multiLine\";\n      excludeOptions2[excludeOptions2[\"strictDate\"] = 12] = \"strictDate\";\n      return excludeOptions2;\n    })(excludeOptions || {});\n  }\n});\n\n// src/lib/responses/MergeSummary.ts\nvar MergeSummaryConflict, MergeSummaryDetail;\nvar init_MergeSummary = __esm({\n  \"src/lib/responses/MergeSummary.ts\"() {\n    MergeSummaryConflict = class {\n      constructor(reason, file = null, meta) {\n        this.reason = reason;\n        this.file = file;\n        this.meta = meta;\n      }\n      toString() {\n        return `${this.file}:${this.reason}`;\n      }\n    };\n    MergeSummaryDetail = class {\n      constructor() {\n        this.conflicts = [];\n        this.merges = [];\n        this.result = \"success\";\n      }\n      get failed() {\n        return this.conflicts.length > 0;\n      }\n      get reason() {\n        return this.result;\n      }\n      toString() {\n        if (this.conflicts.length) {\n          return `CONFLICTS: ${this.conflicts.join(\", \")}`;\n        }\n        return \"OK\";\n      }\n    };\n  }\n});\n\n// src/lib/responses/PullSummary.ts\nvar PullSummary, PullFailedSummary;\nvar init_PullSummary = __esm({\n  \"src/lib/responses/PullSummary.ts\"() {\n    PullSummary = class {\n      constructor() {\n        this.remoteMessages = {\n          all: []\n        };\n        this.created = [];\n        this.deleted = [];\n        this.files = [];\n        this.deletions = {};\n        this.insertions = {};\n        this.summary = {\n          changes: 0,\n          deletions: 0,\n          insertions: 0\n        };\n      }\n    };\n    PullFailedSummary = class {\n      constructor() {\n        this.remote = \"\";\n        this.hash = {\n          local: \"\",\n          remote: \"\"\n        };\n        this.branch = {\n          local: \"\",\n          remote: \"\"\n        };\n        this.message = \"\";\n      }\n      toString() {\n        return this.message;\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-remote-objects.ts\nfunction objectEnumerationResult(remoteMessages) {\n  return remoteMessages.objects = remoteMessages.objects || {\n    compressing: 0,\n    counting: 0,\n    enumerating: 0,\n    packReused: 0,\n    reused: {\n      count: 0,\n      delta: 0\n    },\n    total: {\n      count: 0,\n      delta: 0\n    }\n  };\n}\nfunction asObjectCount(source) {\n  const count = /^\\s*(\\d+)/.exec(source);\n  const delta = /delta (\\d+)/i.exec(source);\n  return {\n    count: asNumber(count && count[1] || \"0\"),\n    delta: asNumber(delta && delta[1] || \"0\")\n  };\n}\nvar remoteMessagesObjectParsers;\nvar init_parse_remote_objects = __esm({\n  \"src/lib/parsers/parse-remote-objects.ts\"() {\n    init_utils();\n    remoteMessagesObjectParsers = [new RemoteLineParser(/^remote:\\s*(enumerating|counting|compressing) objects: (\\d+),/i, (result, [action, count]) => {\n      const key = action.toLowerCase();\n      const enumeration = objectEnumerationResult(result.remoteMessages);\n      Object.assign(enumeration, {\n        [key]: asNumber(count)\n      });\n    }), new RemoteLineParser(/^remote:\\s*(enumerating|counting|compressing) objects: \\d+% \\(\\d+\\/(\\d+)\\),/i, (result, [action, count]) => {\n      const key = action.toLowerCase();\n      const enumeration = objectEnumerationResult(result.remoteMessages);\n      Object.assign(enumeration, {\n        [key]: asNumber(count)\n      });\n    }), new RemoteLineParser(/total ([^,]+), reused ([^,]+), pack-reused (\\d+)/i, (result, [total, reused, packReused]) => {\n      const objects = objectEnumerationResult(result.remoteMessages);\n      objects.total = asObjectCount(total);\n      objects.reused = asObjectCount(reused);\n      objects.packReused = asNumber(packReused);\n    })];\n  }\n});\n\n// src/lib/parsers/parse-remote-messages.ts\nfunction parseRemoteMessages(_stdOut, stdErr) {\n  return parseStringResponse({\n    remoteMessages: new RemoteMessageSummary()\n  }, parsers2, stdErr);\n}\nvar parsers2, RemoteMessageSummary;\nvar init_parse_remote_messages = __esm({\n  \"src/lib/parsers/parse-remote-messages.ts\"() {\n    init_utils();\n    init_parse_remote_objects();\n    parsers2 = [new RemoteLineParser(/^remote:\\s*(.+)$/, (result, [text]) => {\n      result.remoteMessages.all.push(text.trim());\n      return false;\n    }), ...remoteMessagesObjectParsers, new RemoteLineParser([/create a (?:pull|merge) request/i, /\\s(https?:\\/\\/\\S+)$/], (result, [pullRequestUrl]) => {\n      result.remoteMessages.pullRequestUrl = pullRequestUrl;\n    }), new RemoteLineParser([/found (\\d+) vulnerabilities.+\\(([^)]+)\\)/i, /\\s(https?:\\/\\/\\S+)$/], (result, [count, summary, url]) => {\n      result.remoteMessages.vulnerabilities = {\n        count: asNumber(count),\n        summary,\n        url\n      };\n    })];\n    RemoteMessageSummary = class {\n      constructor() {\n        this.all = [];\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-pull.ts\nfunction parsePullErrorResult(stdOut, stdErr) {\n  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);\n  return pullError.message && pullError;\n}\nvar FILE_UPDATE_REGEX, SUMMARY_REGEX, ACTION_REGEX, parsers3, errorParsers, parsePullDetail, parsePullResult;\nvar init_parse_pull = __esm({\n  \"src/lib/parsers/parse-pull.ts\"() {\n    init_PullSummary();\n    init_utils();\n    init_parse_remote_messages();\n    FILE_UPDATE_REGEX = /^\\s*(.+?)\\s+\\|\\s+\\d+\\s*(\\+*)(-*)/;\n    SUMMARY_REGEX = /(\\d+)\\D+((\\d+)\\D+\\(\\+\\))?(\\D+(\\d+)\\D+\\(-\\))?/;\n    ACTION_REGEX = /^(create|delete) mode \\d+ (.+)/;\n    parsers3 = [new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {\n      result.files.push(file);\n      if (insertions) {\n        result.insertions[file] = insertions.length;\n      }\n      if (deletions) {\n        result.deletions[file] = deletions.length;\n      }\n    }), new LineParser(SUMMARY_REGEX, (result, [changes,, insertions,, deletions]) => {\n      if (insertions !== void 0 || deletions !== void 0) {\n        result.summary.changes = +changes || 0;\n        result.summary.insertions = +insertions || 0;\n        result.summary.deletions = +deletions || 0;\n        return true;\n      }\n      return false;\n    }), new LineParser(ACTION_REGEX, (result, [action, file]) => {\n      append(result.files, file);\n      append(action === \"create\" ? result.created : result.deleted, file);\n    })];\n    errorParsers = [new LineParser(/^from\\s(.+)$/i, (result, [remote]) => void (result.remote = remote)), new LineParser(/^fatal:\\s(.+)$/, (result, [message]) => void (result.message = message)), new LineParser(/([a-z0-9]+)\\.\\.([a-z0-9]+)\\s+(\\S+)\\s+->\\s+(\\S+)$/, (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {\n      result.branch.local = branchLocal;\n      result.hash.local = hashLocal;\n      result.branch.remote = branchRemote;\n      result.hash.remote = hashRemote;\n    })];\n    parsePullDetail = (stdOut, stdErr) => {\n      return parseStringResponse(new PullSummary(), parsers3, [stdOut, stdErr]);\n    };\n    parsePullResult = (stdOut, stdErr) => {\n      return Object.assign(new PullSummary(), parsePullDetail(stdOut, stdErr), parseRemoteMessages(stdOut, stdErr));\n    };\n  }\n});\n\n// src/lib/parsers/parse-merge.ts\nvar parsers4, parseMergeResult, parseMergeDetail;\nvar init_parse_merge = __esm({\n  \"src/lib/parsers/parse-merge.ts\"() {\n    init_MergeSummary();\n    init_utils();\n    init_parse_pull();\n    parsers4 = [new LineParser(/^Auto-merging\\s+(.+)$/, (summary, [autoMerge]) => {\n      summary.merges.push(autoMerge);\n    }), new LineParser(/^CONFLICT\\s+\\((.+)\\): Merge conflict in (.+)$/, (summary, [reason, file]) => {\n      summary.conflicts.push(new MergeSummaryConflict(reason, file));\n    }), new LineParser(/^CONFLICT\\s+\\((.+\\/delete)\\): (.+) deleted in (.+) and/, (summary, [reason, file, deleteRef]) => {\n      summary.conflicts.push(new MergeSummaryConflict(reason, file, {\n        deleteRef\n      }));\n    }), new LineParser(/^CONFLICT\\s+\\((.+)\\):/, (summary, [reason]) => {\n      summary.conflicts.push(new MergeSummaryConflict(reason, null));\n    }), new LineParser(/^Automatic merge failed;\\s+(.+)$/, (summary, [result]) => {\n      summary.result = result;\n    })];\n    parseMergeResult = (stdOut, stdErr) => {\n      return Object.assign(parseMergeDetail(stdOut, stdErr), parsePullResult(stdOut, stdErr));\n    };\n    parseMergeDetail = stdOut => {\n      return parseStringResponse(new MergeSummaryDetail(), parsers4, stdOut);\n    };\n  }\n});\n\n// src/lib/tasks/merge.ts\nfunction mergeTask(customArgs) {\n  if (!customArgs.length) {\n    return configurationErrorTask(\"Git.merge requires at least one option\");\n  }\n  return {\n    commands: [\"merge\", ...customArgs],\n    format: \"utf-8\",\n    parser(stdOut, stdErr) {\n      const merge = parseMergeResult(stdOut, stdErr);\n      if (merge.failed) {\n        throw new GitResponseError(merge);\n      }\n      return merge;\n    }\n  };\n}\nvar init_merge = __esm({\n  \"src/lib/tasks/merge.ts\"() {\n    init_git_response_error();\n    init_parse_merge();\n    init_task();\n  }\n});\n\n// src/lib/parsers/parse-push.ts\nfunction pushResultPushedItem(local, remote, status) {\n  const deleted = status.includes(\"deleted\");\n  const tag = status.includes(\"tag\") || /^refs\\/tags/.test(local);\n  const alreadyUpdated = !status.includes(\"new\");\n  return {\n    deleted,\n    tag,\n    branch: !tag,\n    new: !alreadyUpdated,\n    alreadyUpdated,\n    local,\n    remote\n  };\n}\nvar parsers5, parsePushResult, parsePushDetail;\nvar init_parse_push = __esm({\n  \"src/lib/parsers/parse-push.ts\"() {\n    init_utils();\n    init_parse_remote_messages();\n    parsers5 = [new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {\n      result.repo = repo;\n    }), new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {\n      result.ref = __spreadProps(__spreadValues({}, result.ref || {}), {\n        local\n      });\n    }), new LineParser(/^[=*-]\\s+([^:]+):(\\S+)\\s+\\[(.+)]$/, (result, [local, remote, type]) => {\n      result.pushed.push(pushResultPushedItem(local, remote, type));\n    }), new LineParser(/^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/, (result, [local, remote, remoteName]) => {\n      result.branch = __spreadProps(__spreadValues({}, result.branch || {}), {\n        local,\n        remote,\n        remoteName\n      });\n    }), new LineParser(/^([^:]+):(\\S+)\\s+([a-z0-9]+)\\.\\.([a-z0-9]+)$/, (result, [local, remote, from, to]) => {\n      result.update = {\n        head: {\n          local,\n          remote\n        },\n        hash: {\n          from,\n          to\n        }\n      };\n    })];\n    parsePushResult = (stdOut, stdErr) => {\n      const pushDetail = parsePushDetail(stdOut, stdErr);\n      const responseDetail = parseRemoteMessages(stdOut, stdErr);\n      return __spreadValues(__spreadValues({}, pushDetail), responseDetail);\n    };\n    parsePushDetail = (stdOut, stdErr) => {\n      return parseStringResponse({\n        pushed: []\n      }, parsers5, [stdOut, stdErr]);\n    };\n  }\n});\n\n// src/lib/tasks/push.ts\nvar push_exports = {};\n__export(push_exports, {\n  pushTagsTask: () => pushTagsTask,\n  pushTask: () => pushTask\n});\nfunction pushTagsTask(ref = {}, customArgs) {\n  append(customArgs, \"--tags\");\n  return pushTask(ref, customArgs);\n}\nfunction pushTask(ref = {}, customArgs) {\n  const commands = [\"push\", ...customArgs];\n  if (ref.branch) {\n    commands.splice(1, 0, ref.branch);\n  }\n  if (ref.remote) {\n    commands.splice(1, 0, ref.remote);\n  }\n  remove(commands, \"-v\");\n  append(commands, \"--verbose\");\n  append(commands, \"--porcelain\");\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: parsePushResult\n  };\n}\nvar init_push = __esm({\n  \"src/lib/tasks/push.ts\"() {\n    init_parse_push();\n    init_utils();\n  }\n});\n\n// src/lib/tasks/show.ts\nfunction show_default() {\n  return {\n    showBuffer() {\n      const commands = [\"show\", ...getTrailingOptions(arguments, 1)];\n      if (!commands.includes(\"--binary\")) {\n        commands.splice(1, 0, \"--binary\");\n      }\n      return this._runTask(straightThroughBufferTask(commands), trailingFunctionArgument(arguments));\n    },\n    show() {\n      const commands = [\"show\", ...getTrailingOptions(arguments, 1)];\n      return this._runTask(straightThroughStringTask(commands), trailingFunctionArgument(arguments));\n    }\n  };\n}\nvar init_show = __esm({\n  \"src/lib/tasks/show.ts\"() {\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/responses/FileStatusSummary.ts\nvar fromPathRegex, FileStatusSummary;\nvar init_FileStatusSummary = __esm({\n  \"src/lib/responses/FileStatusSummary.ts\"() {\n    fromPathRegex = /^(.+) -> (.+)$/;\n    FileStatusSummary = class {\n      constructor(path, index, working_dir) {\n        this.path = path;\n        this.index = index;\n        this.working_dir = working_dir;\n        if (index + working_dir === \"R\") {\n          const detail = fromPathRegex.exec(path) || [null, path, path];\n          this.from = detail[1] || \"\";\n          this.path = detail[2] || \"\";\n        }\n      }\n    };\n  }\n});\n\n// src/lib/responses/StatusSummary.ts\nfunction renamedFile(line) {\n  const [to, from] = line.split(NULL);\n  return {\n    from: from || to,\n    to\n  };\n}\nfunction parser2(indexX, indexY, handler) {\n  return [`${indexX}${indexY}`, handler];\n}\nfunction conflicts(indexX, ...indexY) {\n  return indexY.map(y => parser2(indexX, y, (result, file) => append(result.conflicted, file)));\n}\nfunction splitLine(result, lineStr) {\n  const trimmed2 = lineStr.trim();\n  switch (\" \") {\n    case trimmed2.charAt(2):\n      return data(trimmed2.charAt(0), trimmed2.charAt(1), trimmed2.substr(3));\n    case trimmed2.charAt(1):\n      return data(\" \" /* NONE */, trimmed2.charAt(0), trimmed2.substr(2));\n    default:\n      return;\n  }\n  function data(index, workingDir, path) {\n    const raw = `${index}${workingDir}`;\n    const handler = parsers6.get(raw);\n    if (handler) {\n      handler(result, path);\n    }\n    if (raw !== \"##\" && raw !== \"!!\") {\n      result.files.push(new FileStatusSummary(path.replace(/\\0.+$/, \"\"), index, workingDir));\n    }\n  }\n}\nvar StatusSummary, parsers6, parseStatusSummary;\nvar init_StatusSummary = __esm({\n  \"src/lib/responses/StatusSummary.ts\"() {\n    init_utils();\n    init_FileStatusSummary();\n    StatusSummary = class {\n      constructor() {\n        this.not_added = [];\n        this.conflicted = [];\n        this.created = [];\n        this.deleted = [];\n        this.ignored = void 0;\n        this.modified = [];\n        this.renamed = [];\n        this.files = [];\n        this.staged = [];\n        this.ahead = 0;\n        this.behind = 0;\n        this.current = null;\n        this.tracking = null;\n        this.detached = false;\n        this.isClean = () => {\n          return !this.files.length;\n        };\n      }\n    };\n    parsers6 = new Map([parser2(\" \" /* NONE */, \"A\" /* ADDED */, (result, file) => append(result.created, file)), parser2(\" \" /* NONE */, \"D\" /* DELETED */, (result, file) => append(result.deleted, file)), parser2(\" \" /* NONE */, \"M\" /* MODIFIED */, (result, file) => append(result.modified, file)), parser2(\"A\" /* ADDED */, \" \" /* NONE */, (result, file) => append(result.created, file) && append(result.staged, file)), parser2(\"A\" /* ADDED */, \"M\" /* MODIFIED */, (result, file) => append(result.created, file) && append(result.staged, file) && append(result.modified, file)), parser2(\"D\" /* DELETED */, \" \" /* NONE */, (result, file) => append(result.deleted, file) && append(result.staged, file)), parser2(\"M\" /* MODIFIED */, \" \" /* NONE */, (result, file) => append(result.modified, file) && append(result.staged, file)), parser2(\"M\" /* MODIFIED */, \"M\" /* MODIFIED */, (result, file) => append(result.modified, file) && append(result.staged, file)), parser2(\"R\" /* RENAMED */, \" \" /* NONE */, (result, file) => {\n      append(result.renamed, renamedFile(file));\n    }), parser2(\"R\" /* RENAMED */, \"M\" /* MODIFIED */, (result, file) => {\n      const renamed = renamedFile(file);\n      append(result.renamed, renamed);\n      append(result.modified, renamed.to);\n    }), parser2(\"!\" /* IGNORED */, \"!\" /* IGNORED */, (_result, _file) => {\n      append(_result.ignored = _result.ignored || [], _file);\n    }), parser2(\"?\" /* UNTRACKED */, \"?\" /* UNTRACKED */, (result, file) => append(result.not_added, file)), ...conflicts(\"A\" /* ADDED */, \"A\" /* ADDED */, \"U\" /* UNMERGED */), ...conflicts(\"D\" /* DELETED */, \"D\" /* DELETED */, \"U\" /* UNMERGED */), ...conflicts(\"U\" /* UNMERGED */, \"A\" /* ADDED */, \"D\" /* DELETED */, \"U\" /* UNMERGED */), [\"##\", (result, line) => {\n      const aheadReg = /ahead (\\d+)/;\n      const behindReg = /behind (\\d+)/;\n      const currentReg = /^(.+?(?=(?:\\.{3}|\\s|$)))/;\n      const trackingReg = /\\.{3}(\\S*)/;\n      const onEmptyBranchReg = /\\son\\s([\\S]+)$/;\n      let regexResult;\n      regexResult = aheadReg.exec(line);\n      result.ahead = regexResult && +regexResult[1] || 0;\n      regexResult = behindReg.exec(line);\n      result.behind = regexResult && +regexResult[1] || 0;\n      regexResult = currentReg.exec(line);\n      result.current = regexResult && regexResult[1];\n      regexResult = trackingReg.exec(line);\n      result.tracking = regexResult && regexResult[1];\n      regexResult = onEmptyBranchReg.exec(line);\n      result.current = regexResult && regexResult[1] || result.current;\n      result.detached = /\\(no branch\\)/.test(line);\n    }]]);\n    parseStatusSummary = function (text) {\n      const lines = text.split(NULL);\n      const status = new StatusSummary();\n      for (let i = 0, l = lines.length; i < l;) {\n        let line = lines[i++].trim();\n        if (!line) {\n          continue;\n        }\n        if (line.charAt(0) === \"R\" /* RENAMED */) {\n          line += NULL + (lines[i++] || \"\");\n        }\n        splitLine(status, line);\n      }\n      return status;\n    };\n  }\n});\n\n// src/lib/tasks/status.ts\nfunction statusTask(customArgs) {\n  const commands = [\"status\", \"--porcelain\", \"-b\", \"-u\", \"--null\", ...customArgs.filter(arg => !ignoredOptions.includes(arg))];\n  return {\n    format: \"utf-8\",\n    commands,\n    parser(text) {\n      return parseStatusSummary(text);\n    }\n  };\n}\nvar ignoredOptions;\nvar init_status = __esm({\n  \"src/lib/tasks/status.ts\"() {\n    init_StatusSummary();\n    ignoredOptions = [\"--null\", \"-z\"];\n  }\n});\n\n// src/lib/tasks/version.ts\nfunction versionResponse(major = 0, minor = 0, patch = 0, agent = \"\", installed = true) {\n  return Object.defineProperty({\n    major,\n    minor,\n    patch,\n    agent,\n    installed\n  }, \"toString\", {\n    value() {\n      return `${this.major}.${this.minor}.${this.patch}`;\n    },\n    configurable: false,\n    enumerable: false\n  });\n}\nfunction notInstalledResponse() {\n  return versionResponse(0, 0, 0, \"\", false);\n}\nfunction version_default() {\n  return {\n    version() {\n      return this._runTask({\n        commands: [\"--version\"],\n        format: \"utf-8\",\n        parser: versionParser,\n        onError(result, error, done, fail) {\n          if (result.exitCode === -2 /* NOT_FOUND */) {\n            return done(Buffer.from(NOT_INSTALLED));\n          }\n          fail(error);\n        }\n      });\n    }\n  };\n}\nfunction versionParser(stdOut) {\n  if (stdOut === NOT_INSTALLED) {\n    return notInstalledResponse();\n  }\n  return parseStringResponse(versionResponse(0, 0, 0, stdOut), parsers7, stdOut);\n}\nvar NOT_INSTALLED, parsers7;\nvar init_version = __esm({\n  \"src/lib/tasks/version.ts\"() {\n    init_utils();\n    NOT_INSTALLED = \"installed=false\";\n    parsers7 = [new LineParser(/version (\\d+)\\.(\\d+)\\.(\\d+)(?:\\s*\\((.+)\\))?/, (result, [major, minor, patch, agent = \"\"]) => {\n      Object.assign(result, versionResponse(asNumber(major), asNumber(minor), asNumber(patch), agent));\n    }), new LineParser(/version (\\d+)\\.(\\d+)\\.(\\D+)(.+)?$/, (result, [major, minor, patch, agent = \"\"]) => {\n      Object.assign(result, versionResponse(asNumber(major), asNumber(minor), patch, agent));\n    })];\n  }\n});\n\n// src/lib/simple-git-api.ts\nvar simple_git_api_exports = {};\n__export(simple_git_api_exports, {\n  SimpleGitApi: () => SimpleGitApi\n});\nvar SimpleGitApi;\nvar init_simple_git_api = __esm({\n  \"src/lib/simple-git-api.ts\"() {\n    init_task_callback();\n    init_change_working_directory();\n    init_checkout();\n    init_commit();\n    init_config();\n    init_first_commit();\n    init_grep();\n    init_hash_object();\n    init_init();\n    init_log();\n    init_merge();\n    init_push();\n    init_show();\n    init_status();\n    init_task();\n    init_version();\n    init_utils();\n    SimpleGitApi = class {\n      constructor(_executor) {\n        this._executor = _executor;\n      }\n      _runTask(task, then) {\n        const chain = this._executor.chain();\n        const promise = chain.push(task);\n        if (then) {\n          taskCallback(task, promise, then);\n        }\n        return Object.create(this, {\n          then: {\n            value: promise.then.bind(promise)\n          },\n          catch: {\n            value: promise.catch.bind(promise)\n          },\n          _executor: {\n            value: chain\n          }\n        });\n      }\n      add(files) {\n        return this._runTask(straightThroughStringTask([\"add\", ...asArray(files)]), trailingFunctionArgument(arguments));\n      }\n      cwd(directory) {\n        const next = trailingFunctionArgument(arguments);\n        if (typeof directory === \"string\") {\n          return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);\n        }\n        if (typeof (directory == null ? void 0 : directory.path) === \"string\") {\n          return this._runTask(changeWorkingDirectoryTask(directory.path, directory.root && this._executor || void 0), next);\n        }\n        return this._runTask(configurationErrorTask(\"Git.cwd: workingDirectory must be supplied as a string\"), next);\n      }\n      hashObject(path, write) {\n        return this._runTask(hashObjectTask(path, write === true), trailingFunctionArgument(arguments));\n      }\n      init(bare) {\n        return this._runTask(initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)), trailingFunctionArgument(arguments));\n      }\n      merge() {\n        return this._runTask(mergeTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));\n      }\n      mergeFromTo(remote, branch) {\n        if (!(filterString(remote) && filterString(branch))) {\n          return this._runTask(configurationErrorTask(`Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`));\n        }\n        return this._runTask(mergeTask([remote, branch, ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments, false));\n      }\n      outputHandler(handler) {\n        this._executor.outputHandler = handler;\n        return this;\n      }\n      push() {\n        const task = pushTask({\n          remote: filterType(arguments[0], filterString),\n          branch: filterType(arguments[1], filterString)\n        }, getTrailingOptions(arguments));\n        return this._runTask(task, trailingFunctionArgument(arguments));\n      }\n      stash() {\n        return this._runTask(straightThroughStringTask([\"stash\", ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));\n      }\n      status() {\n        return this._runTask(statusTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));\n      }\n    };\n    Object.assign(SimpleGitApi.prototype, checkout_default(), commit_default(), config_default(), first_commit_default(), grep_default(), log_default(), show_default(), version_default());\n  }\n});\n\n// src/lib/runners/scheduler.ts\nvar scheduler_exports = {};\n__export(scheduler_exports, {\n  Scheduler: () => Scheduler\n});\nimport { createDeferred } from \"@kwsites/promise-deferred\";\nvar createScheduledTask, Scheduler;\nvar init_scheduler = __esm({\n  \"src/lib/runners/scheduler.ts\"() {\n    init_utils();\n    init_git_logger();\n    createScheduledTask = (() => {\n      let id = 0;\n      return () => {\n        id++;\n        const {\n          promise,\n          done\n        } = createDeferred();\n        return {\n          promise,\n          done,\n          id\n        };\n      };\n    })();\n    Scheduler = class {\n      constructor(concurrency = 2) {\n        this.concurrency = concurrency;\n        this.logger = createLogger(\"\", \"scheduler\");\n        this.pending = [];\n        this.running = [];\n        this.logger(`Constructed, concurrency=%s`, concurrency);\n      }\n      schedule() {\n        if (!this.pending.length || this.running.length >= this.concurrency) {\n          this.logger(`Schedule attempt ignored, pending=%s running=%s concurrency=%s`, this.pending.length, this.running.length, this.concurrency);\n          return;\n        }\n        const task = append(this.running, this.pending.shift());\n        this.logger(`Attempting id=%s`, task.id);\n        task.done(() => {\n          this.logger(`Completing id=`, task.id);\n          remove(this.running, task);\n          this.schedule();\n        });\n      }\n      next() {\n        const {\n          promise,\n          id\n        } = append(this.pending, createScheduledTask());\n        this.logger(`Scheduling id=%s`, id);\n        this.schedule();\n        return promise;\n      }\n    };\n  }\n});\n\n// src/lib/tasks/apply-patch.ts\nvar apply_patch_exports = {};\n__export(apply_patch_exports, {\n  applyPatchTask: () => applyPatchTask\n});\nfunction applyPatchTask(patches, customArgs) {\n  return straightThroughStringTask([\"apply\", ...customArgs, ...patches]);\n}\nvar init_apply_patch = __esm({\n  \"src/lib/tasks/apply-patch.ts\"() {\n    init_task();\n  }\n});\n\n// src/lib/responses/BranchDeleteSummary.ts\nfunction branchDeletionSuccess(branch, hash) {\n  return {\n    branch,\n    hash,\n    success: true\n  };\n}\nfunction branchDeletionFailure(branch) {\n  return {\n    branch,\n    hash: null,\n    success: false\n  };\n}\nvar BranchDeletionBatch;\nvar init_BranchDeleteSummary = __esm({\n  \"src/lib/responses/BranchDeleteSummary.ts\"() {\n    BranchDeletionBatch = class {\n      constructor() {\n        this.all = [];\n        this.branches = {};\n        this.errors = [];\n      }\n      get success() {\n        return !this.errors.length;\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-branch-delete.ts\nfunction hasBranchDeletionError(data, processExitCode) {\n  return processExitCode === 1 /* ERROR */ && deleteErrorRegex.test(data);\n}\nvar deleteSuccessRegex, deleteErrorRegex, parsers8, parseBranchDeletions;\nvar init_parse_branch_delete = __esm({\n  \"src/lib/parsers/parse-branch-delete.ts\"() {\n    init_BranchDeleteSummary();\n    init_utils();\n    deleteSuccessRegex = /(\\S+)\\s+\\(\\S+\\s([^)]+)\\)/;\n    deleteErrorRegex = /^error[^']+'([^']+)'/m;\n    parsers8 = [new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {\n      const deletion = branchDeletionSuccess(branch, hash);\n      result.all.push(deletion);\n      result.branches[branch] = deletion;\n    }), new LineParser(deleteErrorRegex, (result, [branch]) => {\n      const deletion = branchDeletionFailure(branch);\n      result.errors.push(deletion);\n      result.all.push(deletion);\n      result.branches[branch] = deletion;\n    })];\n    parseBranchDeletions = (stdOut, stdErr) => {\n      return parseStringResponse(new BranchDeletionBatch(), parsers8, [stdOut, stdErr]);\n    };\n  }\n});\n\n// src/lib/responses/BranchSummary.ts\nvar BranchSummaryResult;\nvar init_BranchSummary = __esm({\n  \"src/lib/responses/BranchSummary.ts\"() {\n    BranchSummaryResult = class {\n      constructor() {\n        this.all = [];\n        this.branches = {};\n        this.current = \"\";\n        this.detached = false;\n      }\n      push(status, detached, name, commit, label) {\n        if (status === \"*\" /* CURRENT */) {\n          this.detached = detached;\n          this.current = name;\n        }\n        this.all.push(name);\n        this.branches[name] = {\n          current: status === \"*\" /* CURRENT */,\n          linkedWorkTree: status === \"+\" /* LINKED */,\n          name,\n          commit,\n          label\n        };\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-branch.ts\nfunction branchStatus(input) {\n  return input ? input.charAt(0) : \"\";\n}\nfunction parseBranchSummary(stdOut) {\n  return parseStringResponse(new BranchSummaryResult(), parsers9, stdOut);\n}\nvar parsers9;\nvar init_parse_branch = __esm({\n  \"src/lib/parsers/parse-branch.ts\"() {\n    init_BranchSummary();\n    init_utils();\n    parsers9 = [new LineParser(/^([*+]\\s)?\\((?:HEAD )?detached (?:from|at) (\\S+)\\)\\s+([a-z0-9]+)\\s(.*)$/, (result, [current, name, commit, label]) => {\n      result.push(branchStatus(current), true, name, commit, label);\n    }), new LineParser(/^([*+]\\s)?(\\S+)\\s+([a-z0-9]+)\\s?(.*)$/s, (result, [current, name, commit, label]) => {\n      result.push(branchStatus(current), false, name, commit, label);\n    })];\n  }\n});\n\n// src/lib/tasks/branch.ts\nvar branch_exports = {};\n__export(branch_exports, {\n  branchLocalTask: () => branchLocalTask,\n  branchTask: () => branchTask,\n  containsDeleteBranchCommand: () => containsDeleteBranchCommand,\n  deleteBranchTask: () => deleteBranchTask,\n  deleteBranchesTask: () => deleteBranchesTask\n});\nfunction containsDeleteBranchCommand(commands) {\n  const deleteCommands = [\"-d\", \"-D\", \"--delete\"];\n  return commands.some(command => deleteCommands.includes(command));\n}\nfunction branchTask(customArgs) {\n  const isDelete = containsDeleteBranchCommand(customArgs);\n  const commands = [\"branch\", ...customArgs];\n  if (commands.length === 1) {\n    commands.push(\"-a\");\n  }\n  if (!commands.includes(\"-v\")) {\n    commands.splice(1, 0, \"-v\");\n  }\n  return {\n    format: \"utf-8\",\n    commands,\n    parser(stdOut, stdErr) {\n      if (isDelete) {\n        return parseBranchDeletions(stdOut, stdErr).all[0];\n      }\n      return parseBranchSummary(stdOut);\n    }\n  };\n}\nfunction branchLocalTask() {\n  const parser3 = parseBranchSummary;\n  return {\n    format: \"utf-8\",\n    commands: [\"branch\", \"-v\"],\n    parser: parser3\n  };\n}\nfunction deleteBranchesTask(branches, forceDelete = false) {\n  return {\n    format: \"utf-8\",\n    commands: [\"branch\", \"-v\", forceDelete ? \"-D\" : \"-d\", ...branches],\n    parser(stdOut, stdErr) {\n      return parseBranchDeletions(stdOut, stdErr);\n    },\n    onError({\n      exitCode,\n      stdOut\n    }, error, done, fail) {\n      if (!hasBranchDeletionError(String(error), exitCode)) {\n        return fail(error);\n      }\n      done(stdOut);\n    }\n  };\n}\nfunction deleteBranchTask(branch, forceDelete = false) {\n  const task = {\n    format: \"utf-8\",\n    commands: [\"branch\", \"-v\", forceDelete ? \"-D\" : \"-d\", branch],\n    parser(stdOut, stdErr) {\n      return parseBranchDeletions(stdOut, stdErr).branches[branch];\n    },\n    onError({\n      exitCode,\n      stdErr,\n      stdOut\n    }, error, _, fail) {\n      if (!hasBranchDeletionError(String(error), exitCode)) {\n        return fail(error);\n      }\n      throw new GitResponseError(task.parser(bufferToString(stdOut), bufferToString(stdErr)), String(error));\n    }\n  };\n  return task;\n}\nvar init_branch = __esm({\n  \"src/lib/tasks/branch.ts\"() {\n    init_git_response_error();\n    init_parse_branch_delete();\n    init_parse_branch();\n    init_utils();\n  }\n});\n\n// src/lib/responses/CheckIgnore.ts\nvar parseCheckIgnore;\nvar init_CheckIgnore = __esm({\n  \"src/lib/responses/CheckIgnore.ts\"() {\n    parseCheckIgnore = text => {\n      return text.split(/\\n/g).map(line => line.trim()).filter(file => !!file);\n    };\n  }\n});\n\n// src/lib/tasks/check-ignore.ts\nvar check_ignore_exports = {};\n__export(check_ignore_exports, {\n  checkIgnoreTask: () => checkIgnoreTask\n});\nfunction checkIgnoreTask(paths) {\n  return {\n    commands: [\"check-ignore\", ...paths],\n    format: \"utf-8\",\n    parser: parseCheckIgnore\n  };\n}\nvar init_check_ignore = __esm({\n  \"src/lib/tasks/check-ignore.ts\"() {\n    init_CheckIgnore();\n  }\n});\n\n// src/lib/tasks/clone.ts\nvar clone_exports = {};\n__export(clone_exports, {\n  cloneMirrorTask: () => cloneMirrorTask,\n  cloneTask: () => cloneTask\n});\nfunction disallowedCommand(command) {\n  return /^--upload-pack(=|$)/.test(command);\n}\nfunction cloneTask(repo, directory, customArgs) {\n  const commands = [\"clone\", ...customArgs];\n  filterString(repo) && commands.push(repo);\n  filterString(directory) && commands.push(directory);\n  const banned = commands.find(disallowedCommand);\n  if (banned) {\n    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n  }\n  return straightThroughStringTask(commands);\n}\nfunction cloneMirrorTask(repo, directory, customArgs) {\n  append(customArgs, \"--mirror\");\n  return cloneTask(repo, directory, customArgs);\n}\nvar init_clone = __esm({\n  \"src/lib/tasks/clone.ts\"() {\n    init_task();\n    init_utils();\n  }\n});\n\n// src/lib/parsers/parse-fetch.ts\nfunction parseFetchResult(stdOut, stdErr) {\n  const result = {\n    raw: stdOut,\n    remote: null,\n    branches: [],\n    tags: [],\n    updated: [],\n    deleted: []\n  };\n  return parseStringResponse(result, parsers10, [stdOut, stdErr]);\n}\nvar parsers10;\nvar init_parse_fetch = __esm({\n  \"src/lib/parsers/parse-fetch.ts\"() {\n    init_utils();\n    parsers10 = [new LineParser(/From (.+)$/, (result, [remote]) => {\n      result.remote = remote;\n    }), new LineParser(/\\* \\[new branch]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) => {\n      result.branches.push({\n        name,\n        tracking\n      });\n    }), new LineParser(/\\* \\[new tag]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) => {\n      result.tags.push({\n        name,\n        tracking\n      });\n    }), new LineParser(/- \\[deleted]\\s+\\S+\\s*-> (.+)$/, (result, [tracking]) => {\n      result.deleted.push({\n        tracking\n      });\n    }), new LineParser(/\\s*([^.]+)\\.\\.(\\S+)\\s+(\\S+)\\s*-> (.+)$/, (result, [from, to, name, tracking]) => {\n      result.updated.push({\n        name,\n        tracking,\n        to,\n        from\n      });\n    })];\n  }\n});\n\n// src/lib/tasks/fetch.ts\nvar fetch_exports = {};\n__export(fetch_exports, {\n  fetchTask: () => fetchTask\n});\nfunction disallowedCommand2(command) {\n  return /^--upload-pack(=|$)/.test(command);\n}\nfunction fetchTask(remote, branch, customArgs) {\n  const commands = [\"fetch\", ...customArgs];\n  if (remote && branch) {\n    commands.push(remote, branch);\n  }\n  const banned = commands.find(disallowedCommand2);\n  if (banned) {\n    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: parseFetchResult\n  };\n}\nvar init_fetch = __esm({\n  \"src/lib/tasks/fetch.ts\"() {\n    init_parse_fetch();\n    init_task();\n  }\n});\n\n// src/lib/parsers/parse-move.ts\nfunction parseMoveResult(stdOut) {\n  return parseStringResponse({\n    moves: []\n  }, parsers11, stdOut);\n}\nvar parsers11;\nvar init_parse_move = __esm({\n  \"src/lib/parsers/parse-move.ts\"() {\n    init_utils();\n    parsers11 = [new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {\n      result.moves.push({\n        from,\n        to\n      });\n    })];\n  }\n});\n\n// src/lib/tasks/move.ts\nvar move_exports = {};\n__export(move_exports, {\n  moveTask: () => moveTask\n});\nfunction moveTask(from, to) {\n  return {\n    commands: [\"mv\", \"-v\", ...asArray(from), to],\n    format: \"utf-8\",\n    parser: parseMoveResult\n  };\n}\nvar init_move = __esm({\n  \"src/lib/tasks/move.ts\"() {\n    init_parse_move();\n    init_utils();\n  }\n});\n\n// src/lib/tasks/pull.ts\nvar pull_exports = {};\n__export(pull_exports, {\n  pullTask: () => pullTask\n});\nfunction pullTask(remote, branch, customArgs) {\n  const commands = [\"pull\", ...customArgs];\n  if (remote && branch) {\n    commands.splice(1, 0, remote, branch);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(stdOut, stdErr) {\n      return parsePullResult(stdOut, stdErr);\n    },\n    onError(result, _error, _done, fail) {\n      const pullError = parsePullErrorResult(bufferToString(result.stdOut), bufferToString(result.stdErr));\n      if (pullError) {\n        return fail(new GitResponseError(pullError));\n      }\n      fail(_error);\n    }\n  };\n}\nvar init_pull = __esm({\n  \"src/lib/tasks/pull.ts\"() {\n    init_git_response_error();\n    init_parse_pull();\n    init_utils();\n  }\n});\n\n// src/lib/responses/GetRemoteSummary.ts\nfunction parseGetRemotes(text) {\n  const remotes = {};\n  forEach(text, ([name]) => remotes[name] = {\n    name\n  });\n  return Object.values(remotes);\n}\nfunction parseGetRemotesVerbose(text) {\n  const remotes = {};\n  forEach(text, ([name, url, purpose]) => {\n    if (!remotes.hasOwnProperty(name)) {\n      remotes[name] = {\n        name,\n        refs: {\n          fetch: \"\",\n          push: \"\"\n        }\n      };\n    }\n    if (purpose && url) {\n      remotes[name].refs[purpose.replace(/[^a-z]/g, \"\")] = url;\n    }\n  });\n  return Object.values(remotes);\n}\nfunction forEach(text, handler) {\n  forEachLineWithContent(text, line => handler(line.split(/\\s+/)));\n}\nvar init_GetRemoteSummary = __esm({\n  \"src/lib/responses/GetRemoteSummary.ts\"() {\n    init_utils();\n  }\n});\n\n// src/lib/tasks/remote.ts\nvar remote_exports = {};\n__export(remote_exports, {\n  addRemoteTask: () => addRemoteTask,\n  getRemotesTask: () => getRemotesTask,\n  listRemotesTask: () => listRemotesTask,\n  remoteTask: () => remoteTask,\n  removeRemoteTask: () => removeRemoteTask\n});\nfunction addRemoteTask(remoteName, remoteRepo, customArgs = []) {\n  return straightThroughStringTask([\"remote\", \"add\", ...customArgs, remoteName, remoteRepo]);\n}\nfunction getRemotesTask(verbose) {\n  const commands = [\"remote\"];\n  if (verbose) {\n    commands.push(\"-v\");\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: verbose ? parseGetRemotesVerbose : parseGetRemotes\n  };\n}\nfunction listRemotesTask(customArgs = []) {\n  const commands = [...customArgs];\n  if (commands[0] !== \"ls-remote\") {\n    commands.unshift(\"ls-remote\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction remoteTask(customArgs = []) {\n  const commands = [...customArgs];\n  if (commands[0] !== \"remote\") {\n    commands.unshift(\"remote\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction removeRemoteTask(remoteName) {\n  return straightThroughStringTask([\"remote\", \"remove\", remoteName]);\n}\nvar init_remote = __esm({\n  \"src/lib/tasks/remote.ts\"() {\n    init_GetRemoteSummary();\n    init_task();\n  }\n});\n\n// src/lib/tasks/stash-list.ts\nvar stash_list_exports = {};\n__export(stash_list_exports, {\n  stashListTask: () => stashListTask\n});\nfunction stashListTask(opt = {}, customArgs) {\n  const options = parseLogOptions(opt);\n  const commands = [\"stash\", \"list\", ...options.commands, ...customArgs];\n  const parser3 = createListLogSummaryParser(options.splitter, options.fields, logFormatFromCommand(commands));\n  return validateLogFormatConfig(commands) || {\n    commands,\n    format: \"utf-8\",\n    parser: parser3\n  };\n}\nvar init_stash_list = __esm({\n  \"src/lib/tasks/stash-list.ts\"() {\n    init_log_format();\n    init_parse_list_log_summary();\n    init_diff();\n    init_log();\n  }\n});\n\n// src/lib/tasks/sub-module.ts\nvar sub_module_exports = {};\n__export(sub_module_exports, {\n  addSubModuleTask: () => addSubModuleTask,\n  initSubModuleTask: () => initSubModuleTask,\n  subModuleTask: () => subModuleTask,\n  updateSubModuleTask: () => updateSubModuleTask\n});\nfunction addSubModuleTask(repo, path) {\n  return subModuleTask([\"add\", repo, path]);\n}\nfunction initSubModuleTask(customArgs) {\n  return subModuleTask([\"init\", ...customArgs]);\n}\nfunction subModuleTask(customArgs) {\n  const commands = [...customArgs];\n  if (commands[0] !== \"submodule\") {\n    commands.unshift(\"submodule\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction updateSubModuleTask(customArgs) {\n  return subModuleTask([\"update\", ...customArgs]);\n}\nvar init_sub_module = __esm({\n  \"src/lib/tasks/sub-module.ts\"() {\n    init_task();\n  }\n});\n\n// src/lib/responses/TagList.ts\nfunction singleSorted(a, b) {\n  const aIsNum = isNaN(a);\n  const bIsNum = isNaN(b);\n  if (aIsNum !== bIsNum) {\n    return aIsNum ? 1 : -1;\n  }\n  return aIsNum ? sorted(a, b) : 0;\n}\nfunction sorted(a, b) {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\nfunction trimmed(input) {\n  return input.trim();\n}\nfunction toNumber(input) {\n  if (typeof input === \"string\") {\n    return parseInt(input.replace(/^\\D+/g, \"\"), 10) || 0;\n  }\n  return 0;\n}\nvar TagList, parseTagList;\nvar init_TagList = __esm({\n  \"src/lib/responses/TagList.ts\"() {\n    TagList = class {\n      constructor(all, latest) {\n        this.all = all;\n        this.latest = latest;\n      }\n    };\n    parseTagList = function (data, customSort = false) {\n      const tags = data.split(\"\\n\").map(trimmed).filter(Boolean);\n      if (!customSort) {\n        tags.sort(function (tagA, tagB) {\n          const partsA = tagA.split(\".\");\n          const partsB = tagB.split(\".\");\n          if (partsA.length === 1 || partsB.length === 1) {\n            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));\n          }\n          for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {\n            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));\n            if (diff) {\n              return diff;\n            }\n          }\n          return 0;\n        });\n      }\n      const latest = customSort ? tags[0] : [...tags].reverse().find(tag => tag.indexOf(\".\") >= 0);\n      return new TagList(tags, latest);\n    };\n  }\n});\n\n// src/lib/tasks/tag.ts\nvar tag_exports = {};\n__export(tag_exports, {\n  addAnnotatedTagTask: () => addAnnotatedTagTask,\n  addTagTask: () => addTagTask,\n  tagListTask: () => tagListTask\n});\nfunction tagListTask(customArgs = []) {\n  const hasCustomSort = customArgs.some(option => /^--sort=/.test(option));\n  return {\n    format: \"utf-8\",\n    commands: [\"tag\", \"-l\", ...customArgs],\n    parser(text) {\n      return parseTagList(text, hasCustomSort);\n    }\n  };\n}\nfunction addTagTask(name) {\n  return {\n    format: \"utf-8\",\n    commands: [\"tag\", name],\n    parser() {\n      return {\n        name\n      };\n    }\n  };\n}\nfunction addAnnotatedTagTask(name, tagMessage) {\n  return {\n    format: \"utf-8\",\n    commands: [\"tag\", \"-a\", \"-m\", tagMessage, name],\n    parser() {\n      return {\n        name\n      };\n    }\n  };\n}\nvar init_tag = __esm({\n  \"src/lib/tasks/tag.ts\"() {\n    init_TagList();\n  }\n});\n\n// src/git.js\nvar require_git = __commonJS({\n  \"src/git.js\"(exports, module) {\n    var {\n      GitExecutor: GitExecutor2\n    } = (init_git_executor(), __toCommonJS(git_executor_exports));\n    var {\n      SimpleGitApi: SimpleGitApi2\n    } = (init_simple_git_api(), __toCommonJS(simple_git_api_exports));\n    var {\n      Scheduler: Scheduler2\n    } = (init_scheduler(), __toCommonJS(scheduler_exports));\n    var {\n      configurationErrorTask: configurationErrorTask2\n    } = (init_task(), __toCommonJS(task_exports));\n    var {\n      asArray: asArray2,\n      filterArray: filterArray2,\n      filterPrimitives: filterPrimitives2,\n      filterString: filterString2,\n      filterStringOrStringArray: filterStringOrStringArray2,\n      filterType: filterType2,\n      getTrailingOptions: getTrailingOptions2,\n      trailingFunctionArgument: trailingFunctionArgument2,\n      trailingOptionsArgument: trailingOptionsArgument2\n    } = (init_utils(), __toCommonJS(utils_exports));\n    var {\n      applyPatchTask: applyPatchTask2\n    } = (init_apply_patch(), __toCommonJS(apply_patch_exports));\n    var {\n      branchTask: branchTask2,\n      branchLocalTask: branchLocalTask2,\n      deleteBranchesTask: deleteBranchesTask2,\n      deleteBranchTask: deleteBranchTask2\n    } = (init_branch(), __toCommonJS(branch_exports));\n    var {\n      checkIgnoreTask: checkIgnoreTask2\n    } = (init_check_ignore(), __toCommonJS(check_ignore_exports));\n    var {\n      checkIsRepoTask: checkIsRepoTask2\n    } = (init_check_is_repo(), __toCommonJS(check_is_repo_exports));\n    var {\n      cloneTask: cloneTask2,\n      cloneMirrorTask: cloneMirrorTask2\n    } = (init_clone(), __toCommonJS(clone_exports));\n    var {\n      cleanWithOptionsTask: cleanWithOptionsTask2,\n      isCleanOptionsArray: isCleanOptionsArray2\n    } = (init_clean(), __toCommonJS(clean_exports));\n    var {\n      diffSummaryTask: diffSummaryTask2\n    } = (init_diff(), __toCommonJS(diff_exports));\n    var {\n      fetchTask: fetchTask2\n    } = (init_fetch(), __toCommonJS(fetch_exports));\n    var {\n      moveTask: moveTask2\n    } = (init_move(), __toCommonJS(move_exports));\n    var {\n      pullTask: pullTask2\n    } = (init_pull(), __toCommonJS(pull_exports));\n    var {\n      pushTagsTask: pushTagsTask2\n    } = (init_push(), __toCommonJS(push_exports));\n    var {\n      addRemoteTask: addRemoteTask2,\n      getRemotesTask: getRemotesTask2,\n      listRemotesTask: listRemotesTask2,\n      remoteTask: remoteTask2,\n      removeRemoteTask: removeRemoteTask2\n    } = (init_remote(), __toCommonJS(remote_exports));\n    var {\n      getResetMode: getResetMode2,\n      resetTask: resetTask2\n    } = (init_reset(), __toCommonJS(reset_exports));\n    var {\n      stashListTask: stashListTask2\n    } = (init_stash_list(), __toCommonJS(stash_list_exports));\n    var {\n      addSubModuleTask: addSubModuleTask2,\n      initSubModuleTask: initSubModuleTask2,\n      subModuleTask: subModuleTask2,\n      updateSubModuleTask: updateSubModuleTask2\n    } = (init_sub_module(), __toCommonJS(sub_module_exports));\n    var {\n      addAnnotatedTagTask: addAnnotatedTagTask2,\n      addTagTask: addTagTask2,\n      tagListTask: tagListTask2\n    } = (init_tag(), __toCommonJS(tag_exports));\n    var {\n      straightThroughBufferTask: straightThroughBufferTask2,\n      straightThroughStringTask: straightThroughStringTask2\n    } = (init_task(), __toCommonJS(task_exports));\n    function Git2(options, plugins) {\n      this._executor = new GitExecutor2(options.binary, options.baseDir, new Scheduler2(options.maxConcurrentProcesses), plugins);\n      this._trimmed = options.trimmed;\n    }\n    (Git2.prototype = Object.create(SimpleGitApi2.prototype)).constructor = Git2;\n    Git2.prototype.customBinary = function (command) {\n      this._executor.binary = command;\n      return this;\n    };\n    Git2.prototype.env = function (name, value) {\n      if (arguments.length === 1 && typeof name === \"object\") {\n        this._executor.env = name;\n      } else {\n        (this._executor.env = this._executor.env || {})[name] = value;\n      }\n      return this;\n    };\n    Git2.prototype.stashList = function (options) {\n      return this._runTask(stashListTask2(trailingOptionsArgument2(arguments) || {}, filterArray2(options) && options || []), trailingFunctionArgument2(arguments));\n    };\n    function createCloneTask(api, task, repoPath, localPath) {\n      if (typeof repoPath !== \"string\") {\n        return configurationErrorTask2(`git.${api}() requires a string 'repoPath'`);\n      }\n      return task(repoPath, filterType2(localPath, filterString2), getTrailingOptions2(arguments));\n    }\n    Git2.prototype.clone = function () {\n      return this._runTask(createCloneTask(\"clone\", cloneTask2, ...arguments), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.mirror = function () {\n      return this._runTask(createCloneTask(\"mirror\", cloneMirrorTask2, ...arguments), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.mv = function (from, to) {\n      return this._runTask(moveTask2(from, to), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.checkoutLatestTag = function (then) {\n      var git = this;\n      return this.pull(function () {\n        git.tags(function (err, tags) {\n          git.checkout(tags.latest, then);\n        });\n      });\n    };\n    Git2.prototype.pull = function (remote, branch, options, then) {\n      return this._runTask(pullTask2(filterType2(remote, filterString2), filterType2(branch, filterString2), getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.fetch = function (remote, branch) {\n      return this._runTask(fetchTask2(filterType2(remote, filterString2), filterType2(branch, filterString2), getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.silent = function (silence) {\n      console.warn(\"simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3\");\n      return this;\n    };\n    Git2.prototype.tags = function (options, then) {\n      return this._runTask(tagListTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.rebase = function () {\n      return this._runTask(straightThroughStringTask2([\"rebase\", ...getTrailingOptions2(arguments)]), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.reset = function (mode) {\n      return this._runTask(resetTask2(getResetMode2(mode), getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.revert = function (commit) {\n      const next = trailingFunctionArgument2(arguments);\n      if (typeof commit !== \"string\") {\n        return this._runTask(configurationErrorTask2(\"Commit must be a string\"), next);\n      }\n      return this._runTask(straightThroughStringTask2([\"revert\", ...getTrailingOptions2(arguments, 0, true), commit]), next);\n    };\n    Git2.prototype.addTag = function (name) {\n      const task = typeof name === \"string\" ? addTagTask2(name) : configurationErrorTask2(\"Git.addTag requires a tag name\");\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.addAnnotatedTag = function (tagName, tagMessage) {\n      return this._runTask(addAnnotatedTagTask2(tagName, tagMessage), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.deleteLocalBranch = function (branchName, forceDelete, then) {\n      return this._runTask(deleteBranchTask2(branchName, typeof forceDelete === \"boolean\" ? forceDelete : false), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.deleteLocalBranches = function (branchNames, forceDelete, then) {\n      return this._runTask(deleteBranchesTask2(branchNames, typeof forceDelete === \"boolean\" ? forceDelete : false), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.branch = function (options, then) {\n      return this._runTask(branchTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.branchLocal = function (then) {\n      return this._runTask(branchLocalTask2(), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.raw = function (commands) {\n      const createRestCommands = !Array.isArray(commands);\n      const command = [].slice.call(createRestCommands ? arguments : commands, 0);\n      for (let i = 0; i < command.length && createRestCommands; i++) {\n        if (!filterPrimitives2(command[i])) {\n          command.splice(i, command.length - i);\n          break;\n        }\n      }\n      command.push(...getTrailingOptions2(arguments, 0, true));\n      var next = trailingFunctionArgument2(arguments);\n      if (!command.length) {\n        return this._runTask(configurationErrorTask2(\"Raw: must supply one or more command to execute\"), next);\n      }\n      return this._runTask(straightThroughStringTask2(command, this._trimmed), next);\n    };\n    Git2.prototype.submoduleAdd = function (repo, path, then) {\n      return this._runTask(addSubModuleTask2(repo, path), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.submoduleUpdate = function (args, then) {\n      return this._runTask(updateSubModuleTask2(getTrailingOptions2(arguments, true)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.submoduleInit = function (args, then) {\n      return this._runTask(initSubModuleTask2(getTrailingOptions2(arguments, true)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.subModule = function (options, then) {\n      return this._runTask(subModuleTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.listRemote = function () {\n      return this._runTask(listRemotesTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.addRemote = function (remoteName, remoteRepo, then) {\n      return this._runTask(addRemoteTask2(remoteName, remoteRepo, getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.removeRemote = function (remoteName, then) {\n      return this._runTask(removeRemoteTask2(remoteName), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.getRemotes = function (verbose, then) {\n      return this._runTask(getRemotesTask2(verbose === true), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.remote = function (options, then) {\n      return this._runTask(remoteTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.tag = function (options, then) {\n      const command = getTrailingOptions2(arguments);\n      if (command[0] !== \"tag\") {\n        command.unshift(\"tag\");\n      }\n      return this._runTask(straightThroughStringTask2(command), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.updateServerInfo = function (then) {\n      return this._runTask(straightThroughStringTask2([\"update-server-info\"]), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.pushTags = function (remote, then) {\n      const task = pushTagsTask2({\n        remote: filterType2(remote, filterString2)\n      }, getTrailingOptions2(arguments));\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.rm = function (files) {\n      return this._runTask(straightThroughStringTask2([\"rm\", \"-f\", ...asArray2(files)]), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.rmKeepLocal = function (files) {\n      return this._runTask(straightThroughStringTask2([\"rm\", \"--cached\", ...asArray2(files)]), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.catFile = function (options, then) {\n      return this._catFile(\"utf-8\", arguments);\n    };\n    Git2.prototype.binaryCatFile = function () {\n      return this._catFile(\"buffer\", arguments);\n    };\n    Git2.prototype._catFile = function (format, args) {\n      var handler = trailingFunctionArgument2(args);\n      var command = [\"cat-file\"];\n      var options = args[0];\n      if (typeof options === \"string\") {\n        return this._runTask(configurationErrorTask2(\"Git.catFile: options must be supplied as an array of strings\"), handler);\n      }\n      if (Array.isArray(options)) {\n        command.push.apply(command, options);\n      }\n      const task = format === \"buffer\" ? straightThroughBufferTask2(command) : straightThroughStringTask2(command);\n      return this._runTask(task, handler);\n    };\n    Git2.prototype.diff = function (options, then) {\n      const task = filterString2(options) ? configurationErrorTask2(\"git.diff: supplying options as a single string is no longer supported, switch to an array of strings\") : straightThroughStringTask2([\"diff\", ...getTrailingOptions2(arguments)]);\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.diffSummary = function () {\n      return this._runTask(diffSummaryTask2(getTrailingOptions2(arguments, 1)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.applyPatch = function (patches) {\n      const task = !filterStringOrStringArray2(patches) ? configurationErrorTask2(`git.applyPatch requires one or more string patches as the first argument`) : applyPatchTask2(asArray2(patches), getTrailingOptions2([].slice.call(arguments, 1)));\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.revparse = function () {\n      const commands = [\"rev-parse\", ...getTrailingOptions2(arguments, true)];\n      return this._runTask(straightThroughStringTask2(commands, true), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.clean = function (mode, options, then) {\n      const usingCleanOptionsArray = isCleanOptionsArray2(mode);\n      const cleanMode = usingCleanOptionsArray && mode.join(\"\") || filterType2(mode, filterString2) || \"\";\n      const customArgs = getTrailingOptions2([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));\n      return this._runTask(cleanWithOptionsTask2(cleanMode, customArgs), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.exec = function (then) {\n      const task = {\n        commands: [],\n        format: \"utf-8\",\n        parser() {\n          if (typeof then === \"function\") {\n            then();\n          }\n        }\n      };\n      return this._runTask(task);\n    };\n    Git2.prototype.clearQueue = function () {\n      return this;\n    };\n    Git2.prototype.checkIgnore = function (pathnames, then) {\n      return this._runTask(checkIgnoreTask2(asArray2(filterType2(pathnames, filterStringOrStringArray2, []))), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.checkIsRepo = function (checkType, then) {\n      return this._runTask(checkIsRepoTask2(filterType2(checkType, filterString2)), trailingFunctionArgument2(arguments));\n    };\n    module.exports = Git2;\n  }\n});\n\n// src/lib/api.ts\ninit_pathspec();\n\n// src/lib/errors/git-construct-error.ts\ninit_git_error();\nvar GitConstructError = class extends GitError {\n  constructor(config, message) {\n    super(void 0, message);\n    this.config = config;\n  }\n};\n\n// src/lib/api.ts\ninit_git_error();\n\n// src/lib/errors/git-plugin-error.ts\ninit_git_error();\nvar GitPluginError = class extends GitError {\n  constructor(task, plugin, message) {\n    super(task, message);\n    this.task = task;\n    this.plugin = plugin;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n};\n\n// src/lib/api.ts\ninit_git_response_error();\ninit_task_configuration_error();\ninit_check_is_repo();\ninit_clean();\ninit_config();\ninit_grep();\ninit_reset();\n\n// src/lib/plugins/abort-plugin.ts\nfunction abortPlugin(signal) {\n  if (!signal) {\n    return;\n  }\n  const onSpawnAfter = {\n    type: \"spawn.after\",\n    action(_data, context) {\n      function kill() {\n        context.kill(new GitPluginError(void 0, \"abort\", \"Abort signal received\"));\n      }\n      signal.addEventListener(\"abort\", kill);\n      context.spawned.on(\"close\", () => signal.removeEventListener(\"abort\", kill));\n    }\n  };\n  const onSpawnBefore = {\n    type: \"spawn.before\",\n    action(_data, context) {\n      if (signal.aborted) {\n        context.kill(new GitPluginError(void 0, \"abort\", \"Abort already signaled\"));\n      }\n    }\n  };\n  return [onSpawnBefore, onSpawnAfter];\n}\n\n// src/lib/plugins/block-unsafe-operations-plugin.ts\nfunction isConfigSwitch(arg) {\n  return typeof arg === \"string\" && arg.trim().toLowerCase() === \"-c\";\n}\nfunction preventProtocolOverride(arg, next) {\n  if (!isConfigSwitch(arg)) {\n    return;\n  }\n  if (!/^\\s*protocol(.[a-z]+)?.allow/.test(next)) {\n    return;\n  }\n  throw new GitPluginError(void 0, \"unsafe\", \"Configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol\");\n}\nfunction preventUploadPack(arg, method) {\n  if (/^\\s*--(upload|receive)-pack/.test(arg)) {\n    throw new GitPluginError(void 0, \"unsafe\", `Use of --upload-pack or --receive-pack is not permitted without enabling allowUnsafePack`);\n  }\n  if (method === \"clone\" && /^\\s*-u\\b/.test(arg)) {\n    throw new GitPluginError(void 0, \"unsafe\", `Use of clone with option -u is not permitted without enabling allowUnsafePack`);\n  }\n  if (method === \"push\" && /^\\s*--exec\\b/.test(arg)) {\n    throw new GitPluginError(void 0, \"unsafe\", `Use of push with option --exec is not permitted without enabling allowUnsafePack`);\n  }\n}\nfunction blockUnsafeOperationsPlugin({\n  allowUnsafeProtocolOverride = false,\n  allowUnsafePack = false\n} = {}) {\n  return {\n    type: \"spawn.args\",\n    action(args, context) {\n      args.forEach((current, index) => {\n        const next = index < args.length ? args[index + 1] : \"\";\n        allowUnsafeProtocolOverride || preventProtocolOverride(current, next);\n        allowUnsafePack || preventUploadPack(current, context.method);\n      });\n      return args;\n    }\n  };\n}\n\n// src/lib/plugins/command-config-prefixing-plugin.ts\ninit_utils();\nfunction commandConfigPrefixingPlugin(configuration) {\n  const prefix = prefixedArray(configuration, \"-c\");\n  return {\n    type: \"spawn.args\",\n    action(data) {\n      return [...prefix, ...data];\n    }\n  };\n}\n\n// src/lib/plugins/completion-detection.plugin.ts\ninit_utils();\nimport { deferred } from \"@kwsites/promise-deferred\";\nvar never = deferred().promise;\nfunction completionDetectionPlugin({\n  onClose = true,\n  onExit = 50\n} = {}) {\n  function createEvents() {\n    let exitCode = -1;\n    const events = {\n      close: deferred(),\n      closeTimeout: deferred(),\n      exit: deferred(),\n      exitTimeout: deferred()\n    };\n    const result = Promise.race([onClose === false ? never : events.closeTimeout.promise, onExit === false ? never : events.exitTimeout.promise]);\n    configureTimeout(onClose, events.close, events.closeTimeout);\n    configureTimeout(onExit, events.exit, events.exitTimeout);\n    return {\n      close(code) {\n        exitCode = code;\n        events.close.done();\n      },\n      exit(code) {\n        exitCode = code;\n        events.exit.done();\n      },\n      get exitCode() {\n        return exitCode;\n      },\n      result\n    };\n  }\n  function configureTimeout(flag, event, timeout) {\n    if (flag === false) {\n      return;\n    }\n    (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);\n  }\n  return {\n    type: \"spawn.after\",\n    action(_0, _1) {\n      return __async(this, arguments, function* (_data, {\n        spawned,\n        close\n      }) {\n        var _a2, _b;\n        const events = createEvents();\n        let deferClose = true;\n        let quickClose = () => void (deferClose = false);\n        (_a2 = spawned.stdout) == null ? void 0 : _a2.on(\"data\", quickClose);\n        (_b = spawned.stderr) == null ? void 0 : _b.on(\"data\", quickClose);\n        spawned.on(\"error\", quickClose);\n        spawned.on(\"close\", code => events.close(code));\n        spawned.on(\"exit\", code => events.exit(code));\n        try {\n          yield events.result;\n          if (deferClose) {\n            yield delay(50);\n          }\n          close(events.exitCode);\n        } catch (err) {\n          close(events.exitCode, err);\n        }\n      });\n    }\n  };\n}\n\n// src/lib/plugins/error-detection.plugin.ts\ninit_git_error();\nfunction isTaskError(result) {\n  return !!(result.exitCode && result.stdErr.length);\n}\nfunction getErrorMessage(result) {\n  return Buffer.concat([...result.stdOut, ...result.stdErr]);\n}\nfunction errorDetectionHandler(overwrite = false, isError = isTaskError, errorMessage = getErrorMessage) {\n  return (error, result) => {\n    if (!overwrite && error || !isError(result)) {\n      return error;\n    }\n    return errorMessage(result);\n  };\n}\nfunction errorDetectionPlugin(config) {\n  return {\n    type: \"task.error\",\n    action(data, context) {\n      const error = config(data.error, {\n        stdErr: context.stdErr,\n        stdOut: context.stdOut,\n        exitCode: context.exitCode\n      });\n      if (Buffer.isBuffer(error)) {\n        return {\n          error: new GitError(void 0, error.toString(\"utf-8\"))\n        };\n      }\n      return {\n        error\n      };\n    }\n  };\n}\n\n// src/lib/plugins/plugin-store.ts\ninit_utils();\nvar PluginStore = class {\n  constructor() {\n    this.plugins = /* @__PURE__ */new Set();\n  }\n  add(plugin) {\n    const plugins = [];\n    asArray(plugin).forEach(plugin2 => plugin2 && this.plugins.add(append(plugins, plugin2)));\n    return () => {\n      plugins.forEach(plugin2 => this.plugins.delete(plugin2));\n    };\n  }\n  exec(type, data, context) {\n    let output = data;\n    const contextual = Object.freeze(Object.create(context));\n    for (const plugin of this.plugins) {\n      if (plugin.type === type) {\n        output = plugin.action(output, contextual);\n      }\n    }\n    return output;\n  }\n};\n\n// src/lib/plugins/progress-monitor-plugin.ts\ninit_utils();\nfunction progressMonitorPlugin(progress) {\n  const progressCommand = \"--progress\";\n  const progressMethods = [\"checkout\", \"clone\", \"fetch\", \"pull\", \"push\"];\n  const onProgress = {\n    type: \"spawn.after\",\n    action(_data, context) {\n      var _a2;\n      if (!context.commands.includes(progressCommand)) {\n        return;\n      }\n      (_a2 = context.spawned.stderr) == null ? void 0 : _a2.on(\"data\", chunk => {\n        const message = /^([\\s\\S]+?):\\s*(\\d+)% \\((\\d+)\\/(\\d+)\\)/.exec(chunk.toString(\"utf8\"));\n        if (!message) {\n          return;\n        }\n        progress({\n          method: context.method,\n          stage: progressEventStage(message[1]),\n          progress: asNumber(message[2]),\n          processed: asNumber(message[3]),\n          total: asNumber(message[4])\n        });\n      });\n    }\n  };\n  const onArgs = {\n    type: \"spawn.args\",\n    action(args, context) {\n      if (!progressMethods.includes(context.method)) {\n        return args;\n      }\n      return including(args, progressCommand);\n    }\n  };\n  return [onArgs, onProgress];\n}\nfunction progressEventStage(input) {\n  return String(input.toLowerCase().split(\" \", 1)) || \"unknown\";\n}\n\n// src/lib/plugins/spawn-options-plugin.ts\ninit_utils();\nfunction spawnOptionsPlugin(spawnOptions) {\n  const options = pick(spawnOptions, [\"uid\", \"gid\"]);\n  return {\n    type: \"spawn.options\",\n    action(data) {\n      return __spreadValues(__spreadValues({}, options), data);\n    }\n  };\n}\n\n// src/lib/plugins/timout-plugin.ts\nfunction timeoutPlugin({\n  block,\n  stdErr = true,\n  stdOut = true\n}) {\n  if (block > 0) {\n    return {\n      type: \"spawn.after\",\n      action(_data, context) {\n        var _a2, _b;\n        let timeout;\n        function wait() {\n          timeout && clearTimeout(timeout);\n          timeout = setTimeout(kill, block);\n        }\n        function stop() {\n          var _a3, _b2;\n          (_a3 = context.spawned.stdout) == null ? void 0 : _a3.off(\"data\", wait);\n          (_b2 = context.spawned.stderr) == null ? void 0 : _b2.off(\"data\", wait);\n          context.spawned.off(\"exit\", stop);\n          context.spawned.off(\"close\", stop);\n          timeout && clearTimeout(timeout);\n        }\n        function kill() {\n          stop();\n          context.kill(new GitPluginError(void 0, \"timeout\", `block timeout reached`));\n        }\n        stdOut && ((_a2 = context.spawned.stdout) == null ? void 0 : _a2.on(\"data\", wait));\n        stdErr && ((_b = context.spawned.stderr) == null ? void 0 : _b.on(\"data\", wait));\n        context.spawned.on(\"exit\", stop);\n        context.spawned.on(\"close\", stop);\n        wait();\n      }\n    };\n  }\n}\n\n// src/lib/plugins/suffix-paths.plugin.ts\ninit_pathspec();\nfunction suffixPathsPlugin() {\n  return {\n    type: \"spawn.args\",\n    action(data) {\n      const prefix = [];\n      let suffix;\n      function append2(args) {\n        (suffix = suffix || []).push(...args);\n      }\n      for (let i = 0; i < data.length; i++) {\n        const param = data[i];\n        if (isPathSpec(param)) {\n          append2(toPaths(param));\n          continue;\n        }\n        if (param === \"--\") {\n          append2(data.slice(i + 1).flatMap(item => isPathSpec(item) && toPaths(item) || item));\n          break;\n        }\n        prefix.push(param);\n      }\n      return !suffix ? prefix : [...prefix, \"--\", ...suffix.map(String)];\n    }\n  };\n}\n\n// src/lib/git-factory.ts\ninit_utils();\nvar Git = require_git();\nfunction gitInstanceFactory(baseDir, options) {\n  const plugins = new PluginStore();\n  const config = createInstanceConfig(baseDir && (typeof baseDir === \"string\" ? {\n    baseDir\n  } : baseDir) || {}, options);\n  if (!folderExists(config.baseDir)) {\n    throw new GitConstructError(config, `Cannot use simple-git on a directory that does not exist`);\n  }\n  if (Array.isArray(config.config)) {\n    plugins.add(commandConfigPrefixingPlugin(config.config));\n  }\n  plugins.add(blockUnsafeOperationsPlugin(config.unsafe));\n  plugins.add(suffixPathsPlugin());\n  plugins.add(completionDetectionPlugin(config.completion));\n  config.abort && plugins.add(abortPlugin(config.abort));\n  config.progress && plugins.add(progressMonitorPlugin(config.progress));\n  config.timeout && plugins.add(timeoutPlugin(config.timeout));\n  config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));\n  plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));\n  config.errors && plugins.add(errorDetectionPlugin(config.errors));\n  return new Git(config, plugins);\n}\n\n// src/lib/runners/promise-wrapped.ts\ninit_git_response_error();\nvar functionNamesBuilderApi = [\"customBinary\", \"env\", \"outputHandler\", \"silent\"];\nvar functionNamesPromiseApi = [\"add\", \"addAnnotatedTag\", \"addConfig\", \"addRemote\", \"addTag\", \"applyPatch\", \"binaryCatFile\", \"branch\", \"branchLocal\", \"catFile\", \"checkIgnore\", \"checkIsRepo\", \"checkout\", \"checkoutBranch\", \"checkoutLatestTag\", \"checkoutLocalBranch\", \"clean\", \"clone\", \"commit\", \"cwd\", \"deleteLocalBranch\", \"deleteLocalBranches\", \"diff\", \"diffSummary\", \"exec\", \"fetch\", \"getRemotes\", \"init\", \"listConfig\", \"listRemote\", \"log\", \"merge\", \"mergeFromTo\", \"mirror\", \"mv\", \"pull\", \"push\", \"pushTags\", \"raw\", \"rebase\", \"remote\", \"removeRemote\", \"reset\", \"revert\", \"revparse\", \"rm\", \"rmKeepLocal\", \"show\", \"stash\", \"stashList\", \"status\", \"subModule\", \"submoduleAdd\", \"submoduleInit\", \"submoduleUpdate\", \"tag\", \"tags\", \"updateServerInfo\"];\nfunction gitP(...args) {\n  let git;\n  let chain = Promise.resolve();\n  try {\n    git = gitInstanceFactory(...args);\n  } catch (e) {\n    chain = Promise.reject(e);\n  }\n  function builderReturn() {\n    return promiseApi;\n  }\n  function chainReturn() {\n    return chain;\n  }\n  const promiseApi = [...functionNamesBuilderApi, ...functionNamesPromiseApi].reduce((api, name) => {\n    const isAsync = functionNamesPromiseApi.includes(name);\n    const valid = isAsync ? asyncWrapper(name, git) : syncWrapper(name, git, api);\n    const alternative = isAsync ? chainReturn : builderReturn;\n    Object.defineProperty(api, name, {\n      enumerable: false,\n      configurable: false,\n      value: git ? valid : alternative\n    });\n    return api;\n  }, {});\n  return promiseApi;\n  function asyncWrapper(fn, git2) {\n    return function (...args2) {\n      if (typeof args2[args2.length] === \"function\") {\n        throw new TypeError(\"Promise interface requires that handlers are not supplied inline, trailing function not allowed in call to \" + fn);\n      }\n      return chain.then(function () {\n        return new Promise(function (resolve, reject) {\n          const callback = (err, result) => {\n            if (err) {\n              return reject(toError(err));\n            }\n            resolve(result);\n          };\n          args2.push(callback);\n          git2[fn].apply(git2, args2);\n        });\n      });\n    };\n  }\n  function syncWrapper(fn, git2, api) {\n    return (...args2) => {\n      git2[fn](...args2);\n      return api;\n    };\n  }\n}\nfunction toError(error) {\n  if (error instanceof Error) {\n    return error;\n  }\n  if (typeof error === \"string\") {\n    return new Error(error);\n  }\n  return new GitResponseError(error);\n}\n\n// src/esm.mjs\nvar simpleGit = gitInstanceFactory;\nvar esm_default = gitInstanceFactory;\nexport { CheckRepoActions, CleanOptions, GitConfigScope, GitConstructError, GitError, GitPluginError, GitResponseError, ResetMode, TaskConfigurationError, esm_default as default, gitP, grepQueryBuilder, pathspec, simpleGit };","map":{"version":3,"names":["pathspec","paths","key","String","cache","set","isPathSpec","path","has","toPaths","pathSpec","get","init_pathspec","__esm","src/lib/args/pathspec.ts","WeakMap","GitError","init_git_error","src/lib/errors/git-error.ts","Error","constructor","task","message","Object","setPrototypeOf","new","target","prototype","GitResponseError","init_git_response_error","src/lib/errors/git-response-error.ts","git","TaskConfigurationError","init_task_configuration_error","src/lib/errors/task-configuration-error.ts","exists","FOLDER","asFunction","source","NOOP","isUserFunction","splitOn","input","char","index","indexOf","substr","first","offset","isArrayLike","length","last","toLinesWithContent","trimmed2","separator","split","reduce","output","line","lineContent","trim","push","forEachLineWithContent","callback","map","folderExists","append","item","Array","isArray","includes","add","including","remove","splice","delete","asArray","asStringArray","asNumber","onNaN","num","parseInt","isNaN","prefixedArray","prefix","i","max","bufferToString","Buffer","concat","toString","pick","properties","assign","property","delay","duration","Promise","done","setTimeout","NULL","objectToString","init_util","src/lib/utils/util.ts","call","bind","filterType","filter","def","arguments","filterPrimitives","omit","type","test","filterPlainObject","filterFunction","filterArray","filterString","filterStringArray","filterStringOrStringArray","filterHasLength","init_argument_filters","src/lib/utils/argument-filters.ts","every","ExitCodes","init_exit_codes","src/lib/utils/exit-codes.ts","ExitCodes2","GitOutputStreams","init_git_output_streams","src/lib/utils/git-output-streams.ts","stdOut","stdErr","asStrings","LineParser","RemoteLineParser","init_line_parser","src/lib/utils/line-parser.ts","regExp","useMatches","matches","parse","resetMatches","_regExp","reg","addMatch","prepareMatches","match","matched","exec","pushMatch","_index","slice","createInstanceConfig","options","baseDir","process","cwd","config","__spreadValues","defaultOptions","o","trimmed","init_simple_git_options","src/lib/utils/simple-git-options.ts","binary","maxConcurrentProcesses","appendTaskOptions","commands","keys","commands2","value","getTrailingOptions","args","initialPrimitive","objectOnly","command","trailingOptionsArgument","trailingArrayArgument","hasTrailingCallback","trailingFunctionArgument","includeNoop","init_task_options","src/lib/utils/task-options.ts","callTaskParser","parser3","streams","parseStringResponse","result","parsers12","texts","forEach","text","lines","some","init_task_parser","src/lib/utils/task-parser.ts","utils_exports","__export","init_utils","src/lib/utils/index.ts","check_is_repo_exports","CheckRepoActions","checkIsBareRepoTask","checkIsRepoRootTask","checkIsRepoTask","action","format","onError","parser","isNotRepoMessage","error","init_check_is_repo","src/lib/tasks/check-is-repo.ts","CheckRepoActions2","exitCode","fail","from","cleanSummaryParser","dryRun","summary","CleanResponse","regexp","dryRunRemovalRegexp","removalRegexp","removed","replace","isFolderRegexp","folders","files","init_CleanSummary","src/lib/responses/CleanSummary.ts","task_exports","EMPTY_COMMANDS","adhocExecTask","configurationErrorTask","isBufferTask","isEmptyTask","straightThroughBufferTask","straightThroughStringTask","buffer","init_task","src/lib/tasks/task.ts","clean_exports","CONFIG_ERROR_INTERACTIVE_MODE","CONFIG_ERROR_MODE_REQUIRED","CONFIG_ERROR_UNKNOWN_OPTION","CleanOptions","cleanTask","cleanWithOptionsTask","isCleanOptionsArray","mode","customArgs","cleanMode","valid","getCleanOptions","JSON","stringify","isInteractiveMode","CleanOptionValues","isCleanMode","isKnownOption","option","charAt","init_clean","src/lib/tasks/clean.ts","CleanOptions2","Set","values","configListParser","ConfigList","configParser","addValue","file","configGetParser","scopes","Map","configFilePath","filePath","requestedKey","init_ConfigList","src/lib/responses/ConfigList.ts","create","all","_all","addFile","latest","hasOwnProperty","asConfigScope","scope","fallback","GitConfigScope","addConfigTask","append2","getConfigTask","listConfigTask","config_default","addConfig","rest","_runTask","getConfig","listConfig","init_config","src/lib/tasks/config.ts","GitConfigScope2","grepQueryBuilder","params","GrepQuery","param","parseGrep","grep","results","preview","grep_default","searchTerm","then","disallowedOptions","Query","_a","init_grep","src/lib/tasks/grep.ts","Symbol","iterator","query","and","reset_exports","ResetMode","getResetMode","resetTask","isValidResetMode","ResetModes","init_reset","src/lib/tasks/reset.ts","ResetMode2","debug","createLog","prefixedLogger","to","forward","childLoggerName","name","childDebugger","namespace","parentNamespace","childNamespace","startsWith","createLogger","label","verbose","initialStep","infoDebugger","labelPrefix","spawned","debugDebugger","extend","step","sibling","initial","phase","stepPrefix","debug2","info","init_git_logger","src/lib/git-logger.ts","formatters","L","B","isBuffer","_TasksPendingQueue","TasksPendingQueue","init_tasks_pending_queue","src/lib/runners/tasks-pending-queue.ts","logLabel","_queue","withProgress","createProgress","getName","logger","progress","fatal","err","entries","complete","size","attempt","counter","spawn","pluginContext","method","onErrorReceived","stack","onDataReceived","GitExecutorChain","init_git_executor_chain","src/lib/runners/git-executor-chain.ts","_executor","_scheduler","_plugins","_chain","resolve","_cwd","env","outputHandler","chain","attemptTask","__async","onScheduleComplete","next","onQueueComplete","attemptEmptyTask","attemptRemoteTask","e","onFatalException","gitError","raw","gitResponse","outputStreams","handleTaskData","rejection","newStdOut","outputLogger","spawnOptions","windowsHide","_beforeSpawn","__spreadProps","kill","reason","stdout","on","stderr","close","killed","git_executor_exports","GitExecutor","init_git_executor","src/lib/runners/git-executor.ts","taskCallback","response","onSuccess","data","onError2","addDeprecationNoticeToError","log","console","warn","getOwnPropertyNames","descriptorReducer","enumerable","configurable","init_task_callback","src/lib/task-callback.ts","changeWorkingDirectoryTask","directory","root","instance","init_change_working_directory","src/lib/tasks/change-working-directory.ts","checkoutTask","checkout_default","checkout","checkoutBranch","branchName","startPoint","checkoutLocalBranch","init_checkout","src/lib/tasks/checkout.ts","parseCommitResult","author","branch","commit","changes","insertions","deletions","parsers","init_parse_commit","src/lib/parsers/parse-commit.ts","parts","email","pop","join","direction","count","commitTask","commit_default","rejectDeprecatedSignatures","init_commit","src/lib/tasks/commit.ts","first_commit_default","firstCommit","init_first_commit","src/lib/tasks/first-commit.ts","hashObjectTask","write","init_hash_object","src/lib/tasks/hash-object.ts","parseInit","bare","initResponseRegex","InitSummary","reInitResponseRegex","gitDir","tokens","token","shift","init_InitSummary","src/lib/responses/InitSummary.ts","existing","hasBareCommand","bareCommand","initTask","init_init","src/lib/tasks/init.ts","logFormatFromCommand","logFormatRegex","isLogFormat","customArg","init_log_format","src/lib/args/log-format.ts","DiffSummary","init_DiffSummary","src/lib/responses/DiffSummary.ts","changed","getDiffParser","diffSummaryParsers","statParser","numStatParser","nameOnlyParser","nameStatusParser","init_parse_diff_summary","src/lib/parsers/parse-diff-summary.ts","alterations","before","after","inserted","deleted","changesInsert","changesDelete","_status","lineBuilder","fields","field","diff","createListLogSummaryParser","splitter","SPLITTER","defaultFieldNames","logFormat","parseDiffResult","START_BOUNDARY","lineDetail","COMMIT_BOUNDARY","listLogLine","total","init_parse_list_log_summary","src/lib/parsers/parse-list-log-summary.ts","diff_exports","diffSummaryTask","validateLogFormatConfig","flags","init_diff","src/lib/tasks/diff.ts","prettyFormat","formatStr","userOptions","out","excludeOptions","parseLogOptions","opt","hash","date","strictDate","refs","body","multiLine","author_name","mailMap","author_email","suffix","maxCount","n","rangeOperator","symmetric","logTask","log_default","createLogTask","init_log","src/lib/tasks/log.ts","excludeOptions2","MergeSummaryConflict","MergeSummaryDetail","init_MergeSummary","src/lib/responses/MergeSummary.ts","meta","conflicts","merges","failed","PullSummary","PullFailedSummary","init_PullSummary","src/lib/responses/PullSummary.ts","remoteMessages","created","remote","local","objectEnumerationResult","objects","compressing","counting","enumerating","packReused","reused","delta","asObjectCount","remoteMessagesObjectParsers","init_parse_remote_objects","src/lib/parsers/parse-remote-objects.ts","toLowerCase","enumeration","parseRemoteMessages","_stdOut","RemoteMessageSummary","parsers2","init_parse_remote_messages","src/lib/parsers/parse-remote-messages.ts","pullRequestUrl","url","vulnerabilities","parsePullErrorResult","pullError","errorParsers","FILE_UPDATE_REGEX","SUMMARY_REGEX","ACTION_REGEX","parsers3","parsePullDetail","parsePullResult","init_parse_pull","src/lib/parsers/parse-pull.ts","hashLocal","hashRemote","branchLocal","branchRemote","parsers4","parseMergeResult","parseMergeDetail","init_parse_merge","src/lib/parsers/parse-merge.ts","autoMerge","deleteRef","mergeTask","merge","init_merge","src/lib/tasks/merge.ts","pushResultPushedItem","status","tag","alreadyUpdated","parsers5","parsePushResult","parsePushDetail","init_parse_push","src/lib/parsers/parse-push.ts","repo","ref","pushed","remoteName","update","head","pushDetail","responseDetail","push_exports","pushTagsTask","pushTask","init_push","src/lib/tasks/push.ts","show_default","showBuffer","show","init_show","src/lib/tasks/show.ts","fromPathRegex","FileStatusSummary","init_FileStatusSummary","src/lib/responses/FileStatusSummary.ts","working_dir","detail","renamedFile","parser2","indexX","indexY","handler","y","conflicted","splitLine","lineStr","workingDir","parsers6","StatusSummary","parseStatusSummary","init_StatusSummary","src/lib/responses/StatusSummary.ts","not_added","ignored","modified","renamed","staged","ahead","behind","current","tracking","detached","isClean","_result","_file","aheadReg","behindReg","currentReg","trackingReg","onEmptyBranchReg","regexResult","l","statusTask","arg","ignoredOptions","init_status","src/lib/tasks/status.ts","versionResponse","major","minor","patch","agent","installed","defineProperty","notInstalledResponse","version_default","version","versionParser","NOT_INSTALLED","parsers7","init_version","src/lib/tasks/version.ts","simple_git_api_exports","SimpleGitApi","init_simple_git_api","src/lib/simple-git-api.ts","promise","catch","hashObject","init","mergeFromTo","stash","scheduler_exports","Scheduler","createDeferred","createScheduledTask","init_scheduler","src/lib/runners/scheduler.ts","id","concurrency","pending","running","schedule","apply_patch_exports","applyPatchTask","patches","init_apply_patch","src/lib/tasks/apply-patch.ts","branchDeletionSuccess","success","branchDeletionFailure","BranchDeletionBatch","init_BranchDeleteSummary","src/lib/responses/BranchDeleteSummary.ts","branches","errors","hasBranchDeletionError","processExitCode","deleteErrorRegex","deleteSuccessRegex","parsers8","parseBranchDeletions","init_parse_branch_delete","src/lib/parsers/parse-branch-delete.ts","deletion","BranchSummaryResult","init_BranchSummary","src/lib/responses/BranchSummary.ts","linkedWorkTree","branchStatus","parseBranchSummary","parsers9","init_parse_branch","src/lib/parsers/parse-branch.ts","branch_exports","branchLocalTask","branchTask","containsDeleteBranchCommand","deleteBranchTask","deleteBranchesTask","deleteCommands","isDelete","forceDelete","_","init_branch","src/lib/tasks/branch.ts","parseCheckIgnore","init_CheckIgnore","src/lib/responses/CheckIgnore.ts","check_ignore_exports","checkIgnoreTask","init_check_ignore","src/lib/tasks/check-ignore.ts","clone_exports","cloneMirrorTask","cloneTask","disallowedCommand","banned","find","init_clone","src/lib/tasks/clone.ts","parseFetchResult","tags","updated","parsers10","init_parse_fetch","src/lib/parsers/parse-fetch.ts","fetch_exports","fetchTask","disallowedCommand2","init_fetch","src/lib/tasks/fetch.ts","parseMoveResult","moves","parsers11","init_parse_move","src/lib/parsers/parse-move.ts","move_exports","moveTask","init_move","src/lib/tasks/move.ts","pull_exports","pullTask","_error","_done","init_pull","src/lib/tasks/pull.ts","parseGetRemotes","remotes","parseGetRemotesVerbose","purpose","fetch","init_GetRemoteSummary","src/lib/responses/GetRemoteSummary.ts","remote_exports","addRemoteTask","getRemotesTask","listRemotesTask","remoteTask","removeRemoteTask","remoteRepo","unshift","init_remote","src/lib/tasks/remote.ts","stash_list_exports","stashListTask","init_stash_list","src/lib/tasks/stash-list.ts","sub_module_exports","addSubModuleTask","initSubModuleTask","subModuleTask","updateSubModuleTask","init_sub_module","src/lib/tasks/sub-module.ts","singleSorted","a","b","aIsNum","bIsNum","sorted","toNumber","TagList","parseTagList","init_TagList","src/lib/responses/TagList.ts","customSort","Boolean","sort","tagA","tagB","partsA","partsB","Math","reverse","tag_exports","addAnnotatedTagTask","addTagTask","tagListTask","hasCustomSort","tagMessage","init_tag","src/lib/tasks/tag.ts","require_git","__commonJS","src/git.js","exports","module","GitExecutor2","__toCommonJS","SimpleGitApi2","Scheduler2","configurationErrorTask2","asArray2","filterArray2","filterPrimitives2","filterString2","filterStringOrStringArray2","filterType2","getTrailingOptions2","trailingFunctionArgument2","trailingOptionsArgument2","applyPatchTask2","branchTask2","branchLocalTask2","deleteBranchesTask2","deleteBranchTask2","checkIgnoreTask2","checkIsRepoTask2","cloneTask2","cloneMirrorTask2","cleanWithOptionsTask2","isCleanOptionsArray2","diffSummaryTask2","fetchTask2","moveTask2","pullTask2","pushTagsTask2","addRemoteTask2","getRemotesTask2","listRemotesTask2","remoteTask2","removeRemoteTask2","getResetMode2","resetTask2","stashListTask2","addSubModuleTask2","initSubModuleTask2","subModuleTask2","updateSubModuleTask2","addAnnotatedTagTask2","addTagTask2","tagListTask2","straightThroughBufferTask2","straightThroughStringTask2","Git2","plugins","_trimmed","customBinary","stashList","createCloneTask","api","repoPath","localPath","clone","mirror","mv","checkoutLatestTag","pull","silent","silence","rebase","reset","revert","addTag","addAnnotatedTag","tagName","deleteLocalBranch","deleteLocalBranches","branchNames","createRestCommands","submoduleAdd","submoduleUpdate","submoduleInit","subModule","listRemote","addRemote","removeRemote","getRemotes","updateServerInfo","pushTags","rm","rmKeepLocal","catFile","_catFile","binaryCatFile","apply","diffSummary","applyPatch","revparse","clean","usingCleanOptionsArray","clearQueue","checkIgnore","pathnames","checkIsRepo","checkType","GitConstructError","GitPluginError","plugin","abortPlugin","signal","onSpawnAfter","_data","context","addEventListener","removeEventListener","onSpawnBefore","aborted","isConfigSwitch","preventProtocolOverride","preventUploadPack","blockUnsafeOperationsPlugin","allowUnsafeProtocolOverride","allowUnsafePack","commandConfigPrefixingPlugin","configuration","deferred","never","completionDetectionPlugin","onClose","onExit","createEvents","events","closeTimeout","exit","exitTimeout","race","configureTimeout","code","flag","event","timeout","_0","_1","_a2","_b","deferClose","quickClose","isTaskError","getErrorMessage","errorDetectionHandler","overwrite","isError","errorMessage","errorDetectionPlugin","PluginStore","plugin2","contextual","freeze","progressMonitorPlugin","progressCommand","progressMethods","onProgress","chunk","stage","progressEventStage","processed","onArgs","spawnOptionsPlugin","timeoutPlugin","block","wait","clearTimeout","stop","_a3","_b2","off","suffixPathsPlugin","flatMap","Git","gitInstanceFactory","unsafe","completion","abort","functionNamesBuilderApi","functionNamesPromiseApi","gitP","reject","builderReturn","promiseApi","chainReturn","isAsync","asyncWrapper","syncWrapper","alternative","fn","git2","args2","TypeError","toError","simpleGit","esm_default"],"sources":["C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\args\\pathspec.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\errors\\git-error.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\errors\\git-response-error.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\errors\\task-configuration-error.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\utils\\util.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\utils\\argument-filters.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\utils\\exit-codes.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\utils\\git-output-streams.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\utils\\line-parser.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\utils\\simple-git-options.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\utils\\task-options.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\utils\\task-parser.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\utils\\index.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\check-is-repo.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\responses\\CleanSummary.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\task.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\clean.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\responses\\ConfigList.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\config.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\grep.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\reset.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\git-logger.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\runners\\tasks-pending-queue.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\runners\\git-executor-chain.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\runners\\git-executor.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\task-callback.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\change-working-directory.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\checkout.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\parsers\\parse-commit.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\commit.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\first-commit.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\hash-object.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\responses\\InitSummary.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\init.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\args\\log-format.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\responses\\DiffSummary.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\parsers\\parse-diff-summary.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\parsers\\parse-list-log-summary.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\diff.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\log.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\responses\\MergeSummary.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\responses\\PullSummary.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\parsers\\parse-remote-objects.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\parsers\\parse-remote-messages.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\parsers\\parse-pull.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\parsers\\parse-merge.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\merge.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\parsers\\parse-push.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\push.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\show.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\responses\\FileStatusSummary.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\responses\\StatusSummary.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\status.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\version.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\simple-git-api.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\runners\\scheduler.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\apply-patch.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\responses\\BranchDeleteSummary.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\parsers\\parse-branch-delete.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\responses\\BranchSummary.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\parsers\\parse-branch.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\branch.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\responses\\CheckIgnore.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\check-ignore.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\clone.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\parsers\\parse-fetch.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\fetch.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\parsers\\parse-move.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\move.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\pull.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\responses\\GetRemoteSummary.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\remote.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\stash-list.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\sub-module.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\responses\\TagList.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\tasks\\tag.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\git.js","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\api.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\errors\\git-construct-error.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\errors\\git-plugin-error.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\plugins\\abort-plugin.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\plugins\\block-unsafe-operations-plugin.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\plugins\\command-config-prefixing-plugin.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\plugins\\completion-detection.plugin.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\plugins\\error-detection.plugin.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\plugins\\plugin-store.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\plugins\\progress-monitor-plugin.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\plugins\\spawn-options-plugin.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\plugins\\timout-plugin.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\plugins\\suffix-paths.plugin.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\git-factory.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\lib\\runners\\promise-wrapped.ts","C:\\Users\\HarshitSrivastava\\Desktop\\Practice\\React\\Project2\\my-app\\node_modules\\simple-git\\src\\esm.mjs"],"sourcesContent":["const cache = new WeakMap<String, string[]>();\n\nexport function pathspec(...paths: string[]) {\n   const key = new String(paths);\n   cache.set(key, paths);\n\n   return key as string;\n}\n\nexport function isPathSpec(path: string | unknown): path is string {\n   return path instanceof String && cache.has(path);\n}\n\nexport function toPaths(pathSpec: string): string[] {\n   return cache.get(pathSpec) || [];\n}\n","import type { SimpleGitTask } from '../types';\n\n/**\n * The `GitError` is thrown when the underlying `git` process throws a\n * fatal exception (eg an `ENOENT` exception when attempting to use a\n * non-writable directory as the root for your repo), and acts as the\n * base class for more specific errors thrown by the parsing of the\n * git response or errors in the configuration of the task about to\n * be run.\n *\n * When an exception is thrown, pending tasks in the same instance will\n * not be executed. The recommended way to run a series of tasks that\n * can independently fail without needing to prevent future tasks from\n * running is to catch them individually:\n *\n * ```typescript\n import { gitP, SimpleGit, GitError, PullResult } from 'simple-git';\n\n function catchTask (e: GitError) {\n   return e.\n }\n\n const git = gitP(repoWorkingDir);\n const pulled: PullResult | GitError = await git.pull().catch(catchTask);\n const pushed: string | GitError = await git.pushTags().catch(catchTask);\n ```\n */\nexport class GitError extends Error {\n   constructor(\n      public task?: SimpleGitTask<any>,\n      message?: string\n   ) {\n      super(message);\n      Object.setPrototypeOf(this, new.target.prototype);\n   }\n}\n","import { GitError } from './git-error';\n\n/**\n * The `GitResponseError` is the wrapper for a parsed response that is treated as\n * a fatal error, for example attempting a `merge` can leave the repo in a corrupted\n * state when there are conflicts so the task will reject rather than resolve.\n *\n * For example, catching the merge conflict exception:\n *\n * ```typescript\n import { gitP, SimpleGit, GitResponseError, MergeSummary } from 'simple-git';\n\n const git = gitP(repoRoot);\n const mergeOptions: string[] = ['--no-ff', 'other-branch'];\n const mergeSummary: MergeSummary = await git.merge(mergeOptions)\n      .catch((e: GitResponseError<MergeSummary>) => e.git);\n\n if (mergeSummary.failed) {\n   // deal with the error\n }\n ```\n */\nexport class GitResponseError<T = any> extends GitError {\n   constructor(\n      /**\n       * `.git` access the parsed response that is treated as being an error\n       */\n      public readonly git: T,\n      message?: string\n   ) {\n      super(undefined, message || String(git));\n   }\n}\n","import { GitError } from './git-error';\n\n/**\n * The `TaskConfigurationError` is thrown when a command was incorrectly\n * configured. An error of this kind means that no attempt was made to\n * run your command through the underlying `git` binary.\n *\n * Check the `.message` property for more detail on why your configuration\n * resulted in an error.\n */\nexport class TaskConfigurationError extends GitError {\n   constructor(message?: string) {\n      super(undefined, message);\n   }\n}\n","import { exists, FOLDER } from '@kwsites/file-exists';\nimport { Maybe } from '../types';\n\nexport const NULL = '\\0';\n\nexport const NOOP: (...args: any[]) => void = () => {};\n\n/**\n * Returns either the source argument when it is a `Function`, or the default\n * `NOOP` function constant\n */\nexport function asFunction<T extends () => any>(source: T | any): T {\n   return typeof source === 'function' ? source : NOOP;\n}\n\n/**\n * Determines whether the supplied argument is both a function, and is not\n * the `NOOP` function.\n */\nexport function isUserFunction<T extends Function>(source: T | any): source is T {\n   return typeof source === 'function' && source !== NOOP;\n}\n\nexport function splitOn(input: string, char: string): [string, string] {\n   const index = input.indexOf(char);\n   if (index <= 0) {\n      return [input, ''];\n   }\n\n   return [input.substr(0, index), input.substr(index + 1)];\n}\n\nexport function first<T extends any[]>(input: T, offset?: number): Maybe<T[number]>;\nexport function first<T extends IArguments>(input: T, offset?: number): Maybe<unknown>;\nexport function first(input: any[] | IArguments, offset = 0): Maybe<unknown> {\n   return isArrayLike(input) && input.length > offset ? input[offset] : undefined;\n}\n\nexport function last<T extends any[]>(input: T, offset?: number): Maybe<T[number]>;\nexport function last<T extends IArguments>(input: T, offset?: number): Maybe<unknown>;\nexport function last<T>(input: T, offset?: number): Maybe<unknown>;\nexport function last(input: unknown, offset = 0) {\n   if (isArrayLike(input) && input.length > offset) {\n      return input[input.length - 1 - offset];\n   }\n}\n\ntype ArrayLike<T = any> = T[] | IArguments | { [index: number]: T; length: number };\n\nfunction isArrayLike(input: any): input is ArrayLike {\n   return !!(input && typeof input.length === 'number');\n}\n\nexport function toLinesWithContent(input = '', trimmed = true, separator = '\\n'): string[] {\n   return input.split(separator).reduce((output, line) => {\n      const lineContent = trimmed ? line.trim() : line;\n      if (lineContent) {\n         output.push(lineContent);\n      }\n      return output;\n   }, [] as string[]);\n}\n\ntype LineWithContentCallback<T = void> = (line: string) => T;\n\nexport function forEachLineWithContent<T>(\n   input: string,\n   callback: LineWithContentCallback<T>\n): T[] {\n   return toLinesWithContent(input, true).map((line) => callback(line));\n}\n\nexport function folderExists(path: string): boolean {\n   return exists(path, FOLDER);\n}\n\n/**\n * Adds `item` into the `target` `Array` or `Set` when it is not already present and returns the `item`.\n */\nexport function append<T>(target: T[] | Set<T>, item: T): typeof item {\n   if (Array.isArray(target)) {\n      if (!target.includes(item)) {\n         target.push(item);\n      }\n   } else {\n      target.add(item);\n   }\n   return item;\n}\n\n/**\n * Adds `item` into the `target` `Array` when it is not already present and returns the `target`.\n */\nexport function including<T>(target: T[], item: T): typeof target {\n   if (Array.isArray(target) && !target.includes(item)) {\n      target.push(item);\n   }\n\n   return target;\n}\n\nexport function remove<T>(target: Set<T> | T[], item: T): T {\n   if (Array.isArray(target)) {\n      const index = target.indexOf(item);\n      if (index >= 0) {\n         target.splice(index, 1);\n      }\n   } else {\n      target.delete(item);\n   }\n   return item;\n}\n\nexport const objectToString = Object.prototype.toString.call.bind(Object.prototype.toString) as (\n   input: any\n) => string;\n\nexport function asArray<T>(source: T | T[]): T[] {\n   return Array.isArray(source) ? source : [source];\n}\n\nexport function asStringArray<T>(source: T | T[]): string[] {\n   return asArray(source).map(String);\n}\n\nexport function asNumber(source: string | null | undefined, onNaN = 0) {\n   if (source == null) {\n      return onNaN;\n   }\n\n   const num = parseInt(source, 10);\n   return isNaN(num) ? onNaN : num;\n}\n\nexport function prefixedArray<T>(input: T[], prefix: T): T[] {\n   const output: T[] = [];\n   for (let i = 0, max = input.length; i < max; i++) {\n      output.push(prefix, input[i]);\n   }\n   return output;\n}\n\nexport function bufferToString(input: Buffer | Buffer[]): string {\n   return (Array.isArray(input) ? Buffer.concat(input) : input).toString('utf-8');\n}\n\n/**\n * Get a new object from a source object with only the listed properties.\n */\nexport function pick(source: Record<string, any>, properties: string[]) {\n   return Object.assign(\n      {},\n      ...properties.map((property) => (property in source ? { [property]: source[property] } : {}))\n   );\n}\n\nexport function delay(duration = 0): Promise<void> {\n   return new Promise((done) => setTimeout(done, duration));\n}\n","import { Maybe, Options, Primitives } from '../types';\nimport { objectToString } from './util';\nimport { isPathSpec } from '../args/pathspec';\n\nexport interface ArgumentFilterPredicate<T> {\n   (input: any): input is T;\n}\n\nexport function filterType<T, K>(\n   input: K,\n   filter: ArgumentFilterPredicate<T>\n): K extends T ? T : undefined;\nexport function filterType<T, K>(input: K, filter: ArgumentFilterPredicate<T>, def: T): T;\nexport function filterType<T, K>(input: K, filter: ArgumentFilterPredicate<T>, def?: T): Maybe<T> {\n   if (filter(input)) {\n      return input;\n   }\n   return arguments.length > 2 ? def : undefined;\n}\n\nexport const filterArray: ArgumentFilterPredicate<Array<any>> = (input): input is Array<any> => {\n   return Array.isArray(input);\n};\n\nexport function filterPrimitives(\n   input: unknown,\n   omit?: Array<'boolean' | 'string' | 'number'>\n): input is Primitives {\n   const type = isPathSpec(input) ? 'string' : typeof input;\n\n   return (\n      /number|string|boolean/.test(type) &&\n      (!omit || !omit.includes(type as 'boolean' | 'string' | 'number'))\n   );\n}\n\nexport const filterString: ArgumentFilterPredicate<string> = (input): input is string => {\n   return typeof input === 'string';\n};\n\nexport const filterStringArray: ArgumentFilterPredicate<string[]> = (input): input is string[] => {\n   return Array.isArray(input) && input.every(filterString);\n};\n\nexport const filterStringOrStringArray: ArgumentFilterPredicate<string | string[]> = (\n   input\n): input is string | string[] => {\n   return filterString(input) || (Array.isArray(input) && input.every(filterString));\n};\n\nexport function filterPlainObject<T extends Options>(input: T | unknown): input is T;\nexport function filterPlainObject<T extends Object>(input: T | unknown): input is T {\n   return !!input && objectToString(input) === '[object Object]';\n}\n\nexport function filterFunction(input: unknown): input is Function {\n   return typeof input === 'function';\n}\n\nexport const filterHasLength: ArgumentFilterPredicate<{ length: number }> = (\n   input\n): input is { length: number } => {\n   if (input == null || 'number|boolean|function'.includes(typeof input)) {\n      return false;\n   }\n   return Array.isArray(input) || typeof input === 'string' || typeof input.length === 'number';\n};\n","/**\n * Known process exit codes used by the task parsers to determine whether an error\n * was one they can automatically handle\n */\nexport enum ExitCodes {\n   SUCCESS,\n   ERROR,\n   NOT_FOUND = -2,\n   UNCLEAN = 128,\n}\n","import { TaskResponseFormat } from '../types';\n\nexport class GitOutputStreams<T extends TaskResponseFormat = Buffer> {\n   constructor(\n      public readonly stdOut: T,\n      public readonly stdErr: T\n   ) {}\n\n   asStrings(): GitOutputStreams<string> {\n      return new GitOutputStreams(this.stdOut.toString('utf8'), this.stdErr.toString('utf8'));\n   }\n}\n","export class LineParser<T> {\n   protected matches: string[] = [];\n\n   private _regExp: RegExp[];\n\n   constructor(\n      regExp: RegExp | RegExp[],\n      useMatches?: (target: T, match: string[]) => boolean | void\n   ) {\n      this._regExp = Array.isArray(regExp) ? regExp : [regExp];\n      if (useMatches) {\n         this.useMatches = useMatches;\n      }\n   }\n\n   parse = (line: (offset: number) => string | undefined, target: T): boolean => {\n      this.resetMatches();\n\n      if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {\n         return false;\n      }\n\n      return this.useMatches(target, this.prepareMatches()) !== false;\n   };\n\n   // @ts-ignore\n   protected useMatches(target: T, match: string[]): boolean | void {\n      throw new Error(`LineParser:useMatches not implemented`);\n   }\n\n   protected resetMatches() {\n      this.matches.length = 0;\n   }\n\n   protected prepareMatches() {\n      return this.matches;\n   }\n\n   protected addMatch(reg: RegExp, index: number, line?: string) {\n      const matched = line && reg.exec(line);\n      if (matched) {\n         this.pushMatch(index, matched);\n      }\n\n      return !!matched;\n   }\n\n   protected pushMatch(_index: number, matched: string[]) {\n      this.matches.push(...matched.slice(1));\n   }\n}\n\nexport class RemoteLineParser<T> extends LineParser<T> {\n   protected addMatch(reg: RegExp, index: number, line?: string): boolean {\n      return /^remote:\\s/.test(String(line)) && super.addMatch(reg, index, line);\n   }\n\n   protected pushMatch(index: number, matched: string[]) {\n      if (index > 0 || matched.length > 1) {\n         super.pushMatch(index, matched);\n      }\n   }\n}\n","import { SimpleGitOptions } from '../types';\n\nconst defaultOptions: Omit<SimpleGitOptions, 'baseDir'> = {\n   binary: 'git',\n   maxConcurrentProcesses: 5,\n   config: [],\n   trimmed: false,\n};\n\nexport function createInstanceConfig(\n   ...options: Array<Partial<SimpleGitOptions> | undefined>\n): SimpleGitOptions {\n   const baseDir = process.cwd();\n   const config: SimpleGitOptions = Object.assign(\n      { baseDir, ...defaultOptions },\n      ...options.filter((o) => typeof o === 'object' && o)\n   );\n\n   config.baseDir = config.baseDir || baseDir;\n   config.trimmed = config.trimmed === true;\n\n   return config;\n}\n","import {\n   filterArray,\n   filterFunction,\n   filterPlainObject,\n   filterPrimitives,\n   filterType,\n} from './argument-filters';\nimport { asFunction, isUserFunction, last } from './util';\nimport { Maybe, Options, OptionsValues } from '../types';\nimport { isPathSpec } from '../args/pathspec';\n\nexport function appendTaskOptions<T extends Options = Options>(\n   options: Maybe<T>,\n   commands: string[] = []\n): string[] {\n   if (!filterPlainObject<Options>(options)) {\n      return commands;\n   }\n\n   return Object.keys(options).reduce((commands: string[], key: string) => {\n      const value: OptionsValues = options[key];\n\n      if (isPathSpec(value)) {\n         commands.push(value);\n      } else if (filterPrimitives(value, ['boolean'])) {\n         commands.push(key + '=' + value);\n      } else {\n         commands.push(key);\n      }\n\n      return commands;\n   }, commands);\n}\n\nexport function getTrailingOptions(\n   args: IArguments,\n   initialPrimitive = 0,\n   objectOnly = false\n): string[] {\n   const command: string[] = [];\n\n   for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {\n      if ('string|number'.includes(typeof args[i])) {\n         command.push(String(args[i]));\n      }\n   }\n\n   appendTaskOptions(trailingOptionsArgument(args), command);\n   if (!objectOnly) {\n      command.push(...trailingArrayArgument(args));\n   }\n\n   return command;\n}\n\nfunction trailingArrayArgument(args: IArguments) {\n   const hasTrailingCallback = typeof last(args) === 'function';\n   return filterType(last(args, hasTrailingCallback ? 1 : 0), filterArray, []);\n}\n\n/**\n * Given any number of arguments, returns the trailing options argument, ignoring a trailing function argument\n * if there is one. When not found, the return value is null.\n */\nexport function trailingOptionsArgument(args: IArguments): Maybe<Options> {\n   const hasTrailingCallback = filterFunction(last(args));\n   return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);\n}\n\n/**\n * Returns either the source argument when it is a `Function`, or the default\n * `NOOP` function constant\n */\nexport function trailingFunctionArgument(\n   args: unknown[] | IArguments | unknown,\n   includeNoop = true\n): Maybe<(...args: any[]) => unknown> {\n   const callback = asFunction(last(args));\n   return includeNoop || isUserFunction(callback) ? callback : undefined;\n}\n","import type { MaybeArray, TaskParser, TaskResponseFormat } from '../types';\nimport { GitOutputStreams } from './git-output-streams';\nimport { LineParser } from './line-parser';\nimport { asArray, toLinesWithContent } from './util';\n\nexport function callTaskParser<INPUT extends TaskResponseFormat, RESPONSE>(\n   parser: TaskParser<INPUT, RESPONSE>,\n   streams: GitOutputStreams<INPUT>\n) {\n   return parser(streams.stdOut, streams.stdErr);\n}\n\nexport function parseStringResponse<T>(\n   result: T,\n   parsers: LineParser<T>[],\n   texts: MaybeArray<string>,\n   trim = true\n): T {\n   asArray(texts).forEach((text) => {\n      for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {\n         const line = (offset = 0) => {\n            if (i + offset >= max) {\n               return;\n            }\n            return lines[i + offset];\n         };\n\n         parsers.some(({ parse }) => parse(line, result));\n      }\n   });\n\n   return result;\n}\n","export * from './argument-filters';\nexport * from './exit-codes';\nexport * from './git-output-streams';\nexport * from './line-parser';\nexport * from './simple-git-options';\nexport * from './task-options';\nexport * from './task-parser';\nexport * from './util';\n","import { ExitCodes } from '../utils';\nimport { Maybe, StringTask } from '../types';\n\nexport enum CheckRepoActions {\n   BARE = 'bare',\n   IN_TREE = 'tree',\n   IS_REPO_ROOT = 'root',\n}\n\nconst onError: StringTask<boolean>['onError'] = ({ exitCode }, error, done, fail) => {\n   if (exitCode === ExitCodes.UNCLEAN && isNotRepoMessage(error)) {\n      return done(Buffer.from('false'));\n   }\n\n   fail(error);\n};\n\nconst parser: StringTask<boolean>['parser'] = (text) => {\n   return text.trim() === 'true';\n};\n\nexport function checkIsRepoTask(action: Maybe<CheckRepoActions>): StringTask<boolean> {\n   switch (action) {\n      case CheckRepoActions.BARE:\n         return checkIsBareRepoTask();\n      case CheckRepoActions.IS_REPO_ROOT:\n         return checkIsRepoRootTask();\n   }\n\n   const commands = ['rev-parse', '--is-inside-work-tree'];\n\n   return {\n      commands,\n      format: 'utf-8',\n      onError,\n      parser,\n   };\n}\n\nexport function checkIsRepoRootTask(): StringTask<boolean> {\n   const commands = ['rev-parse', '--git-dir'];\n\n   return {\n      commands,\n      format: 'utf-8',\n      onError,\n      parser(path) {\n         return /^\\.(git)?$/.test(path.trim());\n      },\n   };\n}\n\nexport function checkIsBareRepoTask(): StringTask<boolean> {\n   const commands = ['rev-parse', '--is-bare-repository'];\n\n   return {\n      commands,\n      format: 'utf-8',\n      onError,\n      parser,\n   };\n}\n\nfunction isNotRepoMessage(error: Error): boolean {\n   return /(Not a git repository|Kein Git-Repository)/i.test(String(error));\n}\n","import { CleanSummary } from '../../../typings';\nimport { toLinesWithContent } from '../utils';\n\nexport class CleanResponse implements CleanSummary {\n   public paths: string[] = [];\n   public files: string[] = [];\n   public folders: string[] = [];\n\n   constructor(public readonly dryRun: boolean) {}\n}\n\nconst removalRegexp = /^[a-z]+\\s*/i;\nconst dryRunRemovalRegexp = /^[a-z]+\\s+[a-z]+\\s*/i;\nconst isFolderRegexp = /\\/$/;\n\nexport function cleanSummaryParser(dryRun: boolean, text: string): CleanSummary {\n   const summary = new CleanResponse(dryRun);\n   const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;\n\n   toLinesWithContent(text).forEach((line) => {\n      const removed = line.replace(regexp, '');\n\n      summary.paths.push(removed);\n      (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);\n   });\n\n   return summary;\n}\n","import { TaskConfigurationError } from '../errors/task-configuration-error';\nimport type { BufferTask, EmptyTaskParser, SimpleGitTask, StringTask } from '../types';\n\nexport const EMPTY_COMMANDS: [] = [];\n\nexport type EmptyTask = {\n   commands: typeof EMPTY_COMMANDS;\n   format: 'empty';\n   parser: EmptyTaskParser;\n   onError?: undefined;\n};\n\nexport function adhocExecTask(parser: EmptyTaskParser): EmptyTask {\n   return {\n      commands: EMPTY_COMMANDS,\n      format: 'empty',\n      parser,\n   };\n}\n\nexport function configurationErrorTask(error: Error | string): EmptyTask {\n   return {\n      commands: EMPTY_COMMANDS,\n      format: 'empty',\n      parser() {\n         throw typeof error === 'string' ? new TaskConfigurationError(error) : error;\n      },\n   };\n}\n\nexport function straightThroughStringTask(commands: string[], trimmed = false): StringTask<string> {\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text) {\n         return trimmed ? String(text).trim() : text;\n      },\n   };\n}\n\nexport function straightThroughBufferTask(commands: string[]): BufferTask<any> {\n   return {\n      commands,\n      format: 'buffer',\n      parser(buffer) {\n         return buffer;\n      },\n   };\n}\n\nexport function isBufferTask<R>(task: SimpleGitTask<R>): task is BufferTask<R> {\n   return task.format === 'buffer';\n}\n\nexport function isEmptyTask<R>(task: SimpleGitTask<R>): task is EmptyTask {\n   return task.format === 'empty' || !task.commands.length;\n}\n","import { CleanSummary } from '../../../typings';\nimport { cleanSummaryParser } from '../responses/CleanSummary';\nimport { Maybe, StringTask } from '../types';\nimport { asStringArray } from '../utils';\nimport { configurationErrorTask } from './task';\n\nexport const CONFIG_ERROR_INTERACTIVE_MODE = 'Git clean interactive mode is not supported';\nexport const CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter (\"n\" or \"f\") is required';\nexport const CONFIG_ERROR_UNKNOWN_OPTION = 'Git clean unknown option found in: ';\n\n/**\n * All supported option switches available for use in a `git.clean` operation\n */\nexport enum CleanOptions {\n   DRY_RUN = 'n',\n   FORCE = 'f',\n   IGNORED_INCLUDED = 'x',\n   IGNORED_ONLY = 'X',\n   EXCLUDING = 'e',\n   QUIET = 'q',\n   RECURSIVE = 'd',\n}\n\n/**\n * The two modes `git.clean` can run in - one of these must be supplied in order\n * for the command to not throw a `TaskConfigurationError`\n */\nexport type CleanMode = CleanOptions.FORCE | CleanOptions.DRY_RUN;\n\nconst CleanOptionValues: Set<string> = new Set([\n   'i',\n   ...asStringArray(Object.values(CleanOptions as any)),\n]);\n\nexport function cleanWithOptionsTask(mode: CleanMode | string, customArgs: string[]) {\n   const { cleanMode, options, valid } = getCleanOptions(mode);\n\n   if (!cleanMode) {\n      return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);\n   }\n\n   if (!valid.options) {\n      return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));\n   }\n\n   options.push(...customArgs);\n\n   if (options.some(isInteractiveMode)) {\n      return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);\n   }\n\n   return cleanTask(cleanMode, options);\n}\n\nexport function cleanTask(mode: CleanMode, customArgs: string[]): StringTask<CleanSummary> {\n   const commands: string[] = ['clean', `-${mode}`, ...customArgs];\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string): CleanSummary {\n         return cleanSummaryParser(mode === CleanOptions.DRY_RUN, text);\n      },\n   };\n}\n\nexport function isCleanOptionsArray(input: string[]): input is CleanOptions[] {\n   return Array.isArray(input) && input.every((test) => CleanOptionValues.has(test));\n}\n\nfunction getCleanOptions(input: string) {\n   let cleanMode: Maybe<CleanMode>;\n   let options: string[] = [];\n   let valid = { cleanMode: false, options: true };\n\n   input\n      .replace(/[^a-z]i/g, '')\n      .split('')\n      .forEach((char) => {\n         if (isCleanMode(char)) {\n            cleanMode = char;\n            valid.cleanMode = true;\n         } else {\n            valid.options = valid.options && isKnownOption((options[options.length] = `-${char}`));\n         }\n      });\n\n   return {\n      cleanMode,\n      options,\n      valid,\n   };\n}\n\nfunction isCleanMode(cleanMode?: string): cleanMode is CleanMode {\n   return cleanMode === CleanOptions.FORCE || cleanMode === CleanOptions.DRY_RUN;\n}\n\nfunction isKnownOption(option: string): boolean {\n   return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));\n}\n\nfunction isInteractiveMode(option: string): boolean {\n   if (/^-[^\\-]/.test(option)) {\n      return option.indexOf('i') > 0;\n   }\n\n   return option === '--interactive';\n}\n","import { ConfigGetResult, ConfigListSummary, ConfigValues } from '../../../typings';\nimport { last, splitOn } from '../utils';\n\nexport class ConfigList implements ConfigListSummary {\n   public files: string[] = [];\n   public values: { [fileName: string]: ConfigValues } = Object.create(null);\n\n   private _all: ConfigValues | undefined;\n\n   public get all(): ConfigValues {\n      if (!this._all) {\n         this._all = this.files.reduce((all: ConfigValues, file: string) => {\n            return Object.assign(all, this.values[file]);\n         }, {});\n      }\n\n      return this._all;\n   }\n\n   public addFile(file: string): ConfigValues {\n      if (!(file in this.values)) {\n         const latest = last(this.files);\n         this.values[file] = latest ? Object.create(this.values[latest]) : {};\n\n         this.files.push(file);\n      }\n\n      return this.values[file];\n   }\n\n   public addValue(file: string, key: string, value: string) {\n      const values = this.addFile(file);\n\n      if (!values.hasOwnProperty(key)) {\n         values[key] = value;\n      } else if (Array.isArray(values[key])) {\n         (values[key] as string[]).push(value);\n      } else {\n         values[key] = [values[key] as string, value];\n      }\n\n      this._all = undefined;\n   }\n}\n\nexport function configListParser(text: string): ConfigList {\n   const config = new ConfigList();\n\n   for (const item of configParser(text)) {\n      config.addValue(item.file, String(item.key), item.value);\n   }\n\n   return config;\n}\n\nexport function configGetParser(text: string, key: string): ConfigGetResult {\n   let value: string | null = null;\n   const values: string[] = [];\n   const scopes: Map<string, string[]> = new Map();\n\n   for (const item of configParser(text, key)) {\n      if (item.key !== key) {\n         continue;\n      }\n\n      values.push((value = item.value));\n\n      if (!scopes.has(item.file)) {\n         scopes.set(item.file, []);\n      }\n\n      scopes.get(item.file)!.push(value);\n   }\n\n   return {\n      key,\n      paths: Array.from(scopes.keys()),\n      scopes,\n      value,\n      values,\n   };\n}\n\nfunction configFilePath(filePath: string): string {\n   return filePath.replace(/^(file):/, '');\n}\n\nfunction* configParser(text: string, requestedKey: string | null = null) {\n   const lines = text.split('\\0');\n\n   for (let i = 0, max = lines.length - 1; i < max; ) {\n      const file = configFilePath(lines[i++]);\n\n      let value = lines[i++];\n      let key = requestedKey;\n\n      if (value.includes('\\n')) {\n         const line = splitOn(value, '\\n');\n         key = line[0];\n         value = line[1];\n      }\n\n      yield { file, key, value };\n   }\n}\n","import type { ConfigGetResult, ConfigListSummary, SimpleGit } from '../../../typings';\nimport { configGetParser, configListParser } from '../responses/ConfigList';\nimport type { SimpleGitApi } from '../simple-git-api';\nimport type { StringTask } from '../types';\nimport { trailingFunctionArgument } from '../utils';\n\nexport enum GitConfigScope {\n   system = 'system',\n   global = 'global',\n   local = 'local',\n   worktree = 'worktree',\n}\n\nfunction asConfigScope<T extends GitConfigScope | undefined>(\n   scope: GitConfigScope | unknown,\n   fallback: T\n): GitConfigScope | T {\n   if (typeof scope === 'string' && GitConfigScope.hasOwnProperty(scope)) {\n      return scope as GitConfigScope;\n   }\n   return fallback;\n}\n\nfunction addConfigTask(\n   key: string,\n   value: string,\n   append: boolean,\n   scope: GitConfigScope\n): StringTask<string> {\n   const commands: string[] = ['config', `--${scope}`];\n\n   if (append) {\n      commands.push('--add');\n   }\n\n   commands.push(key, value);\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string): string {\n         return text;\n      },\n   };\n}\n\nfunction getConfigTask(key: string, scope?: GitConfigScope): StringTask<ConfigGetResult> {\n   const commands: string[] = ['config', '--null', '--show-origin', '--get-all', key];\n\n   if (scope) {\n      commands.splice(1, 0, `--${scope}`);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text) {\n         return configGetParser(text, key);\n      },\n   };\n}\n\nfunction listConfigTask(scope?: GitConfigScope): StringTask<ConfigListSummary> {\n   const commands = ['config', '--list', '--show-origin', '--null'];\n\n   if (scope) {\n      commands.push(`--${scope}`);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string) {\n         return configListParser(text);\n      },\n   };\n}\n\nexport default function (): Pick<SimpleGit, 'addConfig' | 'getConfig' | 'listConfig'> {\n   return {\n      addConfig(this: SimpleGitApi, key: string, value: string, ...rest: unknown[]) {\n         return this._runTask(\n            addConfigTask(\n               key,\n               value,\n               rest[0] === true,\n               asConfigScope(rest[1], GitConfigScope.local)\n            ),\n            trailingFunctionArgument(arguments)\n         );\n      },\n\n      getConfig(this: SimpleGitApi, key: string, scope?: GitConfigScope) {\n         return this._runTask(\n            getConfigTask(key, asConfigScope(scope, undefined)),\n            trailingFunctionArgument(arguments)\n         );\n      },\n\n      listConfig(this: SimpleGitApi, ...rest: unknown[]) {\n         return this._runTask(\n            listConfigTask(asConfigScope(rest[0], undefined)),\n            trailingFunctionArgument(arguments)\n         );\n      },\n   };\n}\n","import { GrepResult, SimpleGit } from '../../../typings';\nimport { SimpleGitApi } from '../simple-git-api';\nimport {\n   asNumber,\n   forEachLineWithContent,\n   getTrailingOptions,\n   NULL,\n   prefixedArray,\n   trailingFunctionArgument,\n} from '../utils';\n\nimport { configurationErrorTask } from './task';\n\nconst disallowedOptions = ['-h'];\n\nconst Query = Symbol('grepQuery');\n\nexport interface GitGrepQuery extends Iterable<string> {\n   /** Adds one or more terms to be grouped as an \"and\" to any other terms */\n   and(...and: string[]): this;\n\n   /** Adds one or more search terms - git.grep will \"or\" this to other terms */\n   param(...param: string[]): this;\n}\n\nclass GrepQuery implements GitGrepQuery {\n   private [Query]: string[] = [];\n\n   *[Symbol.iterator]() {\n      for (const query of this[Query]) {\n         yield query;\n      }\n   }\n\n   and(...and: string[]) {\n      and.length && this[Query].push('--and', '(', ...prefixedArray(and, '-e'), ')');\n      return this;\n   }\n\n   param(...param: string[]) {\n      this[Query].push(...prefixedArray(param, '-e'));\n      return this;\n   }\n}\n\n/**\n * Creates a new builder for a `git.grep` query with optional params\n */\nexport function grepQueryBuilder(...params: string[]): GitGrepQuery {\n   return new GrepQuery().param(...params);\n}\n\nfunction parseGrep(grep: string): GrepResult {\n   const paths: GrepResult['paths'] = new Set<string>();\n   const results: GrepResult['results'] = {};\n\n   forEachLineWithContent(grep, (input) => {\n      const [path, line, preview] = input.split(NULL);\n      paths.add(path);\n      (results[path] = results[path] || []).push({\n         line: asNumber(line),\n         path,\n         preview,\n      });\n   });\n\n   return {\n      paths,\n      results,\n   };\n}\n\nexport default function (): Pick<SimpleGit, 'grep'> {\n   return {\n      grep(this: SimpleGitApi, searchTerm: string | GitGrepQuery) {\n         const then = trailingFunctionArgument(arguments);\n         const options = getTrailingOptions(arguments);\n\n         for (const option of disallowedOptions) {\n            if (options.includes(option)) {\n               return this._runTask(\n                  configurationErrorTask(`git.grep: use of \"${option}\" is not supported.`),\n                  then\n               );\n            }\n         }\n\n         if (typeof searchTerm === 'string') {\n            searchTerm = grepQueryBuilder().param(searchTerm);\n         }\n\n         const commands = ['grep', '--null', '-n', '--full-name', ...options, ...searchTerm];\n\n         return this._runTask(\n            {\n               commands,\n               format: 'utf-8',\n               parser(stdOut) {\n                  return parseGrep(stdOut);\n               },\n            },\n            then\n         );\n      },\n   };\n}\n","import { straightThroughStringTask } from './task';\nimport { Maybe, OptionFlags, Options } from '../types';\n\nexport enum ResetMode {\n   MIXED = 'mixed',\n   SOFT = 'soft',\n   HARD = 'hard',\n   MERGE = 'merge',\n   KEEP = 'keep',\n}\n\nconst ResetModes = Array.from(Object.values(ResetMode));\n\nexport type ResetOptions = Options &\n   OptionFlags<'-q' | '--quiet' | '--no-quiet' | '--pathspec-from-nul'> &\n   OptionFlags<'--pathspec-from-file', string>;\n\nexport function resetTask(mode: Maybe<ResetMode>, customArgs: string[]) {\n   const commands: string[] = ['reset'];\n   if (isValidResetMode(mode)) {\n      commands.push(`--${mode}`);\n   }\n   commands.push(...customArgs);\n\n   return straightThroughStringTask(commands);\n}\n\nexport function getResetMode(mode: ResetMode | any): Maybe<ResetMode> {\n   if (isValidResetMode(mode)) {\n      return mode;\n   }\n\n   switch (typeof mode) {\n      case 'string':\n      case 'undefined':\n         return ResetMode.SOFT;\n   }\n\n   return;\n}\n\nfunction isValidResetMode(mode: ResetMode | any): mode is ResetMode {\n   return ResetModes.includes(mode);\n}\n","import debug, { Debugger } from 'debug';\nimport {\n   append,\n   filterHasLength,\n   filterString,\n   filterType,\n   NOOP,\n   objectToString,\n   remove,\n} from './utils';\nimport { Maybe } from './types';\n\ndebug.formatters.L = (value: any) => String(filterHasLength(value) ? value.length : '-');\ndebug.formatters.B = (value: Buffer) => {\n   if (Buffer.isBuffer(value)) {\n      return value.toString('utf8');\n   }\n   return objectToString(value);\n};\n\ntype OutputLoggingHandler = (message: string, ...args: any[]) => void;\n\nfunction createLog() {\n   return debug('simple-git');\n}\n\nexport interface OutputLogger extends OutputLoggingHandler {\n   readonly label: string;\n\n   info: OutputLoggingHandler;\n   step(nextStep?: string): OutputLogger;\n   sibling(name: string): OutputLogger;\n}\n\nfunction prefixedLogger(\n   to: Debugger,\n   prefix: string,\n   forward?: OutputLoggingHandler\n): OutputLoggingHandler {\n   if (!prefix || !String(prefix).replace(/\\s*/, '')) {\n      return !forward\n         ? to\n         : (message, ...args) => {\n              to(message, ...args);\n              forward(message, ...args);\n           };\n   }\n\n   return (message, ...args) => {\n      to(`%s ${message}`, prefix, ...args);\n      if (forward) {\n         forward(message, ...args);\n      }\n   };\n}\n\nfunction childLoggerName(\n   name: Maybe<string>,\n   childDebugger: Maybe<Debugger>,\n   { namespace: parentNamespace }: Debugger\n): string {\n   if (typeof name === 'string') {\n      return name;\n   }\n   const childNamespace = (childDebugger && childDebugger.namespace) || '';\n\n   if (childNamespace.startsWith(parentNamespace)) {\n      return childNamespace.substr(parentNamespace.length + 1);\n   }\n\n   return childNamespace || parentNamespace;\n}\n\nexport function createLogger(\n   label: string,\n   verbose?: string | Debugger,\n   initialStep?: string,\n   infoDebugger = createLog()\n): OutputLogger {\n   const labelPrefix = (label && `[${label}]`) || '';\n\n   const spawned: OutputLogger[] = [];\n   const debugDebugger: Maybe<Debugger> =\n      typeof verbose === 'string' ? infoDebugger.extend(verbose) : verbose;\n   const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);\n\n   return step(initialStep);\n\n   function sibling(name: string, initial?: string) {\n      return append(\n         spawned,\n         createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger)\n      );\n   }\n\n   function step(phase?: string) {\n      const stepPrefix = (phase && `[${phase}]`) || '';\n      const debug = (debugDebugger && prefixedLogger(debugDebugger, stepPrefix)) || NOOP;\n      const info = prefixedLogger(infoDebugger, `${labelPrefix} ${stepPrefix}`, debug);\n\n      return Object.assign(debugDebugger ? debug : info, {\n         label,\n         sibling,\n         info,\n         step,\n      });\n   }\n}\n\n/**\n * The `GitLogger` is used by the main `SimpleGit` runner to handle logging\n * any warnings or errors.\n */\nexport class GitLogger {\n   public error: OutputLoggingHandler;\n\n   public warn: OutputLoggingHandler;\n\n   constructor(private _out: Debugger = createLog()) {\n      this.error = prefixedLogger(_out, '[ERROR]');\n      this.warn = prefixedLogger(_out, '[WARN]');\n   }\n\n   silent(silence = false) {\n      if (silence !== this._out.enabled) {\n         return;\n      }\n\n      const { namespace } = this._out;\n      const env = (process.env.DEBUG || '').split(',').filter((s) => !!s);\n      const hasOn = env.includes(namespace);\n      const hasOff = env.includes(`-${namespace}`);\n\n      // enabling the log\n      if (!silence) {\n         if (hasOff) {\n            remove(env, `-${namespace}`);\n         } else {\n            env.push(namespace);\n         }\n      } else {\n         if (hasOn) {\n            remove(env, namespace);\n         } else {\n            env.push(`-${namespace}`);\n         }\n      }\n\n      debug.enable(env.join(','));\n   }\n}\n","import { SimpleGitTask } from '../types';\nimport { GitError } from '../errors/git-error';\nimport { createLogger, OutputLogger } from '../git-logger';\n\ntype AnySimpleGitTask = SimpleGitTask<any>;\n\ntype TaskInProgress = {\n   name: string;\n   logger: OutputLogger;\n   task: AnySimpleGitTask;\n};\n\nexport class TasksPendingQueue {\n   private _queue: Map<AnySimpleGitTask, TaskInProgress> = new Map();\n\n   constructor(private logLabel = 'GitExecutor') {}\n\n   private withProgress(task: AnySimpleGitTask) {\n      return this._queue.get(task);\n   }\n\n   private createProgress(task: AnySimpleGitTask): TaskInProgress {\n      const name = TasksPendingQueue.getName(task.commands[0]);\n      const logger = createLogger(this.logLabel, name);\n\n      return {\n         task,\n         logger,\n         name,\n      };\n   }\n\n   push(task: AnySimpleGitTask): TaskInProgress {\n      const progress = this.createProgress(task);\n      progress.logger('Adding task to the queue, commands = %o', task.commands);\n\n      this._queue.set(task, progress);\n\n      return progress;\n   }\n\n   fatal(err: GitError) {\n      for (const [task, { logger }] of Array.from(this._queue.entries())) {\n         if (task === err.task) {\n            logger.info(`Failed %o`, err);\n            logger(\n               `Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`\n            );\n         } else {\n            logger.info(\n               `A fatal exception occurred in a previous task, the queue has been purged: %o`,\n               err.message\n            );\n         }\n\n         this.complete(task);\n      }\n\n      if (this._queue.size !== 0) {\n         throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);\n      }\n   }\n\n   complete(task: AnySimpleGitTask) {\n      const progress = this.withProgress(task);\n      if (progress) {\n         this._queue.delete(task);\n      }\n   }\n\n   attempt(task: AnySimpleGitTask): TaskInProgress {\n      const progress = this.withProgress(task);\n      if (!progress) {\n         throw new GitError(undefined, 'TasksPendingQueue: attempt called for an unknown task');\n      }\n      progress.logger('Starting task');\n\n      return progress;\n   }\n\n   static getName(name = 'empty') {\n      return `task:${name}:${++TasksPendingQueue.counter}`;\n   }\n\n   private static counter = 0;\n}\n","import { spawn, SpawnOptions } from 'child_process';\nimport { GitError } from '../errors/git-error';\nimport { OutputLogger } from '../git-logger';\nimport { PluginStore } from '../plugins';\nimport { EmptyTask, isBufferTask, isEmptyTask } from '../tasks/task';\nimport {\n   GitExecutorResult,\n   Maybe,\n   outputHandler,\n   RunnableTask,\n   SimpleGitExecutor,\n   SimpleGitTask,\n} from '../types';\nimport { callTaskParser, first, GitOutputStreams, objectToString } from '../utils';\nimport { Scheduler } from './scheduler';\nimport { TasksPendingQueue } from './tasks-pending-queue';\n\nexport class GitExecutorChain implements SimpleGitExecutor {\n   private _chain: Promise<any> = Promise.resolve();\n   private _queue = new TasksPendingQueue();\n   private _cwd: string | undefined;\n\n   public get binary() {\n      return this._executor.binary;\n   }\n\n   public get cwd() {\n      return this._cwd || this._executor.cwd;\n   }\n\n   public set cwd(cwd: string) {\n      this._cwd = cwd;\n   }\n\n   public get env() {\n      return this._executor.env;\n   }\n\n   public get outputHandler() {\n      return this._executor.outputHandler;\n   }\n\n   constructor(\n      private _executor: SimpleGitExecutor,\n      private _scheduler: Scheduler,\n      private _plugins: PluginStore\n   ) {}\n\n   public chain() {\n      return this;\n   }\n\n   public push<R>(task: SimpleGitTask<R>): Promise<R> {\n      this._queue.push(task);\n\n      return (this._chain = this._chain.then(() => this.attemptTask(task)));\n   }\n\n   private async attemptTask<R>(task: SimpleGitTask<R>): Promise<void | R> {\n      const onScheduleComplete = await this._scheduler.next();\n      const onQueueComplete = () => this._queue.complete(task);\n\n      try {\n         const { logger } = this._queue.attempt(task);\n         return (await (isEmptyTask(task)\n            ? this.attemptEmptyTask(task, logger)\n            : this.attemptRemoteTask(task, logger))) as R;\n      } catch (e) {\n         throw this.onFatalException(task, e as Error);\n      } finally {\n         onQueueComplete();\n         onScheduleComplete();\n      }\n   }\n\n   private onFatalException<R>(task: SimpleGitTask<R>, e: Error) {\n      const gitError =\n         e instanceof GitError ? Object.assign(e, { task }) : new GitError(task, e && String(e));\n\n      this._chain = Promise.resolve();\n      this._queue.fatal(gitError);\n\n      return gitError;\n   }\n\n   private async attemptRemoteTask<R>(task: RunnableTask<R>, logger: OutputLogger) {\n      const args = this._plugins.exec(\n         'spawn.args',\n         [...task.commands],\n         pluginContext(task, task.commands)\n      );\n\n      const raw = await this.gitResponse(\n         task,\n         this.binary,\n         args,\n         this.outputHandler,\n         logger.step('SPAWN')\n      );\n      const outputStreams = await this.handleTaskData(task, args, raw, logger.step('HANDLE'));\n\n      logger(`passing response to task's parser as a %s`, task.format);\n\n      if (isBufferTask(task)) {\n         return callTaskParser(task.parser, outputStreams);\n      }\n\n      return callTaskParser(task.parser, outputStreams.asStrings());\n   }\n\n   private async attemptEmptyTask(task: EmptyTask, logger: OutputLogger) {\n      logger(`empty task bypassing child process to call to task's parser`);\n      return task.parser(this);\n   }\n\n   private handleTaskData<R>(\n      task: SimpleGitTask<R>,\n      args: string[],\n      result: GitExecutorResult,\n      logger: OutputLogger\n   ): Promise<GitOutputStreams> {\n      const { exitCode, rejection, stdOut, stdErr } = result;\n\n      return new Promise((done, fail) => {\n         logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);\n\n         const { error } = this._plugins.exec(\n            'task.error',\n            { error: rejection },\n            {\n               ...pluginContext(task, args),\n               ...result,\n            }\n         );\n\n         if (error && task.onError) {\n            logger.info(`exitCode=%s handling with custom error handler`);\n\n            return task.onError(\n               result,\n               error,\n               (newStdOut) => {\n                  logger.info(`custom error handler treated as success`);\n                  logger(`custom error returned a %s`, objectToString(newStdOut));\n\n                  done(\n                     new GitOutputStreams(\n                        Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut,\n                        Buffer.concat(stdErr)\n                     )\n                  );\n               },\n               fail\n            );\n         }\n\n         if (error) {\n            logger.info(\n               `handling as error: exitCode=%s stdErr=%s rejection=%o`,\n               exitCode,\n               stdErr.length,\n               rejection\n            );\n            return fail(error);\n         }\n\n         logger.info(`retrieving task output complete`);\n         done(new GitOutputStreams(Buffer.concat(stdOut), Buffer.concat(stdErr)));\n      });\n   }\n\n   private async gitResponse<R>(\n      task: SimpleGitTask<R>,\n      command: string,\n      args: string[],\n      outputHandler: Maybe<outputHandler>,\n      logger: OutputLogger\n   ): Promise<GitExecutorResult> {\n      const outputLogger = logger.sibling('output');\n      const spawnOptions: SpawnOptions = this._plugins.exec(\n         'spawn.options',\n         {\n            cwd: this.cwd,\n            env: this.env,\n            windowsHide: true,\n         },\n         pluginContext(task, task.commands)\n      );\n\n      return new Promise((done) => {\n         const stdOut: Buffer[] = [];\n         const stdErr: Buffer[] = [];\n\n         logger.info(`%s %o`, command, args);\n         logger('%O', spawnOptions);\n\n         let rejection = this._beforeSpawn(task, args);\n         if (rejection) {\n            return done({\n               stdOut,\n               stdErr,\n               exitCode: 9901,\n               rejection,\n            });\n         }\n\n         this._plugins.exec('spawn.before', undefined, {\n            ...pluginContext(task, args),\n            kill(reason) {\n               rejection = reason || rejection;\n            },\n         });\n\n         const spawned = spawn(command, args, spawnOptions);\n\n         spawned.stdout!.on(\n            'data',\n            onDataReceived(stdOut, 'stdOut', logger, outputLogger.step('stdOut'))\n         );\n         spawned.stderr!.on(\n            'data',\n            onDataReceived(stdErr, 'stdErr', logger, outputLogger.step('stdErr'))\n         );\n\n         spawned.on('error', onErrorReceived(stdErr, logger));\n\n         if (outputHandler) {\n            logger(`Passing child process stdOut/stdErr to custom outputHandler`);\n            outputHandler(command, spawned.stdout!, spawned.stderr!, [...args]);\n         }\n\n         this._plugins.exec('spawn.after', undefined, {\n            ...pluginContext(task, args),\n            spawned,\n            close(exitCode: number, reason?: Error) {\n               done({\n                  stdOut,\n                  stdErr,\n                  exitCode,\n                  rejection: rejection || reason,\n               });\n            },\n            kill(reason: Error) {\n               if (spawned.killed) {\n                  return;\n               }\n\n               rejection = reason;\n               spawned.kill('SIGINT');\n            },\n         });\n      });\n   }\n\n   private _beforeSpawn<R>(task: SimpleGitTask<R>, args: string[]) {\n      let rejection: Maybe<Error>;\n      this._plugins.exec('spawn.before', undefined, {\n         ...pluginContext(task, args),\n         kill(reason) {\n            rejection = reason || rejection;\n         },\n      });\n\n      return rejection;\n   }\n}\n\nfunction pluginContext<R>(task: SimpleGitTask<R>, commands: string[]) {\n   return {\n      method: first(task.commands) || '',\n      commands,\n   };\n}\n\nfunction onErrorReceived(target: Buffer[], logger: OutputLogger) {\n   return (err: Error) => {\n      logger(`[ERROR] child process exception %o`, err);\n      target.push(Buffer.from(String(err.stack), 'ascii'));\n   };\n}\n\nfunction onDataReceived(\n   target: Buffer[],\n   name: string,\n   logger: OutputLogger,\n   output: OutputLogger\n) {\n   return (buffer: Buffer) => {\n      logger(`%s received %L bytes`, name, buffer);\n      output(`%B`, buffer);\n      target.push(buffer);\n   };\n}\n","import type { PluginStore } from '../plugins';\nimport type { GitExecutorEnv, outputHandler, SimpleGitExecutor, SimpleGitTask } from '../types';\n\nimport { GitExecutorChain } from './git-executor-chain';\nimport { Scheduler } from './scheduler';\n\nexport class GitExecutor implements SimpleGitExecutor {\n   private _chain = new GitExecutorChain(this, this._scheduler, this._plugins);\n\n   public env: GitExecutorEnv;\n   public outputHandler?: outputHandler;\n\n   constructor(\n      public binary: string = 'git',\n      public cwd: string,\n      private _scheduler: Scheduler,\n      private _plugins: PluginStore\n   ) {}\n\n   chain(): SimpleGitExecutor {\n      return new GitExecutorChain(this, this._scheduler, this._plugins);\n   }\n\n   push<R>(task: SimpleGitTask<R>): Promise<R> {\n      return this._chain.push(task);\n   }\n}\n","import { GitError } from './errors/git-error';\nimport { GitResponseError } from './errors/git-response-error';\nimport { SimpleGitTask, SimpleGitTaskCallback } from './types';\nimport { NOOP } from './utils';\n\nexport function taskCallback<R>(\n   task: SimpleGitTask<R>,\n   response: Promise<R>,\n   callback: SimpleGitTaskCallback<R> = NOOP\n) {\n   const onSuccess = (data: R) => {\n      callback(null, data);\n   };\n\n   const onError = (err: GitError | GitResponseError) => {\n      if (err?.task === task) {\n         callback(\n            err instanceof GitResponseError ? addDeprecationNoticeToError(err) : err,\n            undefined as any\n         );\n      }\n   };\n\n   response.then(onSuccess, onError);\n}\n\nfunction addDeprecationNoticeToError(err: GitResponseError) {\n   let log = (name: string) => {\n      console.warn(\n         `simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`\n      );\n      log = NOOP;\n   };\n\n   return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));\n\n   function descriptorReducer(all: PropertyDescriptorMap, name: string): typeof all {\n      if (name in err) {\n         return all;\n      }\n\n      all[name] = {\n         enumerable: false,\n         configurable: false,\n         get() {\n            log(name);\n            return err.git[name];\n         },\n      };\n\n      return all;\n   }\n}\n","import { folderExists } from '../utils';\nimport { SimpleGitExecutor } from '../types';\nimport { adhocExecTask } from './task';\n\nexport function changeWorkingDirectoryTask(directory: string, root?: SimpleGitExecutor) {\n   return adhocExecTask((instance: SimpleGitExecutor) => {\n      if (!folderExists(directory)) {\n         throw new Error(`Git.cwd: cannot change to non-directory \"${directory}\"`);\n      }\n\n      return ((root || instance).cwd = directory);\n   });\n}\n","import type { SimpleGit } from '../../../typings';\nimport type { SimpleGitApi } from '../simple-git-api';\nimport { getTrailingOptions, remove, trailingFunctionArgument } from '../utils';\nimport { straightThroughStringTask } from './task';\n\nfunction checkoutTask(args: string[]) {\n   const commands = ['checkout', ...args];\n   if (commands[1] === '-b' && commands.includes('-B')) {\n      commands[1] = remove(commands, '-B');\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport default function (): Pick<SimpleGit, 'checkout' | 'checkoutBranch' | 'checkoutLocalBranch'> {\n   return {\n      checkout(this: SimpleGitApi) {\n         return this._runTask(\n            checkoutTask(getTrailingOptions(arguments, 1)),\n            trailingFunctionArgument(arguments)\n         );\n      },\n\n      checkoutBranch(this: SimpleGitApi, branchName, startPoint) {\n         return this._runTask(\n            checkoutTask(['-b', branchName, startPoint, ...getTrailingOptions(arguments)]),\n            trailingFunctionArgument(arguments)\n         );\n      },\n\n      checkoutLocalBranch(this: SimpleGitApi, branchName) {\n         return this._runTask(\n            checkoutTask(['-b', branchName, ...getTrailingOptions(arguments)]),\n            trailingFunctionArgument(arguments)\n         );\n      },\n   };\n}\n","import { CommitResult } from '../../../typings';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<CommitResult>[] = [\n   new LineParser(/^\\[([^\\s]+)( \\([^)]+\\))? ([^\\]]+)/, (result, [branch, root, commit]) => {\n      result.branch = branch;\n      result.commit = commit;\n      result.root = !!root;\n   }),\n   new LineParser(/\\s*Author:\\s(.+)/i, (result, [author]) => {\n      const parts = author.split('<');\n      const email = parts.pop();\n\n      if (!email || !email.includes('@')) {\n         return;\n      }\n\n      result.author = {\n         email: email.substr(0, email.length - 1),\n         name: parts.join('<').trim(),\n      };\n   }),\n   new LineParser(\n      /(\\d+)[^,]*(?:,\\s*(\\d+)[^,]*)(?:,\\s*(\\d+))/g,\n      (result, [changes, insertions, deletions]) => {\n         result.summary.changes = parseInt(changes, 10) || 0;\n         result.summary.insertions = parseInt(insertions, 10) || 0;\n         result.summary.deletions = parseInt(deletions, 10) || 0;\n      }\n   ),\n   new LineParser(\n      /^(\\d+)[^,]*(?:,\\s*(\\d+)[^(]+\\(([+-]))?/,\n      (result, [changes, lines, direction]) => {\n         result.summary.changes = parseInt(changes, 10) || 0;\n         const count = parseInt(lines, 10) || 0;\n         if (direction === '-') {\n            result.summary.deletions = count;\n         } else if (direction === '+') {\n            result.summary.insertions = count;\n         }\n      }\n   ),\n];\n\nexport function parseCommitResult(stdOut: string): CommitResult {\n   const result: CommitResult = {\n      author: null,\n      branch: '',\n      commit: '',\n      root: false,\n      summary: {\n         changes: 0,\n         insertions: 0,\n         deletions: 0,\n      },\n   };\n   return parseStringResponse(result, parsers, stdOut);\n}\n","import type { CommitResult, SimpleGit } from '../../../typings';\nimport type { SimpleGitApi } from '../simple-git-api';\nimport type { StringTask } from '../types';\nimport { parseCommitResult } from '../parsers/parse-commit';\nimport {\n   asArray,\n   filterArray,\n   filterStringOrStringArray,\n   filterType,\n   getTrailingOptions,\n   prefixedArray,\n   trailingFunctionArgument,\n} from '../utils';\nimport { configurationErrorTask } from './task';\n\nexport function commitTask(\n   message: string[],\n   files: string[],\n   customArgs: string[]\n): StringTask<CommitResult> {\n   const commands: string[] = [\n      '-c',\n      'core.abbrev=40',\n      'commit',\n      ...prefixedArray(message, '-m'),\n      ...files,\n      ...customArgs,\n   ];\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser: parseCommitResult,\n   };\n}\n\nexport default function (): Pick<SimpleGit, 'commit'> {\n   return {\n      commit(this: SimpleGitApi, message: string | string[], ...rest: unknown[]) {\n         const next = trailingFunctionArgument(arguments);\n         const task =\n            rejectDeprecatedSignatures(message) ||\n            commitTask(\n               asArray(message),\n               asArray(filterType(rest[0], filterStringOrStringArray, [])),\n               [...filterType(rest[1], filterArray, []), ...getTrailingOptions(arguments, 0, true)]\n            );\n\n         return this._runTask(task, next);\n      },\n   };\n\n   function rejectDeprecatedSignatures(message?: unknown) {\n      return (\n         !filterStringOrStringArray(message) &&\n         configurationErrorTask(\n            `git.commit: requires the commit message to be supplied as a string/string[]`\n         )\n      );\n   }\n}\n","import { Response, SimpleGit } from '../../../typings';\nimport { SimpleGitApi } from '../simple-git-api';\nimport { trailingFunctionArgument } from '../utils';\nimport { straightThroughStringTask } from './task';\n\nexport default function (): Pick<SimpleGit, 'firstCommit'> {\n   return {\n      firstCommit(this: SimpleGitApi): Response<string> {\n         return this._runTask(\n            straightThroughStringTask(['rev-list', '--max-parents=0', 'HEAD'], true),\n            trailingFunctionArgument(arguments)\n         );\n      },\n   };\n}\n","import { straightThroughStringTask } from './task';\nimport { StringTask } from '../types';\n\n/**\n * Task used by `git.hashObject`\n */\nexport function hashObjectTask(filePath: string, write: boolean): StringTask<string> {\n   const commands = ['hash-object', filePath];\n   if (write) {\n      commands.push('-w');\n   }\n\n   return straightThroughStringTask(commands, true);\n}\n","import { InitResult } from '../../../typings';\n\nexport class InitSummary implements InitResult {\n   constructor(\n      public readonly bare: boolean,\n      public readonly path: string,\n      public readonly existing: boolean,\n      public readonly gitDir: string\n   ) {}\n}\n\nconst initResponseRegex = /^Init.+ repository in (.+)$/;\nconst reInitResponseRegex = /^Rein.+ in (.+)$/;\n\nexport function parseInit(bare: boolean, path: string, text: string) {\n   const response = String(text).trim();\n   let result;\n\n   if ((result = initResponseRegex.exec(response))) {\n      return new InitSummary(bare, path, false, result[1]);\n   }\n\n   if ((result = reInitResponseRegex.exec(response))) {\n      return new InitSummary(bare, path, true, result[1]);\n   }\n\n   let gitDir = '';\n   const tokens = response.split(' ');\n   while (tokens.length) {\n      const token = tokens.shift();\n      if (token === 'in') {\n         gitDir = tokens.join(' ');\n         break;\n      }\n   }\n\n   return new InitSummary(bare, path, /^re/i.test(response), gitDir);\n}\n","import { InitResult } from '../../../typings';\nimport { parseInit } from '../responses/InitSummary';\nimport { StringTask } from '../types';\n\nconst bareCommand = '--bare';\n\nfunction hasBareCommand(command: string[]) {\n   return command.includes(bareCommand);\n}\n\nexport function initTask(bare = false, path: string, customArgs: string[]): StringTask<InitResult> {\n   const commands = ['init', ...customArgs];\n   if (bare && !hasBareCommand(commands)) {\n      commands.splice(1, 0, bareCommand);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string): InitResult {\n         return parseInit(commands.includes('--bare'), path, text);\n      },\n   };\n}\n","export enum LogFormat {\n   NONE = '',\n   STAT = '--stat',\n   NUM_STAT = '--numstat',\n   NAME_ONLY = '--name-only',\n   NAME_STATUS = '--name-status',\n}\n\nconst logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;\n\nexport function logFormatFromCommand(customArgs: string[]) {\n   for (let i = 0; i < customArgs.length; i++) {\n      const format = logFormatRegex.exec(customArgs[i]);\n      if (format) {\n         return `--${format[1]}` as LogFormat;\n      }\n   }\n\n   return LogFormat.NONE;\n}\n\nexport function isLogFormat(customArg: string | unknown) {\n   return logFormatRegex.test(customArg as string);\n}\n","import { DiffResult, DiffResultBinaryFile, DiffResultTextFile } from '../../../typings';\n\n/***\n * The DiffSummary is returned as a response to getting `git().status()`\n */\nexport class DiffSummary implements DiffResult {\n   changed = 0;\n   deletions = 0;\n   insertions = 0;\n\n   files: Array<DiffResultTextFile | DiffResultBinaryFile> = [];\n}\n","import { DiffResult } from '../../../typings';\nimport { LogFormat } from '../args/log-format';\nimport { DiffSummary } from '../responses/DiffSummary';\nimport { asNumber, LineParser, parseStringResponse } from '../utils';\n\nconst statParser = [\n   new LineParser<DiffResult>(\n      /(.+)\\s+\\|\\s+(\\d+)(\\s+[+\\-]+)?$/,\n      (result, [file, changes, alterations = '']) => {\n         result.files.push({\n            file: file.trim(),\n            changes: asNumber(changes),\n            insertions: alterations.replace(/[^+]/g, '').length,\n            deletions: alterations.replace(/[^-]/g, '').length,\n            binary: false,\n         });\n      }\n   ),\n   new LineParser<DiffResult>(\n      /(.+) \\|\\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/,\n      (result, [file, before, after]) => {\n         result.files.push({\n            file: file.trim(),\n            before: asNumber(before),\n            after: asNumber(after),\n            binary: true,\n         });\n      }\n   ),\n   new LineParser<DiffResult>(\n      /(\\d+) files? changed\\s*((?:, \\d+ [^,]+){0,2})/,\n      (result, [changed, summary]) => {\n         const inserted = /(\\d+) i/.exec(summary);\n         const deleted = /(\\d+) d/.exec(summary);\n\n         result.changed = asNumber(changed);\n         result.insertions = asNumber(inserted?.[1]);\n         result.deletions = asNumber(deleted?.[1]);\n      }\n   ),\n];\n\nconst numStatParser = [\n   new LineParser<DiffResult>(\n      /(\\d+)\\t(\\d+)\\t(.+)$/,\n      (result, [changesInsert, changesDelete, file]) => {\n         const insertions = asNumber(changesInsert);\n         const deletions = asNumber(changesDelete);\n\n         result.changed++;\n         result.insertions += insertions;\n         result.deletions += deletions;\n\n         result.files.push({\n            file,\n            changes: insertions + deletions,\n            insertions,\n            deletions,\n            binary: false,\n         });\n      }\n   ),\n   new LineParser<DiffResult>(/-\\t-\\t(.+)$/, (result, [file]) => {\n      result.changed++;\n\n      result.files.push({\n         file,\n         after: 0,\n         before: 0,\n         binary: true,\n      });\n   }),\n];\n\nconst nameOnlyParser = [\n   new LineParser<DiffResult>(/(.+)$/, (result, [file]) => {\n      result.changed++;\n      result.files.push({\n         file,\n         changes: 0,\n         insertions: 0,\n         deletions: 0,\n         binary: false,\n      });\n   }),\n];\n\nconst nameStatusParser = [\n   new LineParser<DiffResult>(/([ACDMRTUXB])\\s*(.+)$/, (result, [_status, file]) => {\n      result.changed++;\n      result.files.push({\n         file,\n         changes: 0,\n         insertions: 0,\n         deletions: 0,\n         binary: false,\n      });\n   }),\n];\n\nconst diffSummaryParsers: Record<LogFormat, LineParser<DiffResult>[]> = {\n   [LogFormat.NONE]: statParser,\n   [LogFormat.STAT]: statParser,\n   [LogFormat.NUM_STAT]: numStatParser,\n   [LogFormat.NAME_STATUS]: nameStatusParser,\n   [LogFormat.NAME_ONLY]: nameOnlyParser,\n};\n\nexport function getDiffParser(format = LogFormat.NONE) {\n   const parser = diffSummaryParsers[format];\n\n   return (stdOut: string) => parseStringResponse(new DiffSummary(), parser, stdOut, false);\n}\n","import { ListLogLine, LogResult } from '../../../typings';\nimport { toLinesWithContent } from '../utils';\nimport { getDiffParser } from './parse-diff-summary';\nimport { LogFormat } from '../args/log-format';\n\nexport const START_BOUNDARY = ' ';\n\nexport const COMMIT_BOUNDARY = ' ';\n\nexport const SPLITTER = '  ';\n\nconst defaultFieldNames = ['hash', 'date', 'message', 'refs', 'author_name', 'author_email'];\n\nfunction lineBuilder(tokens: string[], fields: string[]): any {\n   return fields.reduce(\n      (line, field, index) => {\n         line[field] = tokens[index] || '';\n         return line;\n      },\n      Object.create({ diff: null }) as any\n   );\n}\n\nexport function createListLogSummaryParser<T = any>(\n   splitter = SPLITTER,\n   fields = defaultFieldNames,\n   logFormat = LogFormat.NONE\n) {\n   const parseDiffResult = getDiffParser(logFormat);\n\n   return function (stdOut: string): LogResult<T> {\n      const all: ReadonlyArray<T & ListLogLine> = toLinesWithContent(\n         stdOut,\n         true,\n         START_BOUNDARY\n      ).map(function (item) {\n         const lineDetail = item.trim().split(COMMIT_BOUNDARY);\n         const listLogLine: T & ListLogLine = lineBuilder(\n            lineDetail[0].trim().split(splitter),\n            fields\n         );\n\n         if (lineDetail.length > 1 && !!lineDetail[1].trim()) {\n            listLogLine.diff = parseDiffResult(lineDetail[1]);\n         }\n\n         return listLogLine;\n      });\n\n      return {\n         all,\n         latest: (all.length && all[0]) || null,\n         total: all.length,\n      };\n   };\n}\n","import { StringTask } from '../types';\nimport { DiffResult } from '../../../typings';\nimport { isLogFormat, LogFormat, logFormatFromCommand } from '../args/log-format';\nimport { getDiffParser } from '../parsers/parse-diff-summary';\nimport { configurationErrorTask, EmptyTask } from './task';\n\nexport function diffSummaryTask(customArgs: string[]): StringTask<DiffResult> | EmptyTask {\n   let logFormat = logFormatFromCommand(customArgs);\n\n   const commands = ['diff'];\n\n   if (logFormat === LogFormat.NONE) {\n      logFormat = LogFormat.STAT;\n      commands.push('--stat=4096');\n   }\n\n   commands.push(...customArgs);\n\n   return (\n      validateLogFormatConfig(commands) || {\n         commands,\n         format: 'utf-8',\n         parser: getDiffParser(logFormat),\n      }\n   );\n}\n\nexport function validateLogFormatConfig(customArgs: unknown[]): EmptyTask | void {\n   const flags = customArgs.filter(isLogFormat);\n\n   if (flags.length > 1) {\n      return configurationErrorTask(\n         `Summary flags are mutually exclusive - pick one of ${flags.join(',')}`\n      );\n   }\n\n   if (flags.length && customArgs.includes('-z')) {\n      return configurationErrorTask(\n         `Summary flag ${flags} parsing is not compatible with null termination option '-z'`\n      );\n   }\n}\n","import type { Options, StringTask } from '../types';\nimport type { LogResult, SimpleGit } from '../../../typings';\nimport { logFormatFromCommand } from '../args/log-format';\nimport { pathspec } from '../args/pathspec';\nimport {\n   COMMIT_BOUNDARY,\n   createListLogSummaryParser,\n   SPLITTER,\n   START_BOUNDARY,\n} from '../parsers/parse-list-log-summary';\nimport {\n   appendTaskOptions,\n   filterArray,\n   filterPrimitives,\n   filterString,\n   filterType,\n   trailingFunctionArgument,\n   trailingOptionsArgument,\n} from '../utils';\nimport { SimpleGitApi } from '../simple-git-api';\nimport { configurationErrorTask } from './task';\nimport { validateLogFormatConfig } from './diff';\n\nenum excludeOptions {\n   '--pretty',\n   'max-count',\n   'maxCount',\n   'n',\n   'file',\n   'format',\n   'from',\n   'to',\n   'splitter',\n   'symmetric',\n   'mailMap',\n   'multiLine',\n   'strictDate',\n}\n\nexport interface DefaultLogFields {\n   hash: string;\n   date: string;\n   message: string;\n   refs: string;\n   body: string;\n   author_name: string;\n   author_email: string;\n}\n\nexport type LogOptions<T = DefaultLogFields> = {\n   file?: string;\n   format?: T;\n   from?: string;\n   mailMap?: boolean;\n   maxCount?: number;\n   multiLine?: boolean;\n   splitter?: string;\n   strictDate?: boolean;\n   symmetric?: boolean;\n   to?: string;\n};\n\ninterface ParsedLogOptions {\n   fields: string[];\n   splitter: string;\n   commands: string[];\n}\n\nfunction prettyFormat(\n   format: Record<string, string | unknown>,\n   splitter: string\n): [string[], string] {\n   const fields: string[] = [];\n   const formatStr: string[] = [];\n\n   Object.keys(format).forEach((field) => {\n      fields.push(field);\n      formatStr.push(String(format[field]));\n   });\n\n   return [fields, formatStr.join(splitter)];\n}\n\nfunction userOptions<T extends Options>(input: T): Options {\n   return Object.keys(input).reduce((out, key) => {\n      if (!(key in excludeOptions)) {\n         out[key] = input[key];\n      }\n      return out;\n   }, {} as Options);\n}\n\nexport function parseLogOptions<T extends Options>(\n   opt: Options | LogOptions<T> = {},\n   customArgs: string[] = []\n): ParsedLogOptions {\n   const splitter = filterType(opt.splitter, filterString, SPLITTER);\n   const format =\n      !filterPrimitives(opt.format) && opt.format\n         ? opt.format\n         : {\n              hash: '%H',\n              date: opt.strictDate === false ? '%ai' : '%aI',\n              message: '%s',\n              refs: '%D',\n              body: opt.multiLine ? '%B' : '%b',\n              author_name: opt.mailMap !== false ? '%aN' : '%an',\n              author_email: opt.mailMap !== false ? '%aE' : '%ae',\n           };\n\n   const [fields, formatStr] = prettyFormat(format, splitter);\n\n   const suffix: string[] = [];\n   const command: string[] = [\n      `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,\n      ...customArgs,\n   ];\n\n   const maxCount: number | undefined = (opt as any).n || (opt as any)['max-count'] || opt.maxCount;\n   if (maxCount) {\n      command.push(`--max-count=${maxCount}`);\n   }\n\n   if (opt.from || opt.to) {\n      const rangeOperator = opt.symmetric !== false ? '...' : '..';\n      suffix.push(`${opt.from || ''}${rangeOperator}${opt.to || ''}`);\n   }\n\n   if (filterString(opt.file)) {\n      command.push('--follow', pathspec(opt.file));\n   }\n\n   appendTaskOptions(userOptions(opt as Options), command);\n\n   return {\n      fields,\n      splitter,\n      commands: [...command, ...suffix],\n   };\n}\n\nexport function logTask<T>(\n   splitter: string,\n   fields: string[],\n   customArgs: string[]\n): StringTask<LogResult<T>> {\n   const parser = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));\n\n   return {\n      commands: ['log', ...customArgs],\n      format: 'utf-8',\n      parser,\n   };\n}\n\nexport default function (): Pick<SimpleGit, 'log'> {\n   return {\n      log<T extends Options>(this: SimpleGitApi, ...rest: unknown[]) {\n         const next = trailingFunctionArgument(arguments);\n         const options = parseLogOptions<T>(\n            trailingOptionsArgument(arguments),\n            filterType(arguments[0], filterArray)\n         );\n         const task =\n            rejectDeprecatedSignatures(...rest) ||\n            validateLogFormatConfig(options.commands) ||\n            createLogTask(options);\n\n         return this._runTask(task, next);\n      },\n   };\n\n   function createLogTask(options: ParsedLogOptions) {\n      return logTask(options.splitter, options.fields, options.commands);\n   }\n\n   function rejectDeprecatedSignatures(from?: unknown, to?: unknown) {\n      return (\n         filterString(from) &&\n         filterString(to) &&\n         configurationErrorTask(\n            `git.log(string, string) should be replaced with git.log({ from: string, to: string })`\n         )\n      );\n   }\n}\n","import {\n   MergeConflict,\n   MergeConflictDeletion,\n   MergeDetail,\n   MergeResultStatus,\n} from '../../../typings';\n\nexport class MergeSummaryConflict implements MergeConflict {\n   constructor(\n      public readonly reason: string,\n      public readonly file: string | null = null,\n      public readonly meta?: MergeConflictDeletion\n   ) {}\n\n   toString() {\n      return `${this.file}:${this.reason}`;\n   }\n}\n\nexport class MergeSummaryDetail implements MergeDetail {\n   public conflicts: MergeConflict[] = [];\n   public merges: string[] = [];\n   public result: MergeResultStatus = 'success';\n\n   get failed() {\n      return this.conflicts.length > 0;\n   }\n\n   get reason() {\n      return this.result;\n   }\n\n   toString() {\n      if (this.conflicts.length) {\n         return `CONFLICTS: ${this.conflicts.join(', ')}`;\n      }\n\n      return 'OK';\n   }\n}\n","import {\n   PullDetailFileChanges,\n   PullDetailSummary,\n   PullFailedResult,\n   PullResult,\n} from '../../../typings';\n\nexport class PullSummary implements PullResult {\n   public remoteMessages = {\n      all: [],\n   };\n   public created = [];\n   public deleted: string[] = [];\n   public files: string[] = [];\n   public deletions: PullDetailFileChanges = {};\n   public insertions: PullDetailFileChanges = {};\n   public summary: PullDetailSummary = {\n      changes: 0,\n      deletions: 0,\n      insertions: 0,\n   };\n}\n\nexport class PullFailedSummary implements PullFailedResult {\n   remote = '';\n   hash = {\n      local: '',\n      remote: '',\n   };\n   branch = {\n      local: '',\n      remote: '',\n   };\n   message = '';\n\n   toString() {\n      return this.message;\n   }\n}\n","import {\n   RemoteMessageResult,\n   RemoteMessages,\n   RemoteMessagesObjectEnumeration,\n} from '../../../typings';\nimport { asNumber, RemoteLineParser } from '../utils';\n\nfunction objectEnumerationResult<T extends RemoteMessages = RemoteMessages>(\n   remoteMessages: T\n): RemoteMessagesObjectEnumeration {\n   return (remoteMessages.objects = remoteMessages.objects || {\n      compressing: 0,\n      counting: 0,\n      enumerating: 0,\n      packReused: 0,\n      reused: { count: 0, delta: 0 },\n      total: { count: 0, delta: 0 },\n   });\n}\n\nfunction asObjectCount(source: string) {\n   const count = /^\\s*(\\d+)/.exec(source);\n   const delta = /delta (\\d+)/i.exec(source);\n\n   return {\n      count: asNumber((count && count[1]) || '0'),\n      delta: asNumber((delta && delta[1]) || '0'),\n   };\n}\n\nexport const remoteMessagesObjectParsers: RemoteLineParser<RemoteMessageResult<RemoteMessages>>[] =\n   [\n      new RemoteLineParser(\n         /^remote:\\s*(enumerating|counting|compressing) objects: (\\d+),/i,\n         (result, [action, count]) => {\n            const key = action.toLowerCase();\n            const enumeration = objectEnumerationResult(result.remoteMessages);\n\n            Object.assign(enumeration, { [key]: asNumber(count) });\n         }\n      ),\n      new RemoteLineParser(\n         /^remote:\\s*(enumerating|counting|compressing) objects: \\d+% \\(\\d+\\/(\\d+)\\),/i,\n         (result, [action, count]) => {\n            const key = action.toLowerCase();\n            const enumeration = objectEnumerationResult(result.remoteMessages);\n\n            Object.assign(enumeration, { [key]: asNumber(count) });\n         }\n      ),\n      new RemoteLineParser(\n         /total ([^,]+), reused ([^,]+), pack-reused (\\d+)/i,\n         (result, [total, reused, packReused]) => {\n            const objects = objectEnumerationResult(result.remoteMessages);\n            objects.total = asObjectCount(total);\n            objects.reused = asObjectCount(reused);\n            objects.packReused = asNumber(packReused);\n         }\n      ),\n   ];\n","import { PushResultRemoteMessages, RemoteMessageResult, RemoteMessages } from '../../../typings';\nimport { asNumber, parseStringResponse, RemoteLineParser } from '../utils';\nimport { remoteMessagesObjectParsers } from './parse-remote-objects';\n\nconst parsers: RemoteLineParser<RemoteMessageResult<PushResultRemoteMessages | RemoteMessages>>[] =\n   [\n      new RemoteLineParser(/^remote:\\s*(.+)$/, (result, [text]) => {\n         result.remoteMessages.all.push(text.trim());\n         return false;\n      }),\n      ...remoteMessagesObjectParsers,\n      new RemoteLineParser(\n         [/create a (?:pull|merge) request/i, /\\s(https?:\\/\\/\\S+)$/],\n         (result, [pullRequestUrl]) => {\n            (result.remoteMessages as PushResultRemoteMessages).pullRequestUrl = pullRequestUrl;\n         }\n      ),\n      new RemoteLineParser(\n         [/found (\\d+) vulnerabilities.+\\(([^)]+)\\)/i, /\\s(https?:\\/\\/\\S+)$/],\n         (result, [count, summary, url]) => {\n            (result.remoteMessages as PushResultRemoteMessages).vulnerabilities = {\n               count: asNumber(count),\n               summary,\n               url,\n            };\n         }\n      ),\n   ];\n\nexport function parseRemoteMessages<T extends RemoteMessages = RemoteMessages>(\n   _stdOut: string,\n   stdErr: string\n): RemoteMessageResult {\n   return parseStringResponse({ remoteMessages: new RemoteMessageSummary() as T }, parsers, stdErr);\n}\n\nexport class RemoteMessageSummary implements RemoteMessages {\n   public readonly all: string[] = [];\n}\n","import { PullDetail, PullFailedResult, PullResult, RemoteMessages } from '../../../typings';\nimport { PullFailedSummary, PullSummary } from '../responses/PullSummary';\nimport { TaskParser } from '../types';\nimport { append, LineParser, parseStringResponse } from '../utils';\nimport { parseRemoteMessages } from './parse-remote-messages';\n\nconst FILE_UPDATE_REGEX = /^\\s*(.+?)\\s+\\|\\s+\\d+\\s*(\\+*)(-*)/;\nconst SUMMARY_REGEX = /(\\d+)\\D+((\\d+)\\D+\\(\\+\\))?(\\D+(\\d+)\\D+\\(-\\))?/;\nconst ACTION_REGEX = /^(create|delete) mode \\d+ (.+)/;\n\nconst parsers: LineParser<PullResult>[] = [\n   new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {\n      result.files.push(file);\n\n      if (insertions) {\n         result.insertions[file] = insertions.length;\n      }\n\n      if (deletions) {\n         result.deletions[file] = deletions.length;\n      }\n   }),\n   new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {\n      if (insertions !== undefined || deletions !== undefined) {\n         result.summary.changes = +changes || 0;\n         result.summary.insertions = +insertions || 0;\n         result.summary.deletions = +deletions || 0;\n         return true;\n      }\n      return false;\n   }),\n   new LineParser(ACTION_REGEX, (result, [action, file]) => {\n      append(result.files, file);\n      append(action === 'create' ? result.created : result.deleted, file);\n   }),\n];\n\nconst errorParsers: LineParser<PullFailedResult>[] = [\n   new LineParser(/^from\\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),\n   new LineParser(/^fatal:\\s(.+)$/, (result, [message]) => void (result.message = message)),\n   new LineParser(\n      /([a-z0-9]+)\\.\\.([a-z0-9]+)\\s+(\\S+)\\s+->\\s+(\\S+)$/,\n      (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {\n         result.branch.local = branchLocal;\n         result.hash.local = hashLocal;\n         result.branch.remote = branchRemote;\n         result.hash.remote = hashRemote;\n      }\n   ),\n];\n\nexport const parsePullDetail: TaskParser<string, PullDetail> = (stdOut, stdErr) => {\n   return parseStringResponse(new PullSummary(), parsers, [stdOut, stdErr]);\n};\n\nexport const parsePullResult: TaskParser<string, PullResult> = (stdOut, stdErr) => {\n   return Object.assign(\n      new PullSummary(),\n      parsePullDetail(stdOut, stdErr),\n      parseRemoteMessages<RemoteMessages>(stdOut, stdErr)\n   );\n};\n\nexport function parsePullErrorResult(stdOut: string, stdErr: string) {\n   const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);\n\n   return pullError.message && pullError;\n}\n","import { MergeDetail, MergeResult } from '../../../typings';\nimport { MergeSummaryConflict, MergeSummaryDetail } from '../responses/MergeSummary';\nimport { TaskParser } from '../types';\nimport { LineParser, parseStringResponse } from '../utils';\nimport { parsePullResult } from './parse-pull';\n\nconst parsers: LineParser<MergeDetail>[] = [\n   new LineParser(/^Auto-merging\\s+(.+)$/, (summary, [autoMerge]) => {\n      summary.merges.push(autoMerge);\n   }),\n   new LineParser(/^CONFLICT\\s+\\((.+)\\): Merge conflict in (.+)$/, (summary, [reason, file]) => {\n      summary.conflicts.push(new MergeSummaryConflict(reason, file));\n   }),\n   new LineParser(\n      /^CONFLICT\\s+\\((.+\\/delete)\\): (.+) deleted in (.+) and/,\n      (summary, [reason, file, deleteRef]) => {\n         summary.conflicts.push(new MergeSummaryConflict(reason, file, { deleteRef }));\n      }\n   ),\n   new LineParser(/^CONFLICT\\s+\\((.+)\\):/, (summary, [reason]) => {\n      summary.conflicts.push(new MergeSummaryConflict(reason, null));\n   }),\n   new LineParser(/^Automatic merge failed;\\s+(.+)$/, (summary, [result]) => {\n      summary.result = result;\n   }),\n];\n\n/**\n * Parse the complete response from `git.merge`\n */\nexport const parseMergeResult: TaskParser<string, MergeResult> = (stdOut, stdErr) => {\n   return Object.assign(parseMergeDetail(stdOut, stdErr), parsePullResult(stdOut, stdErr));\n};\n\n/**\n * Parse the merge specific detail (ie: not the content also available in the pull detail) from `git.mnerge`\n * @param stdOut\n */\nexport const parseMergeDetail: TaskParser<string, MergeDetail> = (stdOut) => {\n   return parseStringResponse(new MergeSummaryDetail(), parsers, stdOut);\n};\n","import { MergeResult } from '../../../typings';\nimport { GitResponseError } from '../errors/git-response-error';\nimport { parseMergeResult } from '../parsers/parse-merge';\nimport { StringTask } from '../types';\nimport { configurationErrorTask, EmptyTask } from './task';\n\nexport function mergeTask(customArgs: string[]): EmptyTask | StringTask<MergeResult> {\n   if (!customArgs.length) {\n      return configurationErrorTask('Git.merge requires at least one option');\n   }\n\n   return {\n      commands: ['merge', ...customArgs],\n      format: 'utf-8',\n      parser(stdOut, stdErr): MergeResult {\n         const merge = parseMergeResult(stdOut, stdErr);\n         if (merge.failed) {\n            throw new GitResponseError(merge);\n         }\n\n         return merge;\n      },\n   };\n}\n","import {\n   PushDetail,\n   PushResult,\n   PushResultPushedItem,\n   PushResultRemoteMessages,\n} from '../../../typings';\nimport { TaskParser } from '../types';\nimport { LineParser, parseStringResponse } from '../utils';\nimport { parseRemoteMessages } from './parse-remote-messages';\n\nfunction pushResultPushedItem(local: string, remote: string, status: string): PushResultPushedItem {\n   const deleted = status.includes('deleted');\n   const tag = status.includes('tag') || /^refs\\/tags/.test(local);\n   const alreadyUpdated = !status.includes('new');\n\n   return {\n      deleted,\n      tag,\n      branch: !tag,\n      new: !alreadyUpdated,\n      alreadyUpdated,\n      local,\n      remote,\n   };\n}\n\nconst parsers: LineParser<PushDetail>[] = [\n   new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {\n      result.repo = repo;\n   }),\n   new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {\n      result.ref = {\n         ...(result.ref || {}),\n         local,\n      };\n   }),\n   new LineParser(/^[=*-]\\s+([^:]+):(\\S+)\\s+\\[(.+)]$/, (result, [local, remote, type]) => {\n      result.pushed.push(pushResultPushedItem(local, remote, type));\n   }),\n   new LineParser(\n      /^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/,\n      (result, [local, remote, remoteName]) => {\n         result.branch = {\n            ...(result.branch || {}),\n            local,\n            remote,\n            remoteName,\n         };\n      }\n   ),\n   new LineParser(\n      /^([^:]+):(\\S+)\\s+([a-z0-9]+)\\.\\.([a-z0-9]+)$/,\n      (result, [local, remote, from, to]) => {\n         result.update = {\n            head: {\n               local,\n               remote,\n            },\n            hash: {\n               from,\n               to,\n            },\n         };\n      }\n   ),\n];\n\nexport const parsePushResult: TaskParser<string, PushResult> = (stdOut, stdErr) => {\n   const pushDetail = parsePushDetail(stdOut, stdErr);\n   const responseDetail = parseRemoteMessages<PushResultRemoteMessages>(stdOut, stdErr);\n\n   return {\n      ...pushDetail,\n      ...responseDetail,\n   };\n};\n\nexport const parsePushDetail: TaskParser<string, PushDetail> = (stdOut, stdErr) => {\n   return parseStringResponse({ pushed: [] }, parsers, [stdOut, stdErr]);\n};\n","import { PushResult } from '../../../typings';\nimport { parsePushResult as parser } from '../parsers/parse-push';\nimport { StringTask } from '../types';\nimport { append, remove } from '../utils';\n\ntype PushRef = { remote?: string; branch?: string };\n\nexport function pushTagsTask(ref: PushRef = {}, customArgs: string[]): StringTask<PushResult> {\n   append(customArgs, '--tags');\n   return pushTask(ref, customArgs);\n}\n\nexport function pushTask(ref: PushRef = {}, customArgs: string[]): StringTask<PushResult> {\n   const commands = ['push', ...customArgs];\n   if (ref.branch) {\n      commands.splice(1, 0, ref.branch);\n   }\n   if (ref.remote) {\n      commands.splice(1, 0, ref.remote);\n   }\n\n   remove(commands, '-v');\n   append(commands, '--verbose');\n   append(commands, '--porcelain');\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser,\n   };\n}\n","import { SimpleGit } from '../../../typings';\nimport { SimpleGitApi } from '../simple-git-api';\nimport { getTrailingOptions, trailingFunctionArgument } from '../utils';\nimport { straightThroughBufferTask, straightThroughStringTask } from './task';\n\nexport default function (): Pick<SimpleGit, 'showBuffer' | 'show'> {\n   return {\n      showBuffer(this: SimpleGitApi) {\n         const commands = ['show', ...getTrailingOptions(arguments, 1)];\n         if (!commands.includes('--binary')) {\n            commands.splice(1, 0, '--binary');\n         }\n\n         return this._runTask(\n            straightThroughBufferTask(commands),\n            trailingFunctionArgument(arguments)\n         );\n      },\n\n      show(this: SimpleGitApi) {\n         const commands = ['show', ...getTrailingOptions(arguments, 1)];\n         return this._runTask(\n            straightThroughStringTask(commands),\n            trailingFunctionArgument(arguments)\n         );\n      },\n   };\n}\n","import { FileStatusResult } from '../../../typings';\n\nexport const fromPathRegex = /^(.+) -> (.+)$/;\n\nexport class FileStatusSummary implements FileStatusResult {\n   public readonly from: string | undefined;\n\n   constructor(\n      public path: string,\n      public index: string,\n      public working_dir: string\n   ) {\n      if ('R' === index + working_dir) {\n         const detail = fromPathRegex.exec(path) || [null, path, path];\n         this.from = detail[1] || '';\n         this.path = detail[2] || '';\n      }\n   }\n}\n","import { StatusResult } from '../../../typings';\nimport { append, NULL } from '../utils';\nimport { FileStatusSummary } from './FileStatusSummary';\n\ntype StatusLineParser = (result: StatusResult, file: string) => void;\n\nexport class StatusSummary implements StatusResult {\n   public not_added = [];\n   public conflicted = [];\n   public created = [];\n   public deleted = [];\n   public ignored = undefined;\n   public modified = [];\n   public renamed = [];\n   public files = [];\n   public staged = [];\n   public ahead = 0;\n   public behind = 0;\n   public current = null;\n   public tracking = null;\n   public detached = false;\n\n   public isClean = () => {\n      return !this.files.length;\n   };\n}\n\nenum PorcelainFileStatus {\n   ADDED = 'A',\n   DELETED = 'D',\n   MODIFIED = 'M',\n   RENAMED = 'R',\n   COPIED = 'C',\n   UNMERGED = 'U',\n   UNTRACKED = '?',\n   IGNORED = '!',\n   NONE = ' ',\n}\n\nfunction renamedFile(line: string) {\n   const [to, from] = line.split(NULL);\n\n   return {\n      from: from || to,\n      to,\n   };\n}\n\nfunction parser(\n   indexX: PorcelainFileStatus,\n   indexY: PorcelainFileStatus,\n   handler: StatusLineParser\n): [string, StatusLineParser] {\n   return [`${indexX}${indexY}`, handler];\n}\n\nfunction conflicts(indexX: PorcelainFileStatus, ...indexY: PorcelainFileStatus[]) {\n   return indexY.map((y) => parser(indexX, y, (result, file) => append(result.conflicted, file)));\n}\n\nconst parsers: Map<string, StatusLineParser> = new Map([\n   parser(PorcelainFileStatus.NONE, PorcelainFileStatus.ADDED, (result, file) =>\n      append(result.created, file)\n   ),\n   parser(PorcelainFileStatus.NONE, PorcelainFileStatus.DELETED, (result, file) =>\n      append(result.deleted, file)\n   ),\n   parser(PorcelainFileStatus.NONE, PorcelainFileStatus.MODIFIED, (result, file) =>\n      append(result.modified, file)\n   ),\n\n   parser(\n      PorcelainFileStatus.ADDED,\n      PorcelainFileStatus.NONE,\n      (result, file) => append(result.created, file) && append(result.staged, file)\n   ),\n   parser(\n      PorcelainFileStatus.ADDED,\n      PorcelainFileStatus.MODIFIED,\n      (result, file) =>\n         append(result.created, file) &&\n         append(result.staged, file) &&\n         append(result.modified, file)\n   ),\n\n   parser(\n      PorcelainFileStatus.DELETED,\n      PorcelainFileStatus.NONE,\n      (result, file) => append(result.deleted, file) && append(result.staged, file)\n   ),\n\n   parser(\n      PorcelainFileStatus.MODIFIED,\n      PorcelainFileStatus.NONE,\n      (result, file) => append(result.modified, file) && append(result.staged, file)\n   ),\n   parser(\n      PorcelainFileStatus.MODIFIED,\n      PorcelainFileStatus.MODIFIED,\n      (result, file) => append(result.modified, file) && append(result.staged, file)\n   ),\n\n   parser(PorcelainFileStatus.RENAMED, PorcelainFileStatus.NONE, (result, file) => {\n      append(result.renamed, renamedFile(file));\n   }),\n   parser(PorcelainFileStatus.RENAMED, PorcelainFileStatus.MODIFIED, (result, file) => {\n      const renamed = renamedFile(file);\n      append(result.renamed, renamed);\n      append(result.modified, renamed.to);\n   }),\n   parser(PorcelainFileStatus.IGNORED, PorcelainFileStatus.IGNORED, (_result, _file) => {\n      append((_result.ignored = _result.ignored || []), _file);\n   }),\n\n   parser(PorcelainFileStatus.UNTRACKED, PorcelainFileStatus.UNTRACKED, (result, file) =>\n      append(result.not_added, file)\n   ),\n\n   ...conflicts(PorcelainFileStatus.ADDED, PorcelainFileStatus.ADDED, PorcelainFileStatus.UNMERGED),\n   ...conflicts(\n      PorcelainFileStatus.DELETED,\n      PorcelainFileStatus.DELETED,\n      PorcelainFileStatus.UNMERGED\n   ),\n   ...conflicts(\n      PorcelainFileStatus.UNMERGED,\n      PorcelainFileStatus.ADDED,\n      PorcelainFileStatus.DELETED,\n      PorcelainFileStatus.UNMERGED\n   ),\n\n   [\n      '##',\n      (result, line) => {\n         const aheadReg = /ahead (\\d+)/;\n         const behindReg = /behind (\\d+)/;\n         const currentReg = /^(.+?(?=(?:\\.{3}|\\s|$)))/;\n         const trackingReg = /\\.{3}(\\S*)/;\n         const onEmptyBranchReg = /\\son\\s([\\S]+)$/;\n         let regexResult;\n\n         regexResult = aheadReg.exec(line);\n         result.ahead = (regexResult && +regexResult[1]) || 0;\n\n         regexResult = behindReg.exec(line);\n         result.behind = (regexResult && +regexResult[1]) || 0;\n\n         regexResult = currentReg.exec(line);\n         result.current = regexResult && regexResult[1];\n\n         regexResult = trackingReg.exec(line);\n         result.tracking = regexResult && regexResult[1];\n\n         regexResult = onEmptyBranchReg.exec(line);\n         result.current = (regexResult && regexResult[1]) || result.current;\n\n         result.detached = /\\(no branch\\)/.test(line);\n      },\n   ],\n]);\n\nexport const parseStatusSummary = function (text: string): StatusResult {\n   const lines = text.split(NULL);\n   const status = new StatusSummary();\n\n   for (let i = 0, l = lines.length; i < l; ) {\n      let line = lines[i++].trim();\n\n      if (!line) {\n         continue;\n      }\n\n      if (line.charAt(0) === PorcelainFileStatus.RENAMED) {\n         line += NULL + (lines[i++] || '');\n      }\n\n      splitLine(status, line);\n   }\n\n   return status;\n};\n\nfunction splitLine(result: StatusResult, lineStr: string) {\n   const trimmed = lineStr.trim();\n   switch (' ') {\n      case trimmed.charAt(2):\n         return data(trimmed.charAt(0), trimmed.charAt(1), trimmed.substr(3));\n      case trimmed.charAt(1):\n         return data(PorcelainFileStatus.NONE, trimmed.charAt(0), trimmed.substr(2));\n      default:\n         return;\n   }\n\n   function data(index: string, workingDir: string, path: string) {\n      const raw = `${index}${workingDir}`;\n      const handler = parsers.get(raw);\n\n      if (handler) {\n         handler(result, path);\n      }\n\n      if (raw !== '##' && raw !== '!!') {\n         result.files.push(new FileStatusSummary(path.replace(/\\0.+$/, ''), index, workingDir));\n      }\n   }\n}\n","import { StatusResult } from '../../../typings';\nimport { parseStatusSummary } from '../responses/StatusSummary';\nimport { StringTask } from '../types';\n\nconst ignoredOptions = ['--null', '-z'];\n\nexport function statusTask(customArgs: string[]): StringTask<StatusResult> {\n   const commands = [\n      'status',\n      '--porcelain',\n      '-b',\n      '-u',\n      '--null',\n      ...customArgs.filter((arg) => !ignoredOptions.includes(arg)),\n   ];\n\n   return {\n      format: 'utf-8',\n      commands,\n      parser(text: string) {\n         return parseStatusSummary(text);\n      },\n   };\n}\n","import type { SimpleGitApi } from '../simple-git-api';\nimport type { SimpleGit } from '../../../typings';\nimport { asNumber, ExitCodes, LineParser, parseStringResponse } from '../utils';\n\nexport interface VersionResult {\n   major: number;\n   minor: number;\n   patch: number | string;\n   agent: string;\n   installed: boolean;\n}\n\nconst NOT_INSTALLED = 'installed=false';\n\nfunction versionResponse(\n   major = 0,\n   minor = 0,\n   patch: string | number = 0,\n   agent = '',\n   installed = true\n): VersionResult {\n   return Object.defineProperty(\n      {\n         major,\n         minor,\n         patch,\n         agent,\n         installed,\n      },\n      'toString',\n      {\n         value() {\n            return `${this.major}.${this.minor}.${this.patch}`;\n         },\n         configurable: false,\n         enumerable: false,\n      }\n   );\n}\n\nfunction notInstalledResponse() {\n   return versionResponse(0, 0, 0, '', false);\n}\n\nexport default function (): Pick<SimpleGit, 'version'> {\n   return {\n      version(this: SimpleGitApi) {\n         return this._runTask({\n            commands: ['--version'],\n            format: 'utf-8',\n            parser: versionParser,\n            onError(result, error, done, fail) {\n               if (result.exitCode === ExitCodes.NOT_FOUND) {\n                  return done(Buffer.from(NOT_INSTALLED));\n               }\n\n               fail(error);\n            },\n         });\n      },\n   };\n}\n\nconst parsers: LineParser<VersionResult>[] = [\n   new LineParser(\n      /version (\\d+)\\.(\\d+)\\.(\\d+)(?:\\s*\\((.+)\\))?/,\n      (result, [major, minor, patch, agent = '']) => {\n         Object.assign(\n            result,\n            versionResponse(asNumber(major), asNumber(minor), asNumber(patch), agent)\n         );\n      }\n   ),\n   new LineParser(\n      /version (\\d+)\\.(\\d+)\\.(\\D+)(.+)?$/,\n      (result, [major, minor, patch, agent = '']) => {\n         Object.assign(result, versionResponse(asNumber(major), asNumber(minor), patch, agent));\n      }\n   ),\n];\n\nfunction versionParser(stdOut: string) {\n   if (stdOut === NOT_INSTALLED) {\n      return notInstalledResponse();\n   }\n\n   return parseStringResponse(versionResponse(0, 0, 0, stdOut), parsers, stdOut);\n}\n","import { SimpleGitBase } from '../../typings';\nimport { taskCallback } from './task-callback';\nimport { changeWorkingDirectoryTask } from './tasks/change-working-directory';\nimport checkout from './tasks/checkout';\nimport commit from './tasks/commit';\nimport config from './tasks/config';\nimport firstCommit from './tasks/first-commit';\nimport grep from './tasks/grep';\nimport { hashObjectTask } from './tasks/hash-object';\nimport { initTask } from './tasks/init';\nimport log from './tasks/log';\nimport { mergeTask } from './tasks/merge';\nimport { pushTask } from './tasks/push';\nimport show from './tasks/show';\nimport { statusTask } from './tasks/status';\nimport { configurationErrorTask, straightThroughStringTask } from './tasks/task';\nimport version from './tasks/version';\nimport { outputHandler, SimpleGitExecutor, SimpleGitTask, SimpleGitTaskCallback } from './types';\nimport {\n   asArray,\n   filterString,\n   filterType,\n   getTrailingOptions,\n   trailingFunctionArgument,\n} from './utils';\n\nexport class SimpleGitApi implements SimpleGitBase {\n   constructor(private _executor: SimpleGitExecutor) {}\n\n   protected _runTask<T>(task: SimpleGitTask<T>, then?: SimpleGitTaskCallback<T>) {\n      const chain = this._executor.chain();\n      const promise = chain.push(task);\n\n      if (then) {\n         taskCallback(task, promise, then);\n      }\n\n      return Object.create(this, {\n         then: { value: promise.then.bind(promise) },\n         catch: { value: promise.catch.bind(promise) },\n         _executor: { value: chain },\n      });\n   }\n\n   add(files: string | string[]) {\n      return this._runTask(\n         straightThroughStringTask(['add', ...asArray(files)]),\n         trailingFunctionArgument(arguments)\n      );\n   }\n\n   cwd(directory: string | { path: string; root?: boolean }) {\n      const next = trailingFunctionArgument(arguments);\n\n      if (typeof directory === 'string') {\n         return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);\n      }\n\n      if (typeof directory?.path === 'string') {\n         return this._runTask(\n            changeWorkingDirectoryTask(\n               directory.path,\n               (directory.root && this._executor) || undefined\n            ),\n            next\n         );\n      }\n\n      return this._runTask(\n         configurationErrorTask('Git.cwd: workingDirectory must be supplied as a string'),\n         next\n      );\n   }\n\n   hashObject(path: string, write: boolean | unknown) {\n      return this._runTask(\n         hashObjectTask(path, write === true),\n         trailingFunctionArgument(arguments)\n      );\n   }\n\n   init(bare?: boolean | unknown) {\n      return this._runTask(\n         initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)),\n         trailingFunctionArgument(arguments)\n      );\n   }\n\n   merge() {\n      return this._runTask(\n         mergeTask(getTrailingOptions(arguments)),\n         trailingFunctionArgument(arguments)\n      );\n   }\n\n   mergeFromTo(remote: string, branch: string) {\n      if (!(filterString(remote) && filterString(branch))) {\n         return this._runTask(\n            configurationErrorTask(\n               `Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`\n            )\n         );\n      }\n\n      return this._runTask(\n         mergeTask([remote, branch, ...getTrailingOptions(arguments)]),\n         trailingFunctionArgument(arguments, false)\n      );\n   }\n\n   outputHandler(handler: outputHandler) {\n      this._executor.outputHandler = handler;\n      return this;\n   }\n\n   push() {\n      const task = pushTask(\n         {\n            remote: filterType(arguments[0], filterString),\n            branch: filterType(arguments[1], filterString),\n         },\n         getTrailingOptions(arguments)\n      );\n\n      return this._runTask(task, trailingFunctionArgument(arguments));\n   }\n\n   stash() {\n      return this._runTask(\n         straightThroughStringTask(['stash', ...getTrailingOptions(arguments)]),\n         trailingFunctionArgument(arguments)\n      );\n   }\n\n   status() {\n      return this._runTask(\n         statusTask(getTrailingOptions(arguments)),\n         trailingFunctionArgument(arguments)\n      );\n   }\n}\n\nObject.assign(\n   SimpleGitApi.prototype,\n   checkout(),\n   commit(),\n   config(),\n   firstCommit(),\n   grep(),\n   log(),\n   show(),\n   version()\n);\n","import { append, remove } from '../utils';\nimport { createDeferred, DeferredPromise } from '@kwsites/promise-deferred';\nimport { createLogger } from '../git-logger';\n\ntype ScheduleCompleteCallback = () => void;\ntype ScheduledTask = Pick<DeferredPromise<ScheduleCompleteCallback>, 'promise' | 'done'> & {\n   id: number;\n};\n\nconst createScheduledTask: () => ScheduledTask = (() => {\n   let id = 0;\n   return () => {\n      id++;\n      const { promise, done } = createDeferred<ScheduleCompleteCallback>();\n\n      return {\n         promise,\n         done,\n         id,\n      };\n   };\n})();\n\nexport class Scheduler {\n   private logger = createLogger('', 'scheduler');\n   private pending: ScheduledTask[] = [];\n   private running: ScheduledTask[] = [];\n\n   constructor(private concurrency = 2) {\n      this.logger(`Constructed, concurrency=%s`, concurrency);\n   }\n\n   private schedule() {\n      if (!this.pending.length || this.running.length >= this.concurrency) {\n         this.logger(\n            `Schedule attempt ignored, pending=%s running=%s concurrency=%s`,\n            this.pending.length,\n            this.running.length,\n            this.concurrency\n         );\n         return;\n      }\n\n      const task = append(this.running, this.pending.shift()!);\n      this.logger(`Attempting id=%s`, task.id);\n      task.done(() => {\n         this.logger(`Completing id=`, task.id);\n         remove(this.running, task);\n         this.schedule();\n      });\n   }\n\n   next(): Promise<ScheduleCompleteCallback> {\n      const { promise, id } = append(this.pending, createScheduledTask());\n      this.logger(`Scheduling id=%s`, id);\n\n      this.schedule();\n\n      return promise;\n   }\n}\n","import { straightThroughStringTask } from './task';\nimport { OptionFlags, Options, StringTask } from '../types';\n\nexport type ApplyOptions = Options &\n   OptionFlags<\n      | '--stat'\n      | '--numstat'\n      | '--summary'\n      | '--check'\n      | '--index'\n      | '--intent-to-add'\n      | '--3way'\n      | '--apply'\n      | '--no-add'\n      | '-R'\n      | '--reverse'\n      | '--allow-binary-replacement'\n      | '--binary'\n      | '--reject'\n      | '-z'\n      | '--inaccurate-eof'\n      | '--recount'\n      | '--cached'\n      | '--ignore-space-change'\n      | '--ignore-whitespace'\n      | '--verbose'\n      | '--unsafe-paths'\n   > &\n   OptionFlags<'--whitespace', 'nowarn' | 'warn' | 'fix' | 'error' | 'error-all'> &\n   OptionFlags<'--build-fake-ancestor' | '--exclude' | '--include' | '--directory', string> &\n   OptionFlags<'-p' | '-C', number>;\n\nexport function applyPatchTask(patches: string[], customArgs: string[]): StringTask<string> {\n   return straightThroughStringTask(['apply', ...customArgs, ...patches]);\n}\n","import {\n   BranchMultiDeleteResult,\n   BranchSingleDeleteFailure,\n   BranchSingleDeleteResult,\n   BranchSingleDeleteSuccess,\n} from '../../../typings';\n\nexport class BranchDeletionBatch implements BranchMultiDeleteResult {\n   all: BranchSingleDeleteResult[] = [];\n   branches: { [branchName: string]: BranchSingleDeleteResult } = {};\n   errors: BranchSingleDeleteResult[] = [];\n\n   get success(): boolean {\n      return !this.errors.length;\n   }\n}\n\nexport function branchDeletionSuccess(branch: string, hash: string): BranchSingleDeleteSuccess {\n   return {\n      branch,\n      hash,\n      success: true,\n   };\n}\n\nexport function branchDeletionFailure(branch: string): BranchSingleDeleteFailure {\n   return {\n      branch,\n      hash: null,\n      success: false,\n   };\n}\n\nexport function isSingleBranchDeleteFailure(\n   test: BranchSingleDeleteResult\n): test is BranchSingleDeleteSuccess {\n   return test.success;\n}\n","import { BranchMultiDeleteResult } from '../../../typings';\nimport {\n   BranchDeletionBatch,\n   branchDeletionFailure,\n   branchDeletionSuccess,\n} from '../responses/BranchDeleteSummary';\nimport { TaskParser } from '../types';\nimport { ExitCodes, LineParser, parseStringResponse } from '../utils';\n\nconst deleteSuccessRegex = /(\\S+)\\s+\\(\\S+\\s([^)]+)\\)/;\nconst deleteErrorRegex = /^error[^']+'([^']+)'/m;\n\nconst parsers: LineParser<BranchMultiDeleteResult>[] = [\n   new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {\n      const deletion = branchDeletionSuccess(branch, hash);\n\n      result.all.push(deletion);\n      result.branches[branch] = deletion;\n   }),\n   new LineParser(deleteErrorRegex, (result, [branch]) => {\n      const deletion = branchDeletionFailure(branch);\n\n      result.errors.push(deletion);\n      result.all.push(deletion);\n      result.branches[branch] = deletion;\n   }),\n];\n\nexport const parseBranchDeletions: TaskParser<string, BranchMultiDeleteResult> = (\n   stdOut,\n   stdErr\n) => {\n   return parseStringResponse(new BranchDeletionBatch(), parsers, [stdOut, stdErr]);\n};\n\nexport function hasBranchDeletionError(data: string, processExitCode: ExitCodes): boolean {\n   return processExitCode === ExitCodes.ERROR && deleteErrorRegex.test(data);\n}\n","import type { BranchSummary, BranchSummaryBranch } from '../../../typings';\n\nexport enum BranchStatusIdentifier {\n   CURRENT = '*',\n   LINKED = '+',\n}\n\nexport class BranchSummaryResult implements BranchSummary {\n   public all: string[] = [];\n   public branches: { [p: string]: BranchSummaryBranch } = {};\n   public current: string = '';\n   public detached: boolean = false;\n\n   push(\n      status: BranchStatusIdentifier | unknown,\n      detached: boolean,\n      name: string,\n      commit: string,\n      label: string\n   ) {\n      if (status === BranchStatusIdentifier.CURRENT) {\n         this.detached = detached;\n         this.current = name;\n      }\n\n      this.all.push(name);\n      this.branches[name] = {\n         current: status === BranchStatusIdentifier.CURRENT,\n         linkedWorkTree: status === BranchStatusIdentifier.LINKED,\n         name,\n         commit,\n         label,\n      };\n   }\n}\n","import type { BranchSummary } from '../../../typings';\nimport { BranchSummaryResult } from '../responses/BranchSummary';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<BranchSummaryResult>[] = [\n   new LineParser(\n      /^([*+]\\s)?\\((?:HEAD )?detached (?:from|at) (\\S+)\\)\\s+([a-z0-9]+)\\s(.*)$/,\n      (result, [current, name, commit, label]) => {\n         result.push(branchStatus(current), true, name, commit, label);\n      }\n   ),\n   new LineParser(\n      /^([*+]\\s)?(\\S+)\\s+([a-z0-9]+)\\s?(.*)$/s,\n      (result, [current, name, commit, label]) => {\n         result.push(branchStatus(current), false, name, commit, label);\n      }\n   ),\n];\n\nfunction branchStatus(input?: string) {\n   return input ? input.charAt(0) : '';\n}\n\nexport function parseBranchSummary(stdOut: string): BranchSummary {\n   return parseStringResponse(new BranchSummaryResult(), parsers, stdOut);\n}\n","import { BranchMultiDeleteResult, BranchSingleDeleteResult, BranchSummary } from '../../../typings';\nimport { StringTask } from '../types';\nimport { GitResponseError } from '../errors/git-response-error';\nimport { hasBranchDeletionError, parseBranchDeletions } from '../parsers/parse-branch-delete';\nimport { parseBranchSummary } from '../parsers/parse-branch';\nimport { bufferToString } from '../utils';\n\nexport function containsDeleteBranchCommand(commands: string[]) {\n   const deleteCommands = ['-d', '-D', '--delete'];\n   return commands.some((command) => deleteCommands.includes(command));\n}\n\nexport function branchTask(\n   customArgs: string[]\n): StringTask<BranchSummary | BranchSingleDeleteResult> {\n   const isDelete = containsDeleteBranchCommand(customArgs);\n   const commands = ['branch', ...customArgs];\n\n   if (commands.length === 1) {\n      commands.push('-a');\n   }\n\n   if (!commands.includes('-v')) {\n      commands.splice(1, 0, '-v');\n   }\n\n   return {\n      format: 'utf-8',\n      commands,\n      parser(stdOut, stdErr) {\n         if (isDelete) {\n            return parseBranchDeletions(stdOut, stdErr).all[0];\n         }\n\n         return parseBranchSummary(stdOut);\n      },\n   };\n}\n\nexport function branchLocalTask(): StringTask<BranchSummary> {\n   const parser = parseBranchSummary;\n\n   return {\n      format: 'utf-8',\n      commands: ['branch', '-v'],\n      parser,\n   };\n}\n\nexport function deleteBranchesTask(\n   branches: string[],\n   forceDelete = false\n): StringTask<BranchMultiDeleteResult> {\n   return {\n      format: 'utf-8',\n      commands: ['branch', '-v', forceDelete ? '-D' : '-d', ...branches],\n      parser(stdOut, stdErr) {\n         return parseBranchDeletions(stdOut, stdErr);\n      },\n      onError({ exitCode, stdOut }, error, done, fail) {\n         if (!hasBranchDeletionError(String(error), exitCode)) {\n            return fail(error);\n         }\n\n         done(stdOut);\n      },\n   };\n}\n\nexport function deleteBranchTask(\n   branch: string,\n   forceDelete = false\n): StringTask<BranchSingleDeleteResult> {\n   const task: StringTask<BranchSingleDeleteResult> = {\n      format: 'utf-8',\n      commands: ['branch', '-v', forceDelete ? '-D' : '-d', branch],\n      parser(stdOut, stdErr) {\n         return parseBranchDeletions(stdOut, stdErr).branches[branch]!;\n      },\n      onError({ exitCode, stdErr, stdOut }, error, _, fail) {\n         if (!hasBranchDeletionError(String(error), exitCode)) {\n            return fail(error);\n         }\n\n         throw new GitResponseError(\n            task.parser(bufferToString(stdOut), bufferToString(stdErr)),\n            String(error)\n         );\n      },\n   };\n\n   return task;\n}\n","/**\n * Parser for the `check-ignore` command - returns each file as a string array\n */\nexport const parseCheckIgnore = (text: string): string[] => {\n   return text\n      .split(/\\n/g)\n      .map((line) => line.trim())\n      .filter((file) => !!file);\n};\n","import { StringTask } from '../types';\nimport { parseCheckIgnore } from '../responses/CheckIgnore';\n\nexport function checkIgnoreTask(paths: string[]): StringTask<string[]> {\n   return {\n      commands: ['check-ignore', ...paths],\n      format: 'utf-8',\n      parser: parseCheckIgnore,\n   };\n}\n","import { configurationErrorTask, EmptyTask, straightThroughStringTask } from './task';\nimport { OptionFlags, Options, StringTask } from '../types';\nimport { append, filterString } from '../utils';\n\nexport type CloneOptions = Options &\n   OptionFlags<\n      | '--bare'\n      | '--dissociate'\n      | '--mirror'\n      | '--no-checkout'\n      | '--no-remote-submodules'\n      | '--no-shallow-submodules'\n      | '--no-single-branch'\n      | '--no-tags'\n      | '--remote-submodules'\n      | '--single-branch'\n      | '--shallow-submodules'\n      | '--verbose'\n   > &\n   OptionFlags<'--depth' | '-j' | '--jobs', number> &\n   OptionFlags<\n      | '--branch'\n      | '--origin'\n      | '--recurse-submodules'\n      | '--separate-git-dir'\n      | '--shallow-exclude'\n      | '--shallow-since'\n      | '--template',\n      string\n   >;\n\nfunction disallowedCommand(command: string) {\n   return /^--upload-pack(=|$)/.test(command);\n}\n\nexport function cloneTask(\n   repo: string | undefined,\n   directory: string | undefined,\n   customArgs: string[]\n): StringTask<string> | EmptyTask {\n   const commands = ['clone', ...customArgs];\n\n   filterString(repo) && commands.push(repo);\n   filterString(directory) && commands.push(directory);\n\n   const banned = commands.find(disallowedCommand);\n   if (banned) {\n      return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function cloneMirrorTask(\n   repo: string | undefined,\n   directory: string | undefined,\n   customArgs: string[]\n) {\n   append(customArgs, '--mirror');\n\n   return cloneTask(repo, directory, customArgs);\n}\n","import { FetchResult } from '../../../typings';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<FetchResult>[] = [\n   new LineParser(/From (.+)$/, (result, [remote]) => {\n      result.remote = remote;\n   }),\n   new LineParser(/\\* \\[new branch]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) => {\n      result.branches.push({\n         name,\n         tracking,\n      });\n   }),\n   new LineParser(/\\* \\[new tag]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) => {\n      result.tags.push({\n         name,\n         tracking,\n      });\n   }),\n   new LineParser(/- \\[deleted]\\s+\\S+\\s*-> (.+)$/, (result, [tracking]) => {\n      result.deleted.push({\n         tracking,\n      });\n   }),\n   new LineParser(\n      /\\s*([^.]+)\\.\\.(\\S+)\\s+(\\S+)\\s*-> (.+)$/,\n      (result, [from, to, name, tracking]) => {\n         result.updated.push({\n            name,\n            tracking,\n            to,\n            from,\n         });\n      }\n   ),\n];\n\nexport function parseFetchResult(stdOut: string, stdErr: string): FetchResult {\n   const result: FetchResult = {\n      raw: stdOut,\n      remote: null,\n      branches: [],\n      tags: [],\n      updated: [],\n      deleted: [],\n   };\n   return parseStringResponse(result, parsers, [stdOut, stdErr]);\n}\n","import { FetchResult } from '../../../typings';\nimport { parseFetchResult } from '../parsers/parse-fetch';\nimport { StringTask } from '../types';\n\nimport { configurationErrorTask, EmptyTask } from './task';\n\nfunction disallowedCommand(command: string) {\n   return /^--upload-pack(=|$)/.test(command);\n}\n\nexport function fetchTask(\n   remote: string,\n   branch: string,\n   customArgs: string[]\n): StringTask<FetchResult> | EmptyTask {\n   const commands = ['fetch', ...customArgs];\n   if (remote && branch) {\n      commands.push(remote, branch);\n   }\n\n   const banned = commands.find(disallowedCommand);\n   if (banned) {\n      return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser: parseFetchResult,\n   };\n}\n","import { MoveResult } from '../../../typings';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<MoveResult>[] = [\n   new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {\n      result.moves.push({ from, to });\n   }),\n];\n\nexport function parseMoveResult(stdOut: string): MoveResult {\n   return parseStringResponse({ moves: [] }, parsers, stdOut);\n}\n","import { MoveResult } from '../../../typings';\nimport { parseMoveResult } from '../parsers/parse-move';\nimport { StringTask } from '../types';\nimport { asArray } from '../utils';\n\nexport function moveTask(from: string | string[], to: string): StringTask<MoveResult> {\n   return {\n      commands: ['mv', '-v', ...asArray(from), to],\n      format: 'utf-8',\n      parser: parseMoveResult,\n   };\n}\n","import { PullResult } from '../../../typings';\nimport { GitResponseError } from '../errors/git-response-error';\nimport { parsePullErrorResult, parsePullResult } from '../parsers/parse-pull';\nimport { Maybe, StringTask } from '../types';\nimport { bufferToString } from '../utils';\n\nexport function pullTask(\n   remote: Maybe<string>,\n   branch: Maybe<string>,\n   customArgs: string[]\n): StringTask<PullResult> {\n   const commands: string[] = ['pull', ...customArgs];\n   if (remote && branch) {\n      commands.splice(1, 0, remote, branch);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(stdOut, stdErr): PullResult {\n         return parsePullResult(stdOut, stdErr);\n      },\n      onError(result, _error, _done, fail) {\n         const pullError = parsePullErrorResult(\n            bufferToString(result.stdOut),\n            bufferToString(result.stdErr)\n         );\n         if (pullError) {\n            return fail(new GitResponseError(pullError));\n         }\n\n         fail(_error);\n      },\n   };\n}\n","import { forEachLineWithContent } from '../utils';\n\nexport interface RemoteWithoutRefs {\n   name: string;\n}\n\nexport interface RemoteWithRefs extends RemoteWithoutRefs {\n   refs: {\n      fetch: string;\n      push: string;\n   };\n}\n\nexport function parseGetRemotes(text: string): RemoteWithoutRefs[] {\n   const remotes: { [name: string]: RemoteWithoutRefs } = {};\n\n   forEach(text, ([name]) => (remotes[name] = { name }));\n\n   return Object.values(remotes);\n}\n\nexport function parseGetRemotesVerbose(text: string): RemoteWithRefs[] {\n   const remotes: { [name: string]: RemoteWithRefs } = {};\n\n   forEach(text, ([name, url, purpose]) => {\n      if (!remotes.hasOwnProperty(name)) {\n         remotes[name] = {\n            name: name,\n            refs: { fetch: '', push: '' },\n         };\n      }\n\n      if (purpose && url) {\n         remotes[name].refs[purpose.replace(/[^a-z]/g, '') as keyof RemoteWithRefs['refs']] = url;\n      }\n   });\n\n   return Object.values(remotes);\n}\n\nfunction forEach(text: string, handler: (line: string[]) => void) {\n   forEachLineWithContent(text, (line) => handler(line.split(/\\s+/)));\n}\n","import { parseGetRemotes, parseGetRemotesVerbose } from '../responses/GetRemoteSummary';\nimport { StringTask } from '../types';\nimport { straightThroughStringTask } from './task';\n\nexport function addRemoteTask(\n   remoteName: string,\n   remoteRepo: string,\n   customArgs: string[] = []\n): StringTask<string> {\n   return straightThroughStringTask(['remote', 'add', ...customArgs, remoteName, remoteRepo]);\n}\n\nexport function getRemotesTask(verbose: boolean): StringTask<any> {\n   const commands = ['remote'];\n   if (verbose) {\n      commands.push('-v');\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser: verbose ? parseGetRemotesVerbose : parseGetRemotes,\n   };\n}\n\nexport function listRemotesTask(customArgs: string[] = []): StringTask<string> {\n   const commands = [...customArgs];\n   if (commands[0] !== 'ls-remote') {\n      commands.unshift('ls-remote');\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function remoteTask(customArgs: string[] = []): StringTask<string> {\n   const commands = [...customArgs];\n   if (commands[0] !== 'remote') {\n      commands.unshift('remote');\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function removeRemoteTask(remoteName: string) {\n   return straightThroughStringTask(['remote', 'remove', remoteName]);\n}\n","import { LogOptions, LogResult } from '../../../typings';\nimport { logFormatFromCommand } from '../args/log-format';\nimport { createListLogSummaryParser } from '../parsers/parse-list-log-summary';\nimport type { StringTask } from '../types';\nimport { validateLogFormatConfig } from './diff';\nimport { parseLogOptions } from './log';\nimport type { EmptyTask } from './task';\n\nexport function stashListTask(\n   opt: LogOptions = {},\n   customArgs: string[]\n): EmptyTask | StringTask<LogResult> {\n   const options = parseLogOptions<any>(opt);\n   const commands = ['stash', 'list', ...options.commands, ...customArgs];\n   const parser = createListLogSummaryParser(\n      options.splitter,\n      options.fields,\n      logFormatFromCommand(commands)\n   );\n\n   return (\n      validateLogFormatConfig(commands) || {\n         commands,\n         format: 'utf-8',\n         parser,\n      }\n   );\n}\n","import { StringTask } from '../types';\nimport { straightThroughStringTask } from './task';\n\nexport function addSubModuleTask(repo: string, path: string): StringTask<string> {\n   return subModuleTask(['add', repo, path]);\n}\n\nexport function initSubModuleTask(customArgs: string[]): StringTask<string> {\n   return subModuleTask(['init', ...customArgs]);\n}\n\nexport function subModuleTask(customArgs: string[]): StringTask<string> {\n   const commands = [...customArgs];\n   if (commands[0] !== 'submodule') {\n      commands.unshift('submodule');\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function updateSubModuleTask(customArgs: string[]): StringTask<string> {\n   return subModuleTask(['update', ...customArgs]);\n}\n","import { TagResult } from '../../../typings';\n\nexport class TagList implements TagResult {\n   constructor(\n      public readonly all: string[],\n      public readonly latest: string | undefined\n   ) {}\n}\n\nexport const parseTagList = function (data: string, customSort = false) {\n   const tags = data.split('\\n').map(trimmed).filter(Boolean);\n\n   if (!customSort) {\n      tags.sort(function (tagA, tagB) {\n         const partsA = tagA.split('.');\n         const partsB = tagB.split('.');\n\n         if (partsA.length === 1 || partsB.length === 1) {\n            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));\n         }\n\n         for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {\n            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));\n\n            if (diff) {\n               return diff;\n            }\n         }\n\n         return 0;\n      });\n   }\n\n   const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf('.') >= 0);\n\n   return new TagList(tags, latest);\n};\n\nfunction singleSorted(a: number, b: number): number {\n   const aIsNum = isNaN(a);\n   const bIsNum = isNaN(b);\n\n   if (aIsNum !== bIsNum) {\n      return aIsNum ? 1 : -1;\n   }\n\n   return aIsNum ? sorted(a, b) : 0;\n}\n\nfunction sorted(a: number, b: number) {\n   return a === b ? 0 : a > b ? 1 : -1;\n}\n\nfunction trimmed(input: string) {\n   return input.trim();\n}\n\nfunction toNumber(input: string | undefined) {\n   if (typeof input === 'string') {\n      return parseInt(input.replace(/^\\D+/g, ''), 10) || 0;\n   }\n\n   return 0;\n}\n","import { TagResult } from '../../../typings';\nimport { parseTagList } from '../responses/TagList';\nimport { StringTask } from '../types';\n\n/**\n * Task used by `git.tags`\n */\nexport function tagListTask(customArgs: string[] = []): StringTask<TagResult> {\n   const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));\n\n   return {\n      format: 'utf-8',\n      commands: ['tag', '-l', ...customArgs],\n      parser(text: string) {\n         return parseTagList(text, hasCustomSort);\n      },\n   };\n}\n\n/**\n * Task used by `git.addTag`\n */\nexport function addTagTask(name: string): StringTask<{ name: string }> {\n   return {\n      format: 'utf-8',\n      commands: ['tag', name],\n      parser() {\n         return { name };\n      },\n   };\n}\n\n/**\n * Task used by `git.addTag`\n */\nexport function addAnnotatedTagTask(\n   name: string,\n   tagMessage: string\n): StringTask<{ name: string }> {\n   return {\n      format: 'utf-8',\n      commands: ['tag', '-a', '-m', tagMessage, name],\n      parser() {\n         return { name };\n      },\n   };\n}\n","const { GitExecutor } = require('./lib/runners/git-executor');\nconst { SimpleGitApi } = require('./lib/simple-git-api');\n\nconst { Scheduler } = require('./lib/runners/scheduler');\nconst { configurationErrorTask } = require('./lib/tasks/task');\nconst {\n   asArray,\n   filterArray,\n   filterPrimitives,\n   filterString,\n   filterStringOrStringArray,\n   filterType,\n   getTrailingOptions,\n   trailingFunctionArgument,\n   trailingOptionsArgument,\n} = require('./lib/utils');\nconst { applyPatchTask } = require('./lib/tasks/apply-patch');\nconst {\n   branchTask,\n   branchLocalTask,\n   deleteBranchesTask,\n   deleteBranchTask,\n} = require('./lib/tasks/branch');\nconst { checkIgnoreTask } = require('./lib/tasks/check-ignore');\nconst { checkIsRepoTask } = require('./lib/tasks/check-is-repo');\nconst { cloneTask, cloneMirrorTask } = require('./lib/tasks/clone');\nconst { cleanWithOptionsTask, isCleanOptionsArray } = require('./lib/tasks/clean');\nconst { diffSummaryTask } = require('./lib/tasks/diff');\nconst { fetchTask } = require('./lib/tasks/fetch');\nconst { moveTask } = require('./lib/tasks/move');\nconst { pullTask } = require('./lib/tasks/pull');\nconst { pushTagsTask } = require('./lib/tasks/push');\nconst {\n   addRemoteTask,\n   getRemotesTask,\n   listRemotesTask,\n   remoteTask,\n   removeRemoteTask,\n} = require('./lib/tasks/remote');\nconst { getResetMode, resetTask } = require('./lib/tasks/reset');\nconst { stashListTask } = require('./lib/tasks/stash-list');\nconst {\n   addSubModuleTask,\n   initSubModuleTask,\n   subModuleTask,\n   updateSubModuleTask,\n} = require('./lib/tasks/sub-module');\nconst { addAnnotatedTagTask, addTagTask, tagListTask } = require('./lib/tasks/tag');\nconst { straightThroughBufferTask, straightThroughStringTask } = require('./lib/tasks/task');\n\nfunction Git(options, plugins) {\n   this._executor = new GitExecutor(\n      options.binary,\n      options.baseDir,\n      new Scheduler(options.maxConcurrentProcesses),\n      plugins\n   );\n\n   this._trimmed = options.trimmed;\n}\n\n(Git.prototype = Object.create(SimpleGitApi.prototype)).constructor = Git;\n\n/**\n * Sets the path to a custom git binary, should either be `git` when there is an installation of git available on\n * the system path, or a fully qualified path to the executable.\n *\n * @param {string} command\n * @returns {Git}\n */\nGit.prototype.customBinary = function (command) {\n   this._executor.binary = command;\n   return this;\n};\n\n/**\n * Sets an environment variable for the spawned child process, either supply both a name and value as strings or\n * a single object to entirely replace the current environment variables.\n *\n * @param {string|Object} name\n * @param {string} [value]\n * @returns {Git}\n */\nGit.prototype.env = function (name, value) {\n   if (arguments.length === 1 && typeof name === 'object') {\n      this._executor.env = name;\n   } else {\n      (this._executor.env = this._executor.env || {})[name] = value;\n   }\n\n   return this;\n};\n\n/**\n * List the stash(s) of the local repo\n */\nGit.prototype.stashList = function (options) {\n   return this._runTask(\n      stashListTask(\n         trailingOptionsArgument(arguments) || {},\n         (filterArray(options) && options) || []\n      ),\n      trailingFunctionArgument(arguments)\n   );\n};\n\nfunction createCloneTask(api, task, repoPath, localPath) {\n   if (typeof repoPath !== 'string') {\n      return configurationErrorTask(`git.${api}() requires a string 'repoPath'`);\n   }\n\n   return task(repoPath, filterType(localPath, filterString), getTrailingOptions(arguments));\n}\n\n/**\n * Clone a git repo\n */\nGit.prototype.clone = function () {\n   return this._runTask(\n      createCloneTask('clone', cloneTask, ...arguments),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Mirror a git repo\n */\nGit.prototype.mirror = function () {\n   return this._runTask(\n      createCloneTask('mirror', cloneMirrorTask, ...arguments),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Moves one or more files to a new destination.\n *\n * @see https://git-scm.com/docs/git-mv\n *\n * @param {string|string[]} from\n * @param {string} to\n */\nGit.prototype.mv = function (from, to) {\n   return this._runTask(moveTask(from, to), trailingFunctionArgument(arguments));\n};\n\n/**\n * Internally uses pull and tags to get the list of tags then checks out the latest tag.\n *\n * @param {Function} [then]\n */\nGit.prototype.checkoutLatestTag = function (then) {\n   var git = this;\n   return this.pull(function () {\n      git.tags(function (err, tags) {\n         git.checkout(tags.latest, then);\n      });\n   });\n};\n\n/**\n * Pull the updated contents of the current repo\n */\nGit.prototype.pull = function (remote, branch, options, then) {\n   return this._runTask(\n      pullTask(\n         filterType(remote, filterString),\n         filterType(branch, filterString),\n         getTrailingOptions(arguments)\n      ),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Fetch the updated contents of the current repo.\n *\n * @example\n *   .fetch('upstream', 'master') // fetches from master on remote named upstream\n *   .fetch(function () {}) // runs fetch against default remote and branch and calls function\n *\n * @param {string} [remote]\n * @param {string} [branch]\n */\nGit.prototype.fetch = function (remote, branch) {\n   return this._runTask(\n      fetchTask(\n         filterType(remote, filterString),\n         filterType(branch, filterString),\n         getTrailingOptions(arguments)\n      ),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Disables/enables the use of the console for printing warnings and errors, by default messages are not shown in\n * a production environment.\n *\n * @param {boolean} silence\n * @returns {Git}\n */\nGit.prototype.silent = function (silence) {\n   console.warn(\n      'simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3'\n   );\n   return this;\n};\n\n/**\n * List all tags. When using git 2.7.0 or above, include an options object with `\"--sort\": \"property-name\"` to\n * sort the tags by that property instead of using the default semantic versioning sort.\n *\n * Note, supplying this option when it is not supported by your Git version will cause the operation to fail.\n *\n * @param {Object} [options]\n * @param {Function} [then]\n */\nGit.prototype.tags = function (options, then) {\n   return this._runTask(\n      tagListTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Rebases the current working copy. Options can be supplied either as an array of string parameters\n * to be sent to the `git rebase` command, or a standard options object.\n */\nGit.prototype.rebase = function () {\n   return this._runTask(\n      straightThroughStringTask(['rebase', ...getTrailingOptions(arguments)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Reset a repo\n */\nGit.prototype.reset = function (mode) {\n   return this._runTask(\n      resetTask(getResetMode(mode), getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Revert one or more commits in the local working copy\n */\nGit.prototype.revert = function (commit) {\n   const next = trailingFunctionArgument(arguments);\n\n   if (typeof commit !== 'string') {\n      return this._runTask(configurationErrorTask('Commit must be a string'), next);\n   }\n\n   return this._runTask(\n      straightThroughStringTask(['revert', ...getTrailingOptions(arguments, 0, true), commit]),\n      next\n   );\n};\n\n/**\n * Add a lightweight tag to the head of the current branch\n */\nGit.prototype.addTag = function (name) {\n   const task =\n      typeof name === 'string'\n         ? addTagTask(name)\n         : configurationErrorTask('Git.addTag requires a tag name');\n\n   return this._runTask(task, trailingFunctionArgument(arguments));\n};\n\n/**\n * Add an annotated tag to the head of the current branch\n */\nGit.prototype.addAnnotatedTag = function (tagName, tagMessage) {\n   return this._runTask(\n      addAnnotatedTagTask(tagName, tagMessage),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Delete a local branch\n */\nGit.prototype.deleteLocalBranch = function (branchName, forceDelete, then) {\n   return this._runTask(\n      deleteBranchTask(branchName, typeof forceDelete === 'boolean' ? forceDelete : false),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Delete one or more local branches\n */\nGit.prototype.deleteLocalBranches = function (branchNames, forceDelete, then) {\n   return this._runTask(\n      deleteBranchesTask(branchNames, typeof forceDelete === 'boolean' ? forceDelete : false),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * List all branches\n *\n * @param {Object | string[]} [options]\n * @param {Function} [then]\n */\nGit.prototype.branch = function (options, then) {\n   return this._runTask(\n      branchTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Return list of local branches\n *\n * @param {Function} [then]\n */\nGit.prototype.branchLocal = function (then) {\n   return this._runTask(branchLocalTask(), trailingFunctionArgument(arguments));\n};\n\n/**\n * Executes any command against the git binary.\n */\nGit.prototype.raw = function (commands) {\n   const createRestCommands = !Array.isArray(commands);\n   const command = [].slice.call(createRestCommands ? arguments : commands, 0);\n\n   for (let i = 0; i < command.length && createRestCommands; i++) {\n      if (!filterPrimitives(command[i])) {\n         command.splice(i, command.length - i);\n         break;\n      }\n   }\n\n   command.push(...getTrailingOptions(arguments, 0, true));\n\n   var next = trailingFunctionArgument(arguments);\n\n   if (!command.length) {\n      return this._runTask(\n         configurationErrorTask('Raw: must supply one or more command to execute'),\n         next\n      );\n   }\n\n   return this._runTask(straightThroughStringTask(command, this._trimmed), next);\n};\n\nGit.prototype.submoduleAdd = function (repo, path, then) {\n   return this._runTask(addSubModuleTask(repo, path), trailingFunctionArgument(arguments));\n};\n\nGit.prototype.submoduleUpdate = function (args, then) {\n   return this._runTask(\n      updateSubModuleTask(getTrailingOptions(arguments, true)),\n      trailingFunctionArgument(arguments)\n   );\n};\n\nGit.prototype.submoduleInit = function (args, then) {\n   return this._runTask(\n      initSubModuleTask(getTrailingOptions(arguments, true)),\n      trailingFunctionArgument(arguments)\n   );\n};\n\nGit.prototype.subModule = function (options, then) {\n   return this._runTask(\n      subModuleTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments)\n   );\n};\n\nGit.prototype.listRemote = function () {\n   return this._runTask(\n      listRemotesTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Adds a remote to the list of remotes.\n */\nGit.prototype.addRemote = function (remoteName, remoteRepo, then) {\n   return this._runTask(\n      addRemoteTask(remoteName, remoteRepo, getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Removes an entry by name from the list of remotes.\n */\nGit.prototype.removeRemote = function (remoteName, then) {\n   return this._runTask(removeRemoteTask(remoteName), trailingFunctionArgument(arguments));\n};\n\n/**\n * Gets the currently available remotes, setting the optional verbose argument to true includes additional\n * detail on the remotes themselves.\n */\nGit.prototype.getRemotes = function (verbose, then) {\n   return this._runTask(getRemotesTask(verbose === true), trailingFunctionArgument(arguments));\n};\n\n/**\n * Call any `git remote` function with arguments passed as an array of strings.\n *\n * @param {string[]} options\n * @param {Function} [then]\n */\nGit.prototype.remote = function (options, then) {\n   return this._runTask(\n      remoteTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Call any `git tag` function with arguments passed as an array of strings.\n *\n * @param {string[]} options\n * @param {Function} [then]\n */\nGit.prototype.tag = function (options, then) {\n   const command = getTrailingOptions(arguments);\n\n   if (command[0] !== 'tag') {\n      command.unshift('tag');\n   }\n\n   return this._runTask(straightThroughStringTask(command), trailingFunctionArgument(arguments));\n};\n\n/**\n * Updates repository server info\n *\n * @param {Function} [then]\n */\nGit.prototype.updateServerInfo = function (then) {\n   return this._runTask(\n      straightThroughStringTask(['update-server-info']),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Pushes the current tag changes to a remote which can be either a URL or named remote. When not specified uses the\n * default configured remote spec.\n *\n * @param {string} [remote]\n * @param {Function} [then]\n */\nGit.prototype.pushTags = function (remote, then) {\n   const task = pushTagsTask(\n      { remote: filterType(remote, filterString) },\n      getTrailingOptions(arguments)\n   );\n\n   return this._runTask(task, trailingFunctionArgument(arguments));\n};\n\n/**\n * Removes the named files from source control.\n */\nGit.prototype.rm = function (files) {\n   return this._runTask(\n      straightThroughStringTask(['rm', '-f', ...asArray(files)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Removes the named files from source control but keeps them on disk rather than deleting them entirely. To\n * completely remove the files, use `rm`.\n *\n * @param {string|string[]} files\n */\nGit.prototype.rmKeepLocal = function (files) {\n   return this._runTask(\n      straightThroughStringTask(['rm', '--cached', ...asArray(files)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Returns a list of objects in a tree based on commit hash. Passing in an object hash returns the object's content,\n * size, and type.\n *\n * Passing \"-p\" will instruct cat-file to determine the object type, and display its formatted contents.\n *\n * @param {string[]} [options]\n * @param {Function} [then]\n */\nGit.prototype.catFile = function (options, then) {\n   return this._catFile('utf-8', arguments);\n};\n\nGit.prototype.binaryCatFile = function () {\n   return this._catFile('buffer', arguments);\n};\n\nGit.prototype._catFile = function (format, args) {\n   var handler = trailingFunctionArgument(args);\n   var command = ['cat-file'];\n   var options = args[0];\n\n   if (typeof options === 'string') {\n      return this._runTask(\n         configurationErrorTask('Git.catFile: options must be supplied as an array of strings'),\n         handler\n      );\n   }\n\n   if (Array.isArray(options)) {\n      command.push.apply(command, options);\n   }\n\n   const task =\n      format === 'buffer' ? straightThroughBufferTask(command) : straightThroughStringTask(command);\n\n   return this._runTask(task, handler);\n};\n\nGit.prototype.diff = function (options, then) {\n   const task = filterString(options)\n      ? configurationErrorTask(\n           'git.diff: supplying options as a single string is no longer supported, switch to an array of strings'\n        )\n      : straightThroughStringTask(['diff', ...getTrailingOptions(arguments)]);\n\n   return this._runTask(task, trailingFunctionArgument(arguments));\n};\n\nGit.prototype.diffSummary = function () {\n   return this._runTask(\n      diffSummaryTask(getTrailingOptions(arguments, 1)),\n      trailingFunctionArgument(arguments)\n   );\n};\n\nGit.prototype.applyPatch = function (patches) {\n   const task = !filterStringOrStringArray(patches)\n      ? configurationErrorTask(\n           `git.applyPatch requires one or more string patches as the first argument`\n        )\n      : applyPatchTask(asArray(patches), getTrailingOptions([].slice.call(arguments, 1)));\n\n   return this._runTask(task, trailingFunctionArgument(arguments));\n};\n\nGit.prototype.revparse = function () {\n   const commands = ['rev-parse', ...getTrailingOptions(arguments, true)];\n   return this._runTask(\n      straightThroughStringTask(commands, true),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n */\nGit.prototype.clean = function (mode, options, then) {\n   const usingCleanOptionsArray = isCleanOptionsArray(mode);\n   const cleanMode =\n      (usingCleanOptionsArray && mode.join('')) || filterType(mode, filterString) || '';\n   const customArgs = getTrailingOptions([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));\n\n   return this._runTask(\n      cleanWithOptionsTask(cleanMode, customArgs),\n      trailingFunctionArgument(arguments)\n   );\n};\n\nGit.prototype.exec = function (then) {\n   const task = {\n      commands: [],\n      format: 'utf-8',\n      parser() {\n         if (typeof then === 'function') {\n            then();\n         }\n      },\n   };\n\n   return this._runTask(task);\n};\n\n/**\n * Clears the queue of pending commands and returns the wrapper instance for chaining.\n *\n * @returns {Git}\n */\nGit.prototype.clearQueue = function () {\n   // TODO:\n   // this._executor.clear();\n   return this;\n};\n\n/**\n * Check if a pathname or pathnames are excluded by .gitignore\n *\n * @param {string|string[]} pathnames\n * @param {Function} [then]\n */\nGit.prototype.checkIgnore = function (pathnames, then) {\n   return this._runTask(\n      checkIgnoreTask(asArray(filterType(pathnames, filterStringOrStringArray, []))),\n      trailingFunctionArgument(arguments)\n   );\n};\n\nGit.prototype.checkIsRepo = function (checkType, then) {\n   return this._runTask(\n      checkIsRepoTask(filterType(checkType, filterString)),\n      trailingFunctionArgument(arguments)\n   );\n};\n\nmodule.exports = Git;\n","import { pathspec } from './args/pathspec';\nimport { GitConstructError } from './errors/git-construct-error';\nimport { GitError } from './errors/git-error';\nimport { GitPluginError } from './errors/git-plugin-error';\nimport { GitResponseError } from './errors/git-response-error';\nimport { TaskConfigurationError } from './errors/task-configuration-error';\nimport { CheckRepoActions } from './tasks/check-is-repo';\nimport { CleanOptions } from './tasks/clean';\nimport { GitConfigScope } from './tasks/config';\nimport { grepQueryBuilder } from './tasks/grep';\nimport { ResetMode } from './tasks/reset';\n\nexport {\n   CheckRepoActions,\n   CleanOptions,\n   GitConfigScope,\n   GitConstructError,\n   GitError,\n   GitPluginError,\n   GitResponseError,\n   ResetMode,\n   TaskConfigurationError,\n   grepQueryBuilder,\n   pathspec,\n};\n","import { GitError } from './git-error';\nimport { SimpleGitOptions } from '../types';\n\n/**\n * The `GitConstructError` is thrown when an error occurs in the constructor\n * of the `simple-git` instance itself. Most commonly as a result of using\n * a `baseDir` option that points to a folder that either does not exist,\n * or cannot be read by the user the node script is running as.\n *\n * Check the `.message` property for more detail including the properties\n * passed to the constructor.\n */\nexport class GitConstructError extends GitError {\n   constructor(\n      public readonly config: SimpleGitOptions,\n      message: string\n   ) {\n      super(undefined, message);\n   }\n}\n","import { SimpleGitOptions, SimpleGitTask } from '../types';\nimport { GitError } from './git-error';\n\nexport class GitPluginError extends GitError {\n   constructor(\n      public task?: SimpleGitTask<any>,\n      public readonly plugin?: keyof SimpleGitOptions,\n      message?: string\n   ) {\n      super(task, message);\n      Object.setPrototypeOf(this, new.target.prototype);\n   }\n}\n","import { SimpleGitOptions } from '../types';\nimport { SimpleGitPlugin } from './simple-git-plugin';\nimport { GitPluginError } from '../errors/git-plugin-error';\n\nexport function abortPlugin(signal: SimpleGitOptions['abort']) {\n   if (!signal) {\n      return;\n   }\n\n   const onSpawnAfter: SimpleGitPlugin<'spawn.after'> = {\n      type: 'spawn.after',\n      action(_data, context) {\n         function kill() {\n            context.kill(new GitPluginError(undefined, 'abort', 'Abort signal received'));\n         }\n\n         signal.addEventListener('abort', kill);\n\n         context.spawned.on('close', () => signal.removeEventListener('abort', kill));\n      },\n   };\n\n   const onSpawnBefore: SimpleGitPlugin<'spawn.before'> = {\n      type: 'spawn.before',\n      action(_data, context) {\n         if (signal.aborted) {\n            context.kill(new GitPluginError(undefined, 'abort', 'Abort already signaled'));\n         }\n      },\n   };\n\n   return [onSpawnBefore, onSpawnAfter];\n}\n","import type { SimpleGitPlugin } from './simple-git-plugin';\n\nimport { GitPluginError } from '../errors/git-plugin-error';\nimport type { SimpleGitPluginConfig } from '../types';\n\nfunction isConfigSwitch(arg: string | unknown) {\n   return typeof arg === 'string' && arg.trim().toLowerCase() === '-c';\n}\n\nfunction preventProtocolOverride(arg: string, next: string) {\n   if (!isConfigSwitch(arg)) {\n      return;\n   }\n\n   if (!/^\\s*protocol(.[a-z]+)?.allow/.test(next)) {\n      return;\n   }\n\n   throw new GitPluginError(\n      undefined,\n      'unsafe',\n      'Configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol'\n   );\n}\n\nfunction preventUploadPack(arg: string, method: string) {\n   if (/^\\s*--(upload|receive)-pack/.test(arg)) {\n      throw new GitPluginError(\n         undefined,\n         'unsafe',\n         `Use of --upload-pack or --receive-pack is not permitted without enabling allowUnsafePack`\n      );\n   }\n\n   if (method === 'clone' && /^\\s*-u\\b/.test(arg)) {\n      throw new GitPluginError(\n         undefined,\n         'unsafe',\n         `Use of clone with option -u is not permitted without enabling allowUnsafePack`\n      );\n   }\n\n   if (method === 'push' && /^\\s*--exec\\b/.test(arg)) {\n      throw new GitPluginError(\n         undefined,\n         'unsafe',\n         `Use of push with option --exec is not permitted without enabling allowUnsafePack`\n      );\n   }\n}\n\nexport function blockUnsafeOperationsPlugin({\n   allowUnsafeProtocolOverride = false,\n   allowUnsafePack = false,\n}: SimpleGitPluginConfig['unsafe'] = {}): SimpleGitPlugin<'spawn.args'> {\n   return {\n      type: 'spawn.args',\n      action(args, context) {\n         args.forEach((current, index) => {\n            const next = index < args.length ? args[index + 1] : '';\n\n            allowUnsafeProtocolOverride || preventProtocolOverride(current, next);\n            allowUnsafePack || preventUploadPack(current, context.method);\n         });\n\n         return args;\n      },\n   };\n}\n","import { prefixedArray } from '../utils';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nexport function commandConfigPrefixingPlugin(\n   configuration: string[]\n): SimpleGitPlugin<'spawn.args'> {\n   const prefix = prefixedArray(configuration, '-c');\n\n   return {\n      type: 'spawn.args',\n      action(data) {\n         return [...prefix, ...data];\n      },\n   };\n}\n","import { deferred, DeferredPromise } from '@kwsites/promise-deferred';\nimport { SimpleGitPluginConfig } from '../types';\nimport { delay } from '../utils';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nconst never = deferred().promise;\n\nexport function completionDetectionPlugin({\n   onClose = true,\n   onExit = 50,\n}: SimpleGitPluginConfig['completion'] = {}): SimpleGitPlugin<'spawn.after'> {\n   function createEvents() {\n      let exitCode = -1;\n      const events = {\n         close: deferred(),\n         closeTimeout: deferred(),\n         exit: deferred(),\n         exitTimeout: deferred(),\n      };\n\n      const result = Promise.race([\n         onClose === false ? never : events.closeTimeout.promise,\n         onExit === false ? never : events.exitTimeout.promise,\n      ]);\n\n      configureTimeout(onClose, events.close, events.closeTimeout);\n      configureTimeout(onExit, events.exit, events.exitTimeout);\n\n      return {\n         close(code: number) {\n            exitCode = code;\n            events.close.done();\n         },\n         exit(code: number) {\n            exitCode = code;\n            events.exit.done();\n         },\n         get exitCode() {\n            return exitCode;\n         },\n         result,\n      };\n   }\n\n   function configureTimeout(\n      flag: boolean | number,\n      event: DeferredPromise<void>,\n      timeout: DeferredPromise<void>\n   ) {\n      if (flag === false) {\n         return;\n      }\n\n      (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);\n   }\n\n   return {\n      type: 'spawn.after',\n      async action(_data, { spawned, close }) {\n         const events = createEvents();\n\n         let deferClose = true;\n         let quickClose = () => void (deferClose = false);\n\n         spawned.stdout?.on('data', quickClose);\n         spawned.stderr?.on('data', quickClose);\n         spawned.on('error', quickClose);\n\n         spawned.on('close', (code: number) => events.close(code));\n         spawned.on('exit', (code: number) => events.exit(code));\n\n         try {\n            await events.result;\n            if (deferClose) {\n               await delay(50);\n            }\n            close(events.exitCode);\n         } catch (err) {\n            close(events.exitCode, err as Error);\n         }\n      },\n   };\n}\n","import { GitError } from '../errors/git-error';\nimport { GitExecutorResult, SimpleGitPluginConfig } from '../types';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\ntype TaskResult = Omit<GitExecutorResult, 'rejection'>;\n\nfunction isTaskError(result: TaskResult) {\n   return !!(result.exitCode && result.stdErr.length);\n}\n\nfunction getErrorMessage(result: TaskResult) {\n   return Buffer.concat([...result.stdOut, ...result.stdErr]);\n}\n\nexport function errorDetectionHandler(\n   overwrite = false,\n   isError = isTaskError,\n   errorMessage: (result: TaskResult) => Buffer | Error = getErrorMessage\n) {\n   return (error: Buffer | Error | undefined, result: TaskResult) => {\n      if ((!overwrite && error) || !isError(result)) {\n         return error;\n      }\n\n      return errorMessage(result);\n   };\n}\n\nexport function errorDetectionPlugin(\n   config: SimpleGitPluginConfig['errors']\n): SimpleGitPlugin<'task.error'> {\n   return {\n      type: 'task.error',\n      action(data, context) {\n         const error = config(data.error, {\n            stdErr: context.stdErr,\n            stdOut: context.stdOut,\n            exitCode: context.exitCode,\n         });\n\n         if (Buffer.isBuffer(error)) {\n            return { error: new GitError(undefined, error.toString('utf-8')) };\n         }\n\n         return {\n            error,\n         };\n      },\n   };\n}\n","import { SimpleGitPlugin, SimpleGitPluginType, SimpleGitPluginTypes } from './simple-git-plugin';\nimport { append, asArray } from '../utils';\n\nexport class PluginStore {\n   private plugins: Set<SimpleGitPlugin<SimpleGitPluginType>> = new Set();\n\n   public add<T extends SimpleGitPluginType>(\n      plugin: void | SimpleGitPlugin<T> | SimpleGitPlugin<T>[]\n   ) {\n      const plugins: SimpleGitPlugin<T>[] = [];\n\n      asArray(plugin).forEach((plugin) => plugin && this.plugins.add(append(plugins, plugin)));\n\n      return () => {\n         plugins.forEach((plugin) => this.plugins.delete(plugin));\n      };\n   }\n\n   public exec<T extends SimpleGitPluginType>(\n      type: T,\n      data: SimpleGitPluginTypes[T]['data'],\n      context: SimpleGitPluginTypes[T]['context']\n   ): typeof data {\n      let output = data;\n      const contextual = Object.freeze(Object.create(context));\n\n      for (const plugin of this.plugins) {\n         if (plugin.type === type) {\n            output = plugin.action(output, contextual);\n         }\n      }\n\n      return output;\n   }\n}\n","import { SimpleGitOptions } from '../types';\nimport { asNumber, including } from '../utils';\n\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nexport function progressMonitorPlugin(progress: Exclude<SimpleGitOptions['progress'], void>) {\n   const progressCommand = '--progress';\n   const progressMethods = ['checkout', 'clone', 'fetch', 'pull', 'push'];\n\n   const onProgress: SimpleGitPlugin<'spawn.after'> = {\n      type: 'spawn.after',\n      action(_data, context) {\n         if (!context.commands.includes(progressCommand)) {\n            return;\n         }\n\n         context.spawned.stderr?.on('data', (chunk: Buffer) => {\n            const message = /^([\\s\\S]+?):\\s*(\\d+)% \\((\\d+)\\/(\\d+)\\)/.exec(chunk.toString('utf8'));\n            if (!message) {\n               return;\n            }\n\n            progress({\n               method: context.method,\n               stage: progressEventStage(message[1]),\n               progress: asNumber(message[2]),\n               processed: asNumber(message[3]),\n               total: asNumber(message[4]),\n            });\n         });\n      },\n   };\n\n   const onArgs: SimpleGitPlugin<'spawn.args'> = {\n      type: 'spawn.args',\n      action(args, context) {\n         if (!progressMethods.includes(context.method)) {\n            return args;\n         }\n\n         return including(args, progressCommand);\n      },\n   };\n\n   return [onArgs, onProgress];\n}\n\nfunction progressEventStage(input: string) {\n   return String(input.toLowerCase().split(' ', 1)) || 'unknown';\n}\n","import { SpawnOptions } from 'child_process';\nimport { pick } from '../utils';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nexport function spawnOptionsPlugin(\n   spawnOptions: Partial<SpawnOptions>\n): SimpleGitPlugin<'spawn.options'> {\n   const options = pick(spawnOptions, ['uid', 'gid']);\n\n   return {\n      type: 'spawn.options',\n      action(data) {\n         return { ...options, ...data };\n      },\n   };\n}\n","import type { SimpleGitPlugin } from './simple-git-plugin';\n\nimport type { SimpleGitOptions } from '../types';\nimport { GitPluginError } from '../errors/git-plugin-error';\n\nexport function timeoutPlugin({\n   block,\n   stdErr = true,\n   stdOut = true,\n}: Exclude<SimpleGitOptions['timeout'], undefined>): SimpleGitPlugin<'spawn.after'> | void {\n   if (block > 0) {\n      return {\n         type: 'spawn.after',\n         action(_data, context) {\n            let timeout: NodeJS.Timeout;\n\n            function wait() {\n               timeout && clearTimeout(timeout);\n               timeout = setTimeout(kill, block);\n            }\n\n            function stop() {\n               context.spawned.stdout?.off('data', wait);\n               context.spawned.stderr?.off('data', wait);\n               context.spawned.off('exit', stop);\n               context.spawned.off('close', stop);\n               timeout && clearTimeout(timeout);\n            }\n\n            function kill() {\n               stop();\n               context.kill(new GitPluginError(undefined, 'timeout', `block timeout reached`));\n            }\n\n            stdOut && context.spawned.stdout?.on('data', wait);\n            stdErr && context.spawned.stderr?.on('data', wait);\n            context.spawned.on('exit', stop);\n            context.spawned.on('close', stop);\n\n            wait();\n         },\n      };\n   }\n}\n","import { SimpleGitPlugin } from './simple-git-plugin';\nimport { isPathSpec, toPaths } from '../args/pathspec';\n\nexport function suffixPathsPlugin(): SimpleGitPlugin<'spawn.args'> {\n   return {\n      type: 'spawn.args',\n      action(data) {\n         const prefix: string[] = [];\n         let suffix: undefined | string[];\n         function append(args: string[]) {\n            (suffix = suffix || []).push(...args);\n         }\n\n         for (let i = 0; i < data.length; i++) {\n            const param = data[i];\n\n            if (isPathSpec(param)) {\n               append(toPaths(param));\n               continue;\n            }\n\n            if (param === '--') {\n               append(\n                  data.slice(i + 1).flatMap((item) => (isPathSpec(item) && toPaths(item)) || item)\n               );\n               break;\n            }\n\n            prefix.push(param);\n         }\n\n         return !suffix ? prefix : [...prefix, '--', ...suffix.map(String)];\n      },\n   };\n}\n","import { SimpleGitFactory } from '../../typings';\n\nimport * as api from './api';\nimport {\n   abortPlugin,\n   blockUnsafeOperationsPlugin,\n   commandConfigPrefixingPlugin,\n   completionDetectionPlugin,\n   errorDetectionHandler,\n   errorDetectionPlugin,\n   PluginStore,\n   progressMonitorPlugin,\n   spawnOptionsPlugin,\n   timeoutPlugin,\n} from './plugins';\nimport { suffixPathsPlugin } from './plugins/suffix-paths.plugin';\nimport { createInstanceConfig, folderExists } from './utils';\nimport { SimpleGitOptions } from './types';\n\nconst Git = require('../git');\n\n/**\n * Adds the necessary properties to the supplied object to enable it for use as\n * the default export of a module.\n *\n * Eg: `module.exports = esModuleFactory({ something () {} })`\n */\nexport function esModuleFactory<T>(defaultExport: T) {\n   return Object.defineProperties(defaultExport, {\n      __esModule: { value: true },\n      default: { value: defaultExport },\n   }) as T & { __esModule: true; default: T };\n}\n\nexport function gitExportFactory(factory: SimpleGitFactory) {\n   return Object.assign(factory.bind(null), api);\n}\n\nexport function gitInstanceFactory(\n   baseDir?: string | Partial<SimpleGitOptions>,\n   options?: Partial<SimpleGitOptions>\n) {\n   const plugins = new PluginStore();\n   const config = createInstanceConfig(\n      (baseDir && (typeof baseDir === 'string' ? { baseDir } : baseDir)) || {},\n      options\n   );\n\n   if (!folderExists(config.baseDir)) {\n      throw new api.GitConstructError(\n         config,\n         `Cannot use simple-git on a directory that does not exist`\n      );\n   }\n\n   if (Array.isArray(config.config)) {\n      plugins.add(commandConfigPrefixingPlugin(config.config));\n   }\n\n   plugins.add(blockUnsafeOperationsPlugin(config.unsafe));\n   plugins.add(suffixPathsPlugin());\n   plugins.add(completionDetectionPlugin(config.completion));\n   config.abort && plugins.add(abortPlugin(config.abort));\n   config.progress && plugins.add(progressMonitorPlugin(config.progress));\n   config.timeout && plugins.add(timeoutPlugin(config.timeout));\n   config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));\n\n   plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));\n   config.errors && plugins.add(errorDetectionPlugin(config.errors));\n\n   return new Git(config, plugins);\n}\n","import { SimpleGit, SimpleGitOptions } from '../../../typings';\n\nimport { GitResponseError } from '../errors/git-response-error';\nimport { gitInstanceFactory } from '../git-factory';\nimport { SimpleGitTaskCallback } from '../types';\n\nconst functionNamesBuilderApi = ['customBinary', 'env', 'outputHandler', 'silent'];\n\nconst functionNamesPromiseApi = [\n   'add',\n   'addAnnotatedTag',\n   'addConfig',\n   'addRemote',\n   'addTag',\n   'applyPatch',\n   'binaryCatFile',\n   'branch',\n   'branchLocal',\n   'catFile',\n   'checkIgnore',\n   'checkIsRepo',\n   'checkout',\n   'checkoutBranch',\n   'checkoutLatestTag',\n   'checkoutLocalBranch',\n   'clean',\n   'clone',\n   'commit',\n   'cwd',\n   'deleteLocalBranch',\n   'deleteLocalBranches',\n   'diff',\n   'diffSummary',\n   'exec',\n   'fetch',\n   'getRemotes',\n   'init',\n   'listConfig',\n   'listRemote',\n   'log',\n   'merge',\n   'mergeFromTo',\n   'mirror',\n   'mv',\n   'pull',\n   'push',\n   'pushTags',\n   'raw',\n   'rebase',\n   'remote',\n   'removeRemote',\n   'reset',\n   'revert',\n   'revparse',\n   'rm',\n   'rmKeepLocal',\n   'show',\n   'stash',\n   'stashList',\n   'status',\n   'subModule',\n   'submoduleAdd',\n   'submoduleInit',\n   'submoduleUpdate',\n   'tag',\n   'tags',\n   'updateServerInfo',\n];\n\nexport function gitP(\n   ...args: [] | [string] | [Partial<SimpleGitOptions>] | [string, Partial<SimpleGitOptions>]\n): SimpleGit {\n   let git: any;\n\n   let chain = Promise.resolve();\n\n   try {\n      git = gitInstanceFactory(...args);\n   } catch (e) {\n      chain = Promise.reject(e);\n   }\n\n   function builderReturn() {\n      return promiseApi;\n   }\n\n   function chainReturn() {\n      return chain;\n   }\n\n   const promiseApi = [...functionNamesBuilderApi, ...functionNamesPromiseApi].reduce(\n      (api: any, name: string) => {\n         const isAsync = functionNamesPromiseApi.includes(name);\n\n         const valid = isAsync ? asyncWrapper(name, git) : syncWrapper(name, git, api);\n         const alternative = isAsync ? chainReturn : builderReturn;\n\n         Object.defineProperty(api, name, {\n            enumerable: false,\n            configurable: false,\n            value: git ? valid : alternative,\n         });\n\n         return api;\n      },\n      {}\n   );\n\n   return promiseApi as SimpleGit;\n\n   function asyncWrapper(fn: string, git: any): (...args: any[]) => Promise<any> {\n      return function (...args: any[]) {\n         if (typeof args[args.length] === 'function') {\n            throw new TypeError(\n               'Promise interface requires that handlers are not supplied inline, ' +\n                  'trailing function not allowed in call to ' +\n                  fn\n            );\n         }\n\n         return chain.then(function () {\n            return new Promise(function (resolve, reject) {\n               const callback: SimpleGitTaskCallback = (err: Error | null, result?: any) => {\n                  if (err) {\n                     return reject(toError(err));\n                  }\n\n                  resolve(result);\n               };\n               args.push(callback);\n\n               git[fn].apply(git, args);\n            });\n         });\n      };\n   }\n\n   function syncWrapper(fn: string, git: any, api: SimpleGit) {\n      return (...args: any[]) => {\n         git[fn](...args);\n\n         return api;\n      };\n   }\n}\n\nfunction toError(error: Error | string | any): Error {\n   if (error instanceof Error) {\n      return error;\n   }\n\n   if (typeof error === 'string') {\n      return new Error(error);\n   }\n\n   return new GitResponseError(error);\n}\n","import { gitInstanceFactory } from './lib/git-factory';\n\nexport { gitP } from './lib/runners/promise-wrapped';\nexport * from './lib/api';\n\nexport const simpleGit = gitInstanceFactory;\n\nexport default gitInstanceFactory;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}