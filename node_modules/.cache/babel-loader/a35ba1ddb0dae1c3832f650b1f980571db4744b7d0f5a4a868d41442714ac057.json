{"ast":null,"code":"import AsyncLock from 'async-lock';\nimport Hash from 'sha.js/sha1.js';\nimport crc32 from 'crc-32';\nimport pako from 'pako';\nimport pify from 'pify';\nimport ignore from 'ignore';\nimport cleanGitRef from 'clean-git-ref';\nimport diff3Merge from 'diff3';\n\n/**\n * @typedef {Object} GitProgressEvent\n * @property {string} phase\n * @property {number} loaded\n * @property {number} total\n */\n\n/**\n * @callback ProgressCallback\n * @param {GitProgressEvent} progress\n * @returns {void | Promise<void>}\n */\n\n/**\n * @typedef {Object} GitHttpRequest\n * @property {string} url - The URL to request\n * @property {string} [method='GET'] - The HTTP method to use\n * @property {Object<string, string>} [headers={}] - Headers to include in the HTTP request\n * @property {Object} [agent] - An HTTP or HTTPS agent that manages connections for the HTTP client (Node.js only)\n * @property {AsyncIterableIterator<Uint8Array>} [body] - An async iterator of Uint8Arrays that make up the body of POST requests\n * @property {ProgressCallback} [onProgress] - Reserved for future use (emitting `GitProgressEvent`s)\n * @property {object} [signal] - Reserved for future use (canceling a request)\n */\n\n/**\n * @typedef {Object} GitHttpResponse\n * @property {string} url - The final URL that was fetched after any redirects\n * @property {string} [method] - The HTTP method that was used\n * @property {Object<string, string>} [headers] - HTTP response headers\n * @property {AsyncIterableIterator<Uint8Array>} [body] - An async iterator of Uint8Arrays that make up the body of the response\n * @property {number} statusCode - The HTTP status code\n * @property {string} statusMessage - The HTTP status message\n */\n\n/**\n * @callback HttpFetch\n * @param {GitHttpRequest} request\n * @returns {Promise<GitHttpResponse>}\n */\n\n/**\n * @typedef {Object} HttpClient\n * @property {HttpFetch} request\n */\n\n/**\n * A git commit object.\n *\n * @typedef {Object} CommitObject\n * @property {string} message Commit message\n * @property {string} tree SHA-1 object id of corresponding file tree\n * @property {string[]} parent an array of zero or more SHA-1 object ids\n * @property {Object} author\n * @property {string} author.name The author's name\n * @property {string} author.email The author's email\n * @property {number} author.timestamp UTC Unix timestamp in seconds\n * @property {number} author.timezoneOffset Timezone difference from UTC in minutes\n * @property {Object} committer\n * @property {string} committer.name The committer's name\n * @property {string} committer.email The committer's email\n * @property {number} committer.timestamp UTC Unix timestamp in seconds\n * @property {number} committer.timezoneOffset Timezone difference from UTC in minutes\n * @property {string} [gpgsig] PGP signature (if present)\n */\n\n/**\n * An entry from a git tree object. Files are called 'blobs' and directories are called 'trees'.\n *\n * @typedef {Object} TreeEntry\n * @property {string} mode the 6 digit hexadecimal mode\n * @property {string} path the name of the file or directory\n * @property {string} oid the SHA-1 object id of the blob or tree\n * @property {'commit'|'blob'|'tree'} type the type of object\n */\n\n/**\n * A git tree object. Trees represent a directory snapshot.\n *\n * @typedef {TreeEntry[]} TreeObject\n */\n\n/**\n * A git annotated tag object.\n *\n * @typedef {Object} TagObject\n * @property {string} object SHA-1 object id of object being tagged\n * @property {'blob' | 'tree' | 'commit' | 'tag'} type the type of the object being tagged\n * @property {string} tag the tag name\n * @property {Object} tagger\n * @property {string} tagger.name the tagger's name\n * @property {string} tagger.email the tagger's email\n * @property {number} tagger.timestamp UTC Unix timestamp in seconds\n * @property {number} tagger.timezoneOffset timezone difference from UTC in minutes\n * @property {string} message tag message\n * @property {string} [gpgsig] PGP signature (if present)\n */\n\n/**\n * @typedef {Object} ReadCommitResult\n * @property {string} oid - SHA-1 object id of this commit\n * @property {CommitObject} commit - the parsed commit object\n * @property {string} payload - PGP signing payload\n */\n\n/**\n * @typedef {Object} ServerRef - This object has the following schema:\n * @property {string} ref - The name of the ref\n * @property {string} oid - The SHA-1 object id the ref points to\n * @property {string} [target] - The target ref pointed to by a symbolic ref\n * @property {string} [peeled] - If the oid is the SHA-1 object id of an annotated tag, this is the SHA-1 object id that the annotated tag points to\n */\n\n/**\n * @typedef Walker\n * @property {Symbol} Symbol('GitWalkerSymbol')\n */\n\n/**\n * Normalized subset of filesystem `stat` data:\n *\n * @typedef {Object} Stat\n * @property {number} ctimeSeconds\n * @property {number} ctimeNanoseconds\n * @property {number} mtimeSeconds\n * @property {number} mtimeNanoseconds\n * @property {number} dev\n * @property {number} ino\n * @property {number} mode\n * @property {number} uid\n * @property {number} gid\n * @property {number} size\n */\n\n/**\n * The `WalkerEntry` is an interface that abstracts computing many common tree / blob stats.\n *\n * @typedef {Object} WalkerEntry\n * @property {function(): Promise<'tree'|'blob'|'special'|'commit'>} type\n * @property {function(): Promise<number>} mode\n * @property {function(): Promise<string>} oid\n * @property {function(): Promise<Uint8Array|void>} content\n * @property {function(): Promise<Stat>} stat\n */\n\n/**\n * @typedef {Object} CallbackFsClient\n * @property {function} readFile - https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback\n * @property {function} writeFile - https://nodejs.org/api/fs.html#fs_fs_writefile_file_data_options_callback\n * @property {function} unlink - https://nodejs.org/api/fs.html#fs_fs_unlink_path_callback\n * @property {function} readdir - https://nodejs.org/api/fs.html#fs_fs_readdir_path_options_callback\n * @property {function} mkdir - https://nodejs.org/api/fs.html#fs_fs_mkdir_path_mode_callback\n * @property {function} rmdir - https://nodejs.org/api/fs.html#fs_fs_rmdir_path_callback\n * @property {function} stat - https://nodejs.org/api/fs.html#fs_fs_stat_path_options_callback\n * @property {function} lstat - https://nodejs.org/api/fs.html#fs_fs_lstat_path_options_callback\n * @property {function} [readlink] - https://nodejs.org/api/fs.html#fs_fs_readlink_path_options_callback\n * @property {function} [symlink] - https://nodejs.org/api/fs.html#fs_fs_symlink_target_path_type_callback\n * @property {function} [chmod] - https://nodejs.org/api/fs.html#fs_fs_chmod_path_mode_callback\n */\n\n/**\n * @typedef {Object} PromiseFsClient\n * @property {Object} promises\n * @property {function} promises.readFile - https://nodejs.org/api/fs.html#fs_fspromises_readfile_path_options\n * @property {function} promises.writeFile - https://nodejs.org/api/fs.html#fs_fspromises_writefile_file_data_options\n * @property {function} promises.unlink - https://nodejs.org/api/fs.html#fs_fspromises_unlink_path\n * @property {function} promises.readdir - https://nodejs.org/api/fs.html#fs_fspromises_readdir_path_options\n * @property {function} promises.mkdir - https://nodejs.org/api/fs.html#fs_fspromises_mkdir_path_options\n * @property {function} promises.rmdir - https://nodejs.org/api/fs.html#fs_fspromises_rmdir_path\n * @property {function} promises.stat - https://nodejs.org/api/fs.html#fs_fspromises_stat_path_options\n * @property {function} promises.lstat - https://nodejs.org/api/fs.html#fs_fspromises_lstat_path_options\n * @property {function} [promises.readlink] - https://nodejs.org/api/fs.html#fs_fspromises_readlink_path_options\n * @property {function} [promises.symlink] - https://nodejs.org/api/fs.html#fs_fspromises_symlink_target_path_type\n * @property {function} [promises.chmod] - https://nodejs.org/api/fs.html#fs_fspromises_chmod_path_mode\n */\n\n/**\n * @typedef {CallbackFsClient | PromiseFsClient} FsClient\n */\n\n/**\n * @callback MessageCallback\n * @param {string} message\n * @returns {void | Promise<void>}\n */\n\n/**\n * @typedef {Object} GitAuth\n * @property {string} [username]\n * @property {string} [password]\n * @property {Object<string, string>} [headers]\n * @property {boolean} [cancel] Tells git to throw a `UserCanceledError` (instead of an `HttpError`).\n */\n\n/**\n * @callback AuthCallback\n * @param {string} url\n * @param {GitAuth} auth Might have some values if the URL itself originally contained a username or password.\n * @returns {GitAuth | void | Promise<GitAuth | void>}\n */\n\n/**\n * @callback AuthFailureCallback\n * @param {string} url\n * @param {GitAuth} auth The credentials that failed\n * @returns {GitAuth | void | Promise<GitAuth | void>}\n */\n\n/**\n * @callback AuthSuccessCallback\n * @param {string} url\n * @param {GitAuth} auth\n * @returns {void | Promise<void>}\n */\n\n/**\n * @typedef {Object} SignParams\n * @property {string} payload - a plaintext message\n * @property {string} secretKey - an 'ASCII armor' encoded PGP key (technically can actually contain _multiple_ keys)\n */\n\n/**\n * @callback SignCallback\n * @param {SignParams} args\n * @return {{signature: string} | Promise<{signature: string}>} - an 'ASCII armor' encoded \"detached\" signature\n */\n\n/**\n * @typedef {Object} MergeDriverParams\n * @property {Array<string>} branches\n * @property {Array<string>} contents\n * @property {string} path\n */\n\n/**\n * @callback MergeDriverCallback\n * @param {MergeDriverParams} args\n * @return {{cleanMerge: boolean, mergedText: string} | Promise<{cleanMerge: boolean, mergedText: string}>}\n */\n\n/**\n * @callback WalkerMap\n * @param {string} filename\n * @param {WalkerEntry[]} entries\n * @returns {Promise<any>}\n */\n\n/**\n * @callback WalkerReduce\n * @param {any} parent\n * @param {any[]} children\n * @returns {Promise<any>}\n */\n\n/**\n * @callback WalkerIterateCallback\n * @param {WalkerEntry[]} entries\n * @returns {Promise<any[]>}\n */\n\n/**\n * @callback WalkerIterate\n * @param {WalkerIterateCallback} walk\n * @param {IterableIterator<WalkerEntry[]>} children\n * @returns {Promise<any[]>}\n */\n\n/**\n * @typedef {Object} RefUpdateStatus\n * @property {boolean} ok\n * @property {string} error\n */\n\n/**\n * @typedef {Object} PushResult\n * @property {boolean} ok\n * @property {?string} error\n * @property {Object<string, RefUpdateStatus>} refs\n * @property {Object<string, string>} [headers]\n */\n\n/**\n * @typedef {0|1} HeadStatus\n */\n\n/**\n * @typedef {0|1|2} WorkdirStatus\n */\n\n/**\n * @typedef {0|1|2|3} StageStatus\n */\n\n/**\n * @typedef {[string, HeadStatus, WorkdirStatus, StageStatus]} StatusRow\n */\n\nclass BaseError extends Error {\n  constructor(message) {\n    super(message);\n    // Setting this here allows TS to infer that all git errors have a `caller` property and\n    // that its type is string.\n    this.caller = '';\n  }\n  toJSON() {\n    // Error objects aren't normally serializable. So we do something about that.\n    return {\n      code: this.code,\n      data: this.data,\n      caller: this.caller,\n      message: this.message,\n      stack: this.stack\n    };\n  }\n  fromJSON(json) {\n    const e = new BaseError(json.message);\n    e.code = json.code;\n    e.data = json.data;\n    e.caller = json.caller;\n    e.stack = json.stack;\n    return e;\n  }\n  get isIsomorphicGitError() {\n    return true;\n  }\n}\nclass UnmergedPathsError extends BaseError {\n  /**\n   * @param {Array<string>} filepaths\n   */\n  constructor(filepaths) {\n    super(`Modifying the index is not possible because you have unmerged files: ${filepaths.toString}. Fix them up in the work tree, and then use 'git add/rm as appropriate to mark resolution and make a commit.`);\n    this.code = this.name = UnmergedPathsError.code;\n    this.data = {\n      filepaths\n    };\n  }\n}\n/** @type {'UnmergedPathsError'} */\nUnmergedPathsError.code = 'UnmergedPathsError';\nclass InternalError extends BaseError {\n  /**\n   * @param {string} message\n   */\n  constructor(message) {\n    super(`An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${message}`);\n    this.code = this.name = InternalError.code;\n    this.data = {\n      message\n    };\n  }\n}\n/** @type {'InternalError'} */\nInternalError.code = 'InternalError';\nclass UnsafeFilepathError extends BaseError {\n  /**\n   * @param {string} filepath\n   */\n  constructor(filepath) {\n    super(`The filepath \"${filepath}\" contains unsafe character sequences`);\n    this.code = this.name = UnsafeFilepathError.code;\n    this.data = {\n      filepath\n    };\n  }\n}\n/** @type {'UnsafeFilepathError'} */\nUnsafeFilepathError.code = 'UnsafeFilepathError';\n\n// Modeled after https://github.com/tjfontaine/node-buffercursor\n// but with the goal of being much lighter weight.\nclass BufferCursor {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this._start = 0;\n  }\n  eof() {\n    return this._start >= this.buffer.length;\n  }\n  tell() {\n    return this._start;\n  }\n  seek(n) {\n    this._start = n;\n  }\n  slice(n) {\n    const r = this.buffer.slice(this._start, this._start + n);\n    this._start += n;\n    return r;\n  }\n  toString(enc, length) {\n    const r = this.buffer.toString(enc, this._start, this._start + length);\n    this._start += length;\n    return r;\n  }\n  write(value, length, enc) {\n    const r = this.buffer.write(value, this._start, length, enc);\n    this._start += length;\n    return r;\n  }\n  copy(source, start, end) {\n    const r = source.copy(this.buffer, this._start, start, end);\n    this._start += r;\n    return r;\n  }\n  readUInt8() {\n    const r = this.buffer.readUInt8(this._start);\n    this._start += 1;\n    return r;\n  }\n  writeUInt8(value) {\n    const r = this.buffer.writeUInt8(value, this._start);\n    this._start += 1;\n    return r;\n  }\n  readUInt16BE() {\n    const r = this.buffer.readUInt16BE(this._start);\n    this._start += 2;\n    return r;\n  }\n  writeUInt16BE(value) {\n    const r = this.buffer.writeUInt16BE(value, this._start);\n    this._start += 2;\n    return r;\n  }\n  readUInt32BE() {\n    const r = this.buffer.readUInt32BE(this._start);\n    this._start += 4;\n    return r;\n  }\n  writeUInt32BE(value) {\n    const r = this.buffer.writeUInt32BE(value, this._start);\n    this._start += 4;\n    return r;\n  }\n}\nfunction compareStrings(a, b) {\n  // https://stackoverflow.com/a/40355107/2168416\n  return -(a < b) || +(a > b);\n}\nfunction comparePath(a, b) {\n  // https://stackoverflow.com/a/40355107/2168416\n  return compareStrings(a.path, b.path);\n}\n\n/**\n * From https://github.com/git/git/blob/master/Documentation/technical/index-format.txt\n *\n * 32-bit mode, split into (high to low bits)\n *\n *  4-bit object type\n *    valid values in binary are 1000 (regular file), 1010 (symbolic link)\n *    and 1110 (gitlink)\n *\n *  3-bit unused\n *\n *  9-bit unix permission. Only 0755 and 0644 are valid for regular files.\n *  Symbolic links and gitlinks have value 0 in this field.\n */\nfunction normalizeMode(mode) {\n  // Note: BrowserFS will use -1 for \"unknown\"\n  // I need to make it non-negative for these bitshifts to work.\n  let type = mode > 0 ? mode >> 12 : 0;\n  // If it isn't valid, assume it as a \"regular file\"\n  // 0100 = directory\n  // 1000 = regular file\n  // 1010 = symlink\n  // 1110 = gitlink\n  if (type !== 0b0100 && type !== 0b1000 && type !== 0b1010 && type !== 0b1110) {\n    type = 0b1000;\n  }\n  let permissions = mode & 0o777;\n  // Is the file executable? then 755. Else 644.\n  if (permissions & 0b001001001) {\n    permissions = 0o755;\n  } else {\n    permissions = 0o644;\n  }\n  // If it's not a regular file, scrub all permissions\n  if (type !== 0b1000) permissions = 0;\n  return (type << 12) + permissions;\n}\nconst MAX_UINT32 = 2 ** 32;\nfunction SecondsNanoseconds(givenSeconds, givenNanoseconds, milliseconds, date) {\n  if (givenSeconds !== undefined && givenNanoseconds !== undefined) {\n    return [givenSeconds, givenNanoseconds];\n  }\n  if (milliseconds === undefined) {\n    milliseconds = date.valueOf();\n  }\n  const seconds = Math.floor(milliseconds / 1000);\n  const nanoseconds = (milliseconds - seconds * 1000) * 1000000;\n  return [seconds, nanoseconds];\n}\nfunction normalizeStats(e) {\n  const [ctimeSeconds, ctimeNanoseconds] = SecondsNanoseconds(e.ctimeSeconds, e.ctimeNanoseconds, e.ctimeMs, e.ctime);\n  const [mtimeSeconds, mtimeNanoseconds] = SecondsNanoseconds(e.mtimeSeconds, e.mtimeNanoseconds, e.mtimeMs, e.mtime);\n  return {\n    ctimeSeconds: ctimeSeconds % MAX_UINT32,\n    ctimeNanoseconds: ctimeNanoseconds % MAX_UINT32,\n    mtimeSeconds: mtimeSeconds % MAX_UINT32,\n    mtimeNanoseconds: mtimeNanoseconds % MAX_UINT32,\n    dev: e.dev % MAX_UINT32,\n    ino: e.ino % MAX_UINT32,\n    mode: normalizeMode(e.mode % MAX_UINT32),\n    uid: e.uid % MAX_UINT32,\n    gid: e.gid % MAX_UINT32,\n    // size of -1 happens over a BrowserFS HTTP Backend that doesn't serve Content-Length headers\n    // (like the Karma webserver) because BrowserFS HTTP Backend uses HTTP HEAD requests to do fs.stat\n    size: e.size > -1 ? e.size % MAX_UINT32 : 0\n  };\n}\nfunction toHex(buffer) {\n  let hex = '';\n  for (const byte of new Uint8Array(buffer)) {\n    if (byte < 16) hex += '0';\n    hex += byte.toString(16);\n  }\n  return hex;\n}\n\n/* eslint-env node, browser */\n\nlet supportsSubtleSHA1 = null;\nasync function shasum(buffer) {\n  if (supportsSubtleSHA1 === null) {\n    supportsSubtleSHA1 = await testSubtleSHA1();\n  }\n  return supportsSubtleSHA1 ? subtleSHA1(buffer) : shasumSync(buffer);\n}\n\n// This is modeled after @dominictarr's \"shasum\" module,\n// but without the 'json-stable-stringify' dependency and\n// extra type-casting features.\nfunction shasumSync(buffer) {\n  return new Hash().update(buffer).digest('hex');\n}\nasync function subtleSHA1(buffer) {\n  const hash = await crypto.subtle.digest('SHA-1', buffer);\n  return toHex(hash);\n}\nasync function testSubtleSHA1() {\n  // I'm using a rather crude method of progressive enhancement, because\n  // some browsers that have crypto.subtle.digest don't actually implement SHA-1.\n  try {\n    const hash = await subtleSHA1(new Uint8Array([]));\n    if (hash === 'da39a3ee5e6b4b0d3255bfef95601890afd80709') return true;\n  } catch (_) {\n    // no bother\n  }\n  return false;\n}\n\n// Extract 1-bit assume-valid, 1-bit extended flag, 2-bit merge state flag, 12-bit path length flag\nfunction parseCacheEntryFlags(bits) {\n  return {\n    assumeValid: Boolean(bits & 0b1000000000000000),\n    extended: Boolean(bits & 0b0100000000000000),\n    stage: (bits & 0b0011000000000000) >> 12,\n    nameLength: bits & 0b0000111111111111\n  };\n}\nfunction renderCacheEntryFlags(entry) {\n  const flags = entry.flags;\n  // 1-bit extended flag (must be zero in version 2)\n  flags.extended = false;\n  // 12-bit name length if the length is less than 0xFFF; otherwise 0xFFF\n  // is stored in this field.\n  flags.nameLength = Math.min(Buffer.from(entry.path).length, 0xfff);\n  return (flags.assumeValid ? 0b1000000000000000 : 0) + (flags.extended ? 0b0100000000000000 : 0) + ((flags.stage & 0b11) << 12) + (flags.nameLength & 0b111111111111);\n}\nclass GitIndex {\n  /*::\n   _entries: Map<string, CacheEntry>\n   _dirty: boolean // Used to determine if index needs to be saved to filesystem\n   */\n  constructor(entries, unmergedPaths) {\n    this._dirty = false;\n    this._unmergedPaths = unmergedPaths || new Set();\n    this._entries = entries || new Map();\n  }\n  _addEntry(entry) {\n    if (entry.flags.stage === 0) {\n      entry.stages = [entry];\n      this._entries.set(entry.path, entry);\n      this._unmergedPaths.delete(entry.path);\n    } else {\n      let existingEntry = this._entries.get(entry.path);\n      if (!existingEntry) {\n        this._entries.set(entry.path, entry);\n        existingEntry = entry;\n      }\n      existingEntry.stages[entry.flags.stage] = entry;\n      this._unmergedPaths.add(entry.path);\n    }\n  }\n  static async from(buffer) {\n    if (Buffer.isBuffer(buffer)) {\n      return GitIndex.fromBuffer(buffer);\n    } else if (buffer === null) {\n      return new GitIndex(null);\n    } else {\n      throw new InternalError('invalid type passed to GitIndex.from');\n    }\n  }\n  static async fromBuffer(buffer) {\n    if (buffer.length === 0) {\n      throw new InternalError('Index file is empty (.git/index)');\n    }\n    const index = new GitIndex();\n    const reader = new BufferCursor(buffer);\n    const magic = reader.toString('utf8', 4);\n    if (magic !== 'DIRC') {\n      throw new InternalError(`Invalid dircache magic file number: ${magic}`);\n    }\n\n    // Verify shasum after we ensured that the file has a magic number\n    const shaComputed = await shasum(buffer.slice(0, -20));\n    const shaClaimed = buffer.slice(-20).toString('hex');\n    if (shaClaimed !== shaComputed) {\n      throw new InternalError(`Invalid checksum in GitIndex buffer: expected ${shaClaimed} but saw ${shaComputed}`);\n    }\n    const version = reader.readUInt32BE();\n    if (version !== 2) {\n      throw new InternalError(`Unsupported dircache version: ${version}`);\n    }\n    const numEntries = reader.readUInt32BE();\n    let i = 0;\n    while (!reader.eof() && i < numEntries) {\n      const entry = {};\n      entry.ctimeSeconds = reader.readUInt32BE();\n      entry.ctimeNanoseconds = reader.readUInt32BE();\n      entry.mtimeSeconds = reader.readUInt32BE();\n      entry.mtimeNanoseconds = reader.readUInt32BE();\n      entry.dev = reader.readUInt32BE();\n      entry.ino = reader.readUInt32BE();\n      entry.mode = reader.readUInt32BE();\n      entry.uid = reader.readUInt32BE();\n      entry.gid = reader.readUInt32BE();\n      entry.size = reader.readUInt32BE();\n      entry.oid = reader.slice(20).toString('hex');\n      const flags = reader.readUInt16BE();\n      entry.flags = parseCacheEntryFlags(flags);\n      // TODO: handle if (version === 3 && entry.flags.extended)\n      const pathlength = buffer.indexOf(0, reader.tell() + 1) - reader.tell();\n      if (pathlength < 1) {\n        throw new InternalError(`Got a path length of: ${pathlength}`);\n      }\n      // TODO: handle pathnames larger than 12 bits\n      entry.path = reader.toString('utf8', pathlength);\n\n      // Prevent malicious paths like \"..\\foo\"\n      if (entry.path.includes('..\\\\') || entry.path.includes('../')) {\n        throw new UnsafeFilepathError(entry.path);\n      }\n\n      // The next bit is awkward. We expect 1 to 8 null characters\n      // such that the total size of the entry is a multiple of 8 bits.\n      // (Hence subtract 12 bytes for the header.)\n      let padding = 8 - (reader.tell() - 12) % 8;\n      if (padding === 0) padding = 8;\n      while (padding--) {\n        const tmp = reader.readUInt8();\n        if (tmp !== 0) {\n          throw new InternalError(`Expected 1-8 null characters but got '${tmp}' after ${entry.path}`);\n        } else if (reader.eof()) {\n          throw new InternalError('Unexpected end of file');\n        }\n      }\n      // end of awkward part\n      entry.stages = [];\n      index._addEntry(entry);\n      i++;\n    }\n    return index;\n  }\n  get unmergedPaths() {\n    return [...this._unmergedPaths];\n  }\n  get entries() {\n    return [...this._entries.values()].sort(comparePath);\n  }\n  get entriesMap() {\n    return this._entries;\n  }\n  get entriesFlat() {\n    return [...this.entries].flatMap(entry => {\n      return entry.stages.length > 1 ? entry.stages.filter(x => x) : entry;\n    });\n  }\n  *[Symbol.iterator]() {\n    for (const entry of this.entries) {\n      yield entry;\n    }\n  }\n  insert({\n    filepath,\n    stats,\n    oid,\n    stage = 0\n  }) {\n    if (!stats) {\n      stats = {\n        ctimeSeconds: 0,\n        ctimeNanoseconds: 0,\n        mtimeSeconds: 0,\n        mtimeNanoseconds: 0,\n        dev: 0,\n        ino: 0,\n        mode: 0,\n        uid: 0,\n        gid: 0,\n        size: 0\n      };\n    }\n    stats = normalizeStats(stats);\n    const bfilepath = Buffer.from(filepath);\n    const entry = {\n      ctimeSeconds: stats.ctimeSeconds,\n      ctimeNanoseconds: stats.ctimeNanoseconds,\n      mtimeSeconds: stats.mtimeSeconds,\n      mtimeNanoseconds: stats.mtimeNanoseconds,\n      dev: stats.dev,\n      ino: stats.ino,\n      // We provide a fallback value for `mode` here because not all fs\n      // implementations assign it, but we use it in GitTree.\n      // '100644' is for a \"regular non-executable file\"\n      mode: stats.mode || 0o100644,\n      uid: stats.uid,\n      gid: stats.gid,\n      size: stats.size,\n      path: filepath,\n      oid: oid,\n      flags: {\n        assumeValid: false,\n        extended: false,\n        stage,\n        nameLength: bfilepath.length < 0xfff ? bfilepath.length : 0xfff\n      },\n      stages: []\n    };\n    this._addEntry(entry);\n    this._dirty = true;\n  }\n  delete({\n    filepath\n  }) {\n    if (this._entries.has(filepath)) {\n      this._entries.delete(filepath);\n    } else {\n      for (const key of this._entries.keys()) {\n        if (key.startsWith(filepath + '/')) {\n          this._entries.delete(key);\n        }\n      }\n    }\n    if (this._unmergedPaths.has(filepath)) {\n      this._unmergedPaths.delete(filepath);\n    }\n    this._dirty = true;\n  }\n  clear() {\n    this._entries.clear();\n    this._dirty = true;\n  }\n  has({\n    filepath\n  }) {\n    return this._entries.has(filepath);\n  }\n  render() {\n    return this.entries.map(entry => `${entry.mode.toString(8)} ${entry.oid}    ${entry.path}`).join('\\n');\n  }\n  static async _entryToBuffer(entry) {\n    const bpath = Buffer.from(entry.path);\n    // the fixed length + the filename + at least one null char => align by 8\n    const length = Math.ceil((62 + bpath.length + 1) / 8) * 8;\n    const written = Buffer.alloc(length);\n    const writer = new BufferCursor(written);\n    const stat = normalizeStats(entry);\n    writer.writeUInt32BE(stat.ctimeSeconds);\n    writer.writeUInt32BE(stat.ctimeNanoseconds);\n    writer.writeUInt32BE(stat.mtimeSeconds);\n    writer.writeUInt32BE(stat.mtimeNanoseconds);\n    writer.writeUInt32BE(stat.dev);\n    writer.writeUInt32BE(stat.ino);\n    writer.writeUInt32BE(stat.mode);\n    writer.writeUInt32BE(stat.uid);\n    writer.writeUInt32BE(stat.gid);\n    writer.writeUInt32BE(stat.size);\n    writer.write(entry.oid, 20, 'hex');\n    writer.writeUInt16BE(renderCacheEntryFlags(entry));\n    writer.write(entry.path, bpath.length, 'utf8');\n    return written;\n  }\n  async toObject() {\n    const header = Buffer.alloc(12);\n    const writer = new BufferCursor(header);\n    writer.write('DIRC', 4, 'utf8');\n    writer.writeUInt32BE(2);\n    writer.writeUInt32BE(this.entriesFlat.length);\n    let entryBuffers = [];\n    for (const entry of this.entries) {\n      entryBuffers.push(GitIndex._entryToBuffer(entry));\n      if (entry.stages.length > 1) {\n        for (const stage of entry.stages) {\n          if (stage && stage !== entry) {\n            entryBuffers.push(GitIndex._entryToBuffer(stage));\n          }\n        }\n      }\n    }\n    entryBuffers = await Promise.all(entryBuffers);\n    const body = Buffer.concat(entryBuffers);\n    const main = Buffer.concat([header, body]);\n    const sum = await shasum(main);\n    return Buffer.concat([main, Buffer.from(sum, 'hex')]);\n  }\n}\nfunction compareStats(entry, stats) {\n  // Comparison based on the description in Paragraph 4 of\n  // https://www.kernel.org/pub/software/scm/git/docs/technical/racy-git.txt\n  const e = normalizeStats(entry);\n  const s = normalizeStats(stats);\n  const staleness = e.mode !== s.mode || e.mtimeSeconds !== s.mtimeSeconds || e.ctimeSeconds !== s.ctimeSeconds || e.uid !== s.uid || e.gid !== s.gid || e.ino !== s.ino || e.size !== s.size;\n  return staleness;\n}\n\n// import LockManager from 'travix-lock-manager'\n\n// import Lock from '../utils.js'\n\n// const lm = new LockManager()\nlet lock = null;\nconst IndexCache = Symbol('IndexCache');\nfunction createCache() {\n  return {\n    map: new Map(),\n    stats: new Map()\n  };\n}\nasync function updateCachedIndexFile(fs, filepath, cache) {\n  const stat = await fs.lstat(filepath);\n  const rawIndexFile = await fs.read(filepath);\n  const index = await GitIndex.from(rawIndexFile);\n  // cache the GitIndex object so we don't need to re-read it every time.\n  cache.map.set(filepath, index);\n  // Save the stat data for the index so we know whether the cached file is stale (modified by an outside process).\n  cache.stats.set(filepath, stat);\n}\n\n// Determine whether our copy of the index file is stale\nasync function isIndexStale(fs, filepath, cache) {\n  const savedStats = cache.stats.get(filepath);\n  if (savedStats === undefined) return true;\n  const currStats = await fs.lstat(filepath);\n  if (savedStats === null) return false;\n  if (currStats === null) return false;\n  return compareStats(savedStats, currStats);\n}\nclass GitIndexManager {\n  /**\n   *\n   * @param {object} opts\n   * @param {import('../models/FileSystem.js').FileSystem} opts.fs\n   * @param {string} opts.gitdir\n   * @param {object} opts.cache\n   * @param {bool} opts.allowUnmerged\n   * @param {function(GitIndex): any} closure\n   */\n  static async acquire({\n    fs,\n    gitdir,\n    cache,\n    allowUnmerged = true\n  }, closure) {\n    if (!cache[IndexCache]) cache[IndexCache] = createCache();\n    const filepath = `${gitdir}/index`;\n    if (lock === null) lock = new AsyncLock({\n      maxPending: Infinity\n    });\n    let result;\n    let unmergedPaths = [];\n    await lock.acquire(filepath, async () => {\n      // Acquire a file lock while we're reading the index\n      // to make sure other processes aren't writing to it\n      // simultaneously, which could result in a corrupted index.\n      // const fileLock = await Lock(filepath)\n      if (await isIndexStale(fs, filepath, cache[IndexCache])) {\n        await updateCachedIndexFile(fs, filepath, cache[IndexCache]);\n      }\n      const index = cache[IndexCache].map.get(filepath);\n      unmergedPaths = index.unmergedPaths;\n      if (unmergedPaths.length && !allowUnmerged) throw new UnmergedPathsError(unmergedPaths);\n      result = await closure(index);\n      if (index._dirty) {\n        // Acquire a file lock while we're writing the index file\n        // let fileLock = await Lock(filepath)\n        const buffer = await index.toObject();\n        await fs.write(filepath, buffer);\n        // Update cached stat value\n        cache[IndexCache].stats.set(filepath, await fs.lstat(filepath));\n        index._dirty = false;\n      }\n    });\n    return result;\n  }\n}\nfunction basename(path) {\n  const last = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\\\'));\n  if (last > -1) {\n    path = path.slice(last + 1);\n  }\n  return path;\n}\nfunction dirname(path) {\n  const last = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\\\'));\n  if (last === -1) return '.';\n  if (last === 0) return '/';\n  return path.slice(0, last);\n}\n\n/*::\ntype Node = {\n  type: string,\n  fullpath: string,\n  basename: string,\n  metadata: Object, // mode, oid\n  parent?: Node,\n  children: Array<Node>\n}\n*/\n\nfunction flatFileListToDirectoryStructure(files) {\n  const inodes = new Map();\n  const mkdir = function (name) {\n    if (!inodes.has(name)) {\n      const dir = {\n        type: 'tree',\n        fullpath: name,\n        basename: basename(name),\n        metadata: {},\n        children: []\n      };\n      inodes.set(name, dir);\n      // This recursively generates any missing parent folders.\n      // We do it after we've added the inode to the set so that\n      // we don't recurse infinitely trying to create the root '.' dirname.\n      dir.parent = mkdir(dirname(name));\n      if (dir.parent && dir.parent !== dir) dir.parent.children.push(dir);\n    }\n    return inodes.get(name);\n  };\n  const mkfile = function (name, metadata) {\n    if (!inodes.has(name)) {\n      const file = {\n        type: 'blob',\n        fullpath: name,\n        basename: basename(name),\n        metadata: metadata,\n        // This recursively generates any missing parent folders.\n        parent: mkdir(dirname(name)),\n        children: []\n      };\n      if (file.parent) file.parent.children.push(file);\n      inodes.set(name, file);\n    }\n    return inodes.get(name);\n  };\n  mkdir('.');\n  for (const file of files) {\n    mkfile(file.path, file);\n  }\n  return inodes;\n}\n\n/**\n *\n * @param {number} mode\n */\nfunction mode2type(mode) {\n  // prettier-ignore\n  switch (mode) {\n    case 0o040000:\n      return 'tree';\n    case 0o100644:\n      return 'blob';\n    case 0o100755:\n      return 'blob';\n    case 0o120000:\n      return 'blob';\n    case 0o160000:\n      return 'commit';\n  }\n  throw new InternalError(`Unexpected GitTree entry mode: ${mode.toString(8)}`);\n}\nclass GitWalkerIndex {\n  constructor({\n    fs,\n    gitdir,\n    cache\n  }) {\n    this.treePromise = GitIndexManager.acquire({\n      fs,\n      gitdir,\n      cache\n    }, async function (index) {\n      return flatFileListToDirectoryStructure(index.entries);\n    });\n    const walker = this;\n    this.ConstructEntry = class StageEntry {\n      constructor(fullpath) {\n        this._fullpath = fullpath;\n        this._type = false;\n        this._mode = false;\n        this._stat = false;\n        this._oid = false;\n      }\n      async type() {\n        return walker.type(this);\n      }\n      async mode() {\n        return walker.mode(this);\n      }\n      async stat() {\n        return walker.stat(this);\n      }\n      async content() {\n        return walker.content(this);\n      }\n      async oid() {\n        return walker.oid(this);\n      }\n    };\n  }\n  async readdir(entry) {\n    const filepath = entry._fullpath;\n    const tree = await this.treePromise;\n    const inode = tree.get(filepath);\n    if (!inode) return null;\n    if (inode.type === 'blob') return null;\n    if (inode.type !== 'tree') {\n      throw new Error(`ENOTDIR: not a directory, scandir '${filepath}'`);\n    }\n    const names = inode.children.map(inode => inode.fullpath);\n    names.sort(compareStrings);\n    return names;\n  }\n  async type(entry) {\n    if (entry._type === false) {\n      await entry.stat();\n    }\n    return entry._type;\n  }\n  async mode(entry) {\n    if (entry._mode === false) {\n      await entry.stat();\n    }\n    return entry._mode;\n  }\n  async stat(entry) {\n    if (entry._stat === false) {\n      const tree = await this.treePromise;\n      const inode = tree.get(entry._fullpath);\n      if (!inode) {\n        throw new Error(`ENOENT: no such file or directory, lstat '${entry._fullpath}'`);\n      }\n      const stats = inode.type === 'tree' ? {} : normalizeStats(inode.metadata);\n      entry._type = inode.type === 'tree' ? 'tree' : mode2type(stats.mode);\n      entry._mode = stats.mode;\n      if (inode.type === 'tree') {\n        entry._stat = undefined;\n      } else {\n        entry._stat = stats;\n      }\n    }\n    return entry._stat;\n  }\n  async content(_entry) {\n    // Cannot get content for an index entry\n  }\n  async oid(entry) {\n    if (entry._oid === false) {\n      const tree = await this.treePromise;\n      const inode = tree.get(entry._fullpath);\n      entry._oid = inode.metadata.oid;\n    }\n    return entry._oid;\n  }\n}\n\n// This is part of an elaborate system to facilitate code-splitting / tree-shaking.\n// commands/walk.js can depend on only this, and the actual Walker classes exported\n// can be opaque - only having a single property (this symbol) that is not enumerable,\n// and thus the constructor can be passed as an argument to walk while being \"unusable\"\n// outside of it.\nconst GitWalkSymbol = Symbol('GitWalkSymbol');\n\n// @ts-check\n\n/**\n * @returns {Walker}\n */\nfunction STAGE() {\n  const o = Object.create(null);\n  Object.defineProperty(o, GitWalkSymbol, {\n    value: function ({\n      fs,\n      gitdir,\n      cache\n    }) {\n      return new GitWalkerIndex({\n        fs,\n        gitdir,\n        cache\n      });\n    }\n  });\n  Object.freeze(o);\n  return o;\n}\n\n// @ts-check\n\nclass NotFoundError extends BaseError {\n  /**\n   * @param {string} what\n   */\n  constructor(what) {\n    super(`Could not find ${what}.`);\n    this.code = this.name = NotFoundError.code;\n    this.data = {\n      what\n    };\n  }\n}\n/** @type {'NotFoundError'} */\nNotFoundError.code = 'NotFoundError';\nclass ObjectTypeError extends BaseError {\n  /**\n   * @param {string} oid\n   * @param {'blob'|'commit'|'tag'|'tree'} actual\n   * @param {'blob'|'commit'|'tag'|'tree'} expected\n   * @param {string} [filepath]\n   */\n  constructor(oid, actual, expected, filepath) {\n    super(`Object ${oid} ${filepath ? `at ${filepath}` : ''}was anticipated to be a ${expected} but it is a ${actual}.`);\n    this.code = this.name = ObjectTypeError.code;\n    this.data = {\n      oid,\n      actual,\n      expected,\n      filepath\n    };\n  }\n}\n/** @type {'ObjectTypeError'} */\nObjectTypeError.code = 'ObjectTypeError';\nclass InvalidOidError extends BaseError {\n  /**\n   * @param {string} value\n   */\n  constructor(value) {\n    super(`Expected a 40-char hex object id but saw \"${value}\".`);\n    this.code = this.name = InvalidOidError.code;\n    this.data = {\n      value\n    };\n  }\n}\n/** @type {'InvalidOidError'} */\nInvalidOidError.code = 'InvalidOidError';\nclass NoRefspecError extends BaseError {\n  /**\n   * @param {string} remote\n   */\n  constructor(remote) {\n    super(`Could not find a fetch refspec for remote \"${remote}\". Make sure the config file has an entry like the following:\n[remote \"${remote}\"]\n\\tfetch = +refs/heads/*:refs/remotes/origin/*\n`);\n    this.code = this.name = NoRefspecError.code;\n    this.data = {\n      remote\n    };\n  }\n}\n/** @type {'NoRefspecError'} */\nNoRefspecError.code = 'NoRefspecError';\nclass GitPackedRefs {\n  constructor(text) {\n    this.refs = new Map();\n    this.parsedConfig = [];\n    if (text) {\n      let key = null;\n      this.parsedConfig = text.trim().split('\\n').map(line => {\n        if (/^\\s*#/.test(line)) {\n          return {\n            line,\n            comment: true\n          };\n        }\n        const i = line.indexOf(' ');\n        if (line.startsWith('^')) {\n          // This is a oid for the commit associated with the annotated tag immediately preceding this line.\n          // Trim off the '^'\n          const value = line.slice(1);\n          // The tagname^{} syntax is based on the output of `git show-ref --tags -d`\n          this.refs.set(key + '^{}', value);\n          return {\n            line,\n            ref: key,\n            peeled: value\n          };\n        } else {\n          // This is an oid followed by the ref name\n          const value = line.slice(0, i);\n          key = line.slice(i + 1);\n          this.refs.set(key, value);\n          return {\n            line,\n            ref: key,\n            oid: value\n          };\n        }\n      });\n    }\n    return this;\n  }\n  static from(text) {\n    return new GitPackedRefs(text);\n  }\n  delete(ref) {\n    this.parsedConfig = this.parsedConfig.filter(entry => entry.ref !== ref);\n    this.refs.delete(ref);\n  }\n  toString() {\n    return this.parsedConfig.map(({\n      line\n    }) => line).join('\\n') + '\\n';\n  }\n}\nclass GitRefSpec {\n  constructor({\n    remotePath,\n    localPath,\n    force,\n    matchPrefix\n  }) {\n    Object.assign(this, {\n      remotePath,\n      localPath,\n      force,\n      matchPrefix\n    });\n  }\n  static from(refspec) {\n    const [forceMatch, remotePath, remoteGlobMatch, localPath, localGlobMatch] = refspec.match(/^(\\+?)(.*?)(\\*?):(.*?)(\\*?)$/).slice(1);\n    const force = forceMatch === '+';\n    const remoteIsGlob = remoteGlobMatch === '*';\n    const localIsGlob = localGlobMatch === '*';\n    // validate\n    // TODO: Make this check more nuanced, and depend on whether this is a fetch refspec or a push refspec\n    if (remoteIsGlob !== localIsGlob) {\n      throw new InternalError('Invalid refspec');\n    }\n    return new GitRefSpec({\n      remotePath,\n      localPath,\n      force,\n      matchPrefix: remoteIsGlob\n    });\n    // TODO: We need to run resolveRef on both paths to expand them to their full name.\n  }\n  translate(remoteBranch) {\n    if (this.matchPrefix) {\n      if (remoteBranch.startsWith(this.remotePath)) {\n        return this.localPath + remoteBranch.replace(this.remotePath, '');\n      }\n    } else {\n      if (remoteBranch === this.remotePath) return this.localPath;\n    }\n    return null;\n  }\n  reverseTranslate(localBranch) {\n    if (this.matchPrefix) {\n      if (localBranch.startsWith(this.localPath)) {\n        return this.remotePath + localBranch.replace(this.localPath, '');\n      }\n    } else {\n      if (localBranch === this.localPath) return this.remotePath;\n    }\n    return null;\n  }\n}\nclass GitRefSpecSet {\n  constructor(rules = []) {\n    this.rules = rules;\n  }\n  static from(refspecs) {\n    const rules = [];\n    for (const refspec of refspecs) {\n      rules.push(GitRefSpec.from(refspec)); // might throw\n    }\n    return new GitRefSpecSet(rules);\n  }\n  add(refspec) {\n    const rule = GitRefSpec.from(refspec); // might throw\n    this.rules.push(rule);\n  }\n  translate(remoteRefs) {\n    const result = [];\n    for (const rule of this.rules) {\n      for (const remoteRef of remoteRefs) {\n        const localRef = rule.translate(remoteRef);\n        if (localRef) {\n          result.push([remoteRef, localRef]);\n        }\n      }\n    }\n    return result;\n  }\n  translateOne(remoteRef) {\n    let result = null;\n    for (const rule of this.rules) {\n      const localRef = rule.translate(remoteRef);\n      if (localRef) {\n        result = localRef;\n      }\n    }\n    return result;\n  }\n  localNamespaces() {\n    return this.rules.filter(rule => rule.matchPrefix).map(rule => rule.localPath.replace(/\\/$/, ''));\n  }\n}\nfunction compareRefNames(a, b) {\n  // https://stackoverflow.com/a/40355107/2168416\n  const _a = a.replace(/\\^\\{\\}$/, '');\n  const _b = b.replace(/\\^\\{\\}$/, '');\n  const tmp = -(_a < _b) || +(_a > _b);\n  if (tmp === 0) {\n    return a.endsWith('^{}') ? 1 : -1;\n  }\n  return tmp;\n}\nfunction normalizePath(path) {\n  return path.replace(/\\/\\.\\//g, '/') // Replace '/./' with '/'\n  .replace(/\\/{2,}/g, '/') // Replace consecutive '/'\n  .replace(/^\\/\\.$/, '/') // if path === '/.' return '/'\n  .replace(/^\\.\\/$/, '.') // if path === './' return '.'\n  .replace(/^\\.\\//, '') // Remove leading './'\n  .replace(/\\/\\.$/, '') // Remove trailing '/.'\n  .replace(/(.+)\\/$/, '$1') // Remove trailing '/'\n  .replace(/^$/, '.'); // if path === '' return '.'\n}\n\n// For some reason path.posix.join is undefined in webpack\n\nfunction join(...parts) {\n  return normalizePath(parts.map(normalizePath).join('/'));\n}\n\n// This is straight from parse_unit_factor in config.c of canonical git\nconst num = val => {\n  val = val.toLowerCase();\n  let n = parseInt(val);\n  if (val.endsWith('k')) n *= 1024;\n  if (val.endsWith('m')) n *= 1024 * 1024;\n  if (val.endsWith('g')) n *= 1024 * 1024 * 1024;\n  return n;\n};\n\n// This is straight from git_parse_maybe_bool_text in config.c of canonical git\nconst bool = val => {\n  val = val.trim().toLowerCase();\n  if (val === 'true' || val === 'yes' || val === 'on') return true;\n  if (val === 'false' || val === 'no' || val === 'off') return false;\n  throw Error(`Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ${val}`);\n};\nconst schema = {\n  core: {\n    filemode: bool,\n    bare: bool,\n    logallrefupdates: bool,\n    symlinks: bool,\n    ignorecase: bool,\n    bigFileThreshold: num\n  }\n};\n\n// https://git-scm.com/docs/git-config#_syntax\n\n// section starts with [ and ends with ]\n// section is alphanumeric (ASCII) with - and .\n// section is case insensitive\n// subsection is optionnal\n// subsection is specified after section and one or more spaces\n// subsection is specified between double quotes\nconst SECTION_LINE_REGEX = /^\\[([A-Za-z0-9-.]+)(?: \"(.*)\")?\\]$/;\nconst SECTION_REGEX = /^[A-Za-z0-9-.]+$/;\n\n// variable lines contain a name, and equal sign and then a value\n// variable lines can also only contain a name (the implicit value is a boolean true)\n// variable name is alphanumeric (ASCII) with -\n// variable name starts with an alphabetic character\n// variable name is case insensitive\nconst VARIABLE_LINE_REGEX = /^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/;\nconst VARIABLE_NAME_REGEX = /^[A-Za-z][A-Za-z-]*$/;\nconst VARIABLE_VALUE_COMMENT_REGEX = /^(.*?)( *[#;].*)$/;\nconst extractSectionLine = line => {\n  const matches = SECTION_LINE_REGEX.exec(line);\n  if (matches != null) {\n    const [section, subsection] = matches.slice(1);\n    return [section, subsection];\n  }\n  return null;\n};\nconst extractVariableLine = line => {\n  const matches = VARIABLE_LINE_REGEX.exec(line);\n  if (matches != null) {\n    const [name, rawValue = 'true'] = matches.slice(1);\n    const valueWithoutComments = removeComments(rawValue);\n    const valueWithoutQuotes = removeQuotes(valueWithoutComments);\n    return [name, valueWithoutQuotes];\n  }\n  return null;\n};\nconst removeComments = rawValue => {\n  const commentMatches = VARIABLE_VALUE_COMMENT_REGEX.exec(rawValue);\n  if (commentMatches == null) {\n    return rawValue;\n  }\n  const [valueWithoutComment, comment] = commentMatches.slice(1);\n  // if odd number of quotes before and after comment => comment is escaped\n  if (hasOddNumberOfQuotes(valueWithoutComment) && hasOddNumberOfQuotes(comment)) {\n    return `${valueWithoutComment}${comment}`;\n  }\n  return valueWithoutComment;\n};\nconst hasOddNumberOfQuotes = text => {\n  const numberOfQuotes = (text.match(/(?:^|[^\\\\])\"/g) || []).length;\n  return numberOfQuotes % 2 !== 0;\n};\nconst removeQuotes = text => {\n  return text.split('').reduce((newText, c, idx, text) => {\n    const isQuote = c === '\"' && text[idx - 1] !== '\\\\';\n    const isEscapeForQuote = c === '\\\\' && text[idx + 1] === '\"';\n    if (isQuote || isEscapeForQuote) {\n      return newText;\n    }\n    return newText + c;\n  }, '');\n};\nconst lower = text => {\n  return text != null ? text.toLowerCase() : null;\n};\nconst getPath = (section, subsection, name) => {\n  return [lower(section), subsection, lower(name)].filter(a => a != null).join('.');\n};\nconst normalizePath$1 = path => {\n  const pathSegments = path.split('.');\n  const section = pathSegments.shift();\n  const name = pathSegments.pop();\n  const subsection = pathSegments.length ? pathSegments.join('.') : undefined;\n  return {\n    section,\n    subsection,\n    name,\n    path: getPath(section, subsection, name),\n    sectionPath: getPath(section, subsection, null)\n  };\n};\nconst findLastIndex = (array, callback) => {\n  return array.reduce((lastIndex, item, index) => {\n    return callback(item) ? index : lastIndex;\n  }, -1);\n};\n\n// Note: there are a LOT of edge cases that aren't covered (e.g. keys in sections that also\n// have subsections, [include] directives, etc.\nclass GitConfig {\n  constructor(text) {\n    let section = null;\n    let subsection = null;\n    this.parsedConfig = text.split('\\n').map(line => {\n      let name = null;\n      let value = null;\n      const trimmedLine = line.trim();\n      const extractedSection = extractSectionLine(trimmedLine);\n      const isSection = extractedSection != null;\n      if (isSection) {\n        ;\n        [section, subsection] = extractedSection;\n      } else {\n        const extractedVariable = extractVariableLine(trimmedLine);\n        const isVariable = extractedVariable != null;\n        if (isVariable) {\n          ;\n          [name, value] = extractedVariable;\n        }\n      }\n      const path = getPath(section, subsection, name);\n      return {\n        line,\n        isSection,\n        section,\n        subsection,\n        name,\n        value,\n        path\n      };\n    });\n  }\n  static from(text) {\n    return new GitConfig(text);\n  }\n  async get(path, getall = false) {\n    const normalizedPath = normalizePath$1(path).path;\n    const allValues = this.parsedConfig.filter(config => config.path === normalizedPath).map(({\n      section,\n      name,\n      value\n    }) => {\n      const fn = schema[section] && schema[section][name];\n      return fn ? fn(value) : value;\n    });\n    return getall ? allValues : allValues.pop();\n  }\n  async getall(path) {\n    return this.get(path, true);\n  }\n  async getSubsections(section) {\n    return this.parsedConfig.filter(config => config.section === section && config.isSection).map(config => config.subsection);\n  }\n  async deleteSection(section, subsection) {\n    this.parsedConfig = this.parsedConfig.filter(config => !(config.section === section && config.subsection === subsection));\n  }\n  async append(path, value) {\n    return this.set(path, value, true);\n  }\n  async set(path, value, append = false) {\n    const {\n      section,\n      subsection,\n      name,\n      path: normalizedPath,\n      sectionPath\n    } = normalizePath$1(path);\n    const configIndex = findLastIndex(this.parsedConfig, config => config.path === normalizedPath);\n    if (value == null) {\n      if (configIndex !== -1) {\n        this.parsedConfig.splice(configIndex, 1);\n      }\n    } else {\n      if (configIndex !== -1) {\n        const config = this.parsedConfig[configIndex];\n        // Name should be overwritten in case the casing changed\n        const modifiedConfig = Object.assign({}, config, {\n          name,\n          value,\n          modified: true\n        });\n        if (append) {\n          this.parsedConfig.splice(configIndex + 1, 0, modifiedConfig);\n        } else {\n          this.parsedConfig[configIndex] = modifiedConfig;\n        }\n      } else {\n        const sectionIndex = this.parsedConfig.findIndex(config => config.path === sectionPath);\n        const newConfig = {\n          section,\n          subsection,\n          name,\n          value,\n          modified: true,\n          path: normalizedPath\n        };\n        if (SECTION_REGEX.test(section) && VARIABLE_NAME_REGEX.test(name)) {\n          if (sectionIndex >= 0) {\n            // Reuse existing section\n            this.parsedConfig.splice(sectionIndex + 1, 0, newConfig);\n          } else {\n            // Add a new section\n            const newSection = {\n              section,\n              subsection,\n              modified: true,\n              path: sectionPath\n            };\n            this.parsedConfig.push(newSection, newConfig);\n          }\n        }\n      }\n    }\n  }\n  toString() {\n    return this.parsedConfig.map(({\n      line,\n      section,\n      subsection,\n      name,\n      value,\n      modified = false\n    }) => {\n      if (!modified) {\n        return line;\n      }\n      if (name != null && value != null) {\n        if (typeof value === 'string' && /[#;]/.test(value)) {\n          // A `#` or `;` symbol denotes a comment, so we have to wrap it in double quotes\n          return `\\t${name} = \"${value}\"`;\n        }\n        return `\\t${name} = ${value}`;\n      }\n      if (subsection != null) {\n        return `[${section} \"${subsection}\"]`;\n      }\n      return `[${section}]`;\n    }).join('\\n');\n  }\n}\nclass GitConfigManager {\n  static async get({\n    fs,\n    gitdir\n  }) {\n    // We can improve efficiency later if needed.\n    // TODO: read from full list of git config files\n    const text = await fs.read(`${gitdir}/config`, {\n      encoding: 'utf8'\n    });\n    return GitConfig.from(text);\n  }\n  static async save({\n    fs,\n    gitdir,\n    config\n  }) {\n    // We can improve efficiency later if needed.\n    // TODO: handle saving to the correct global/user/repo location\n    await fs.write(`${gitdir}/config`, config.toString(), {\n      encoding: 'utf8'\n    });\n  }\n}\n\n// This is a convenience wrapper for reading and writing files in the 'refs' directory.\n\n// @see https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions\nconst refpaths = ref => [`${ref}`, `refs/${ref}`, `refs/tags/${ref}`, `refs/heads/${ref}`, `refs/remotes/${ref}`, `refs/remotes/${ref}/HEAD`];\n\n// @see https://git-scm.com/docs/gitrepository-layout\nconst GIT_FILES = ['config', 'description', 'index', 'shallow', 'commondir'];\nclass GitRefManager {\n  static async updateRemoteRefs({\n    fs,\n    gitdir,\n    remote,\n    refs,\n    symrefs,\n    tags,\n    refspecs = undefined,\n    prune = false,\n    pruneTags = false\n  }) {\n    // Validate input\n    for (const value of refs.values()) {\n      if (!value.match(/[0-9a-f]{40}/)) {\n        throw new InvalidOidError(value);\n      }\n    }\n    const config = await GitConfigManager.get({\n      fs,\n      gitdir\n    });\n    if (!refspecs) {\n      refspecs = await config.getall(`remote.${remote}.fetch`);\n      if (refspecs.length === 0) {\n        throw new NoRefspecError(remote);\n      }\n      // There's some interesting behavior with HEAD that doesn't follow the refspec.\n      refspecs.unshift(`+HEAD:refs/remotes/${remote}/HEAD`);\n    }\n    const refspec = GitRefSpecSet.from(refspecs);\n    const actualRefsToWrite = new Map();\n    // Delete all current tags if the pruneTags argument is true.\n    if (pruneTags) {\n      const tags = await GitRefManager.listRefs({\n        fs,\n        gitdir,\n        filepath: 'refs/tags'\n      });\n      await GitRefManager.deleteRefs({\n        fs,\n        gitdir,\n        refs: tags.map(tag => `refs/tags/${tag}`)\n      });\n    }\n    // Add all tags if the fetch tags argument is true.\n    if (tags) {\n      for (const serverRef of refs.keys()) {\n        if (serverRef.startsWith('refs/tags') && !serverRef.endsWith('^{}')) {\n          // Git's behavior is to only fetch tags that do not conflict with tags already present.\n          if (!(await GitRefManager.exists({\n            fs,\n            gitdir,\n            ref: serverRef\n          }))) {\n            // Always use the object id of the tag itself, and not the peeled object id.\n            const oid = refs.get(serverRef);\n            actualRefsToWrite.set(serverRef, oid);\n          }\n        }\n      }\n    }\n    // Combine refs and symrefs giving symrefs priority\n    const refTranslations = refspec.translate([...refs.keys()]);\n    for (const [serverRef, translatedRef] of refTranslations) {\n      const value = refs.get(serverRef);\n      actualRefsToWrite.set(translatedRef, value);\n    }\n    const symrefTranslations = refspec.translate([...symrefs.keys()]);\n    for (const [serverRef, translatedRef] of symrefTranslations) {\n      const value = symrefs.get(serverRef);\n      const symtarget = refspec.translateOne(value);\n      if (symtarget) {\n        actualRefsToWrite.set(translatedRef, `ref: ${symtarget}`);\n      }\n    }\n    // If `prune` argument is true, clear out the existing local refspec roots\n    const pruned = [];\n    if (prune) {\n      for (const filepath of refspec.localNamespaces()) {\n        const refs = (await GitRefManager.listRefs({\n          fs,\n          gitdir,\n          filepath\n        })).map(file => `${filepath}/${file}`);\n        for (const ref of refs) {\n          if (!actualRefsToWrite.has(ref)) {\n            pruned.push(ref);\n          }\n        }\n      }\n      if (pruned.length > 0) {\n        await GitRefManager.deleteRefs({\n          fs,\n          gitdir,\n          refs: pruned\n        });\n      }\n    }\n    // Update files\n    // TODO: For large repos with a history of thousands of pull requests\n    // (i.e. gitlab-ce) it would be vastly more efficient to write them\n    // to .git/packed-refs.\n    // The trick is to make sure we a) don't write a packed ref that is\n    // already shadowed by a loose ref and b) don't loose any refs already\n    // in packed-refs. Doing this efficiently may be difficult. A\n    // solution that might work is\n    // a) load the current packed-refs file\n    // b) add actualRefsToWrite, overriding the existing values if present\n    // c) enumerate all the loose refs currently in .git/refs/remotes/${remote}\n    // d) overwrite their value with the new value.\n    // Examples of refs we need to avoid writing in loose format for efficieny's sake\n    // are .git/refs/remotes/origin/refs/remotes/remote_mirror_3059\n    // and .git/refs/remotes/origin/refs/merge-requests\n    for (const [key, value] of actualRefsToWrite) {\n      await fs.write(join(gitdir, key), `${value.trim()}\\n`, 'utf8');\n    }\n    return {\n      pruned\n    };\n  }\n\n  // TODO: make this less crude?\n  static async writeRef({\n    fs,\n    gitdir,\n    ref,\n    value\n  }) {\n    // Validate input\n    if (!value.match(/[0-9a-f]{40}/)) {\n      throw new InvalidOidError(value);\n    }\n    await fs.write(join(gitdir, ref), `${value.trim()}\\n`, 'utf8');\n  }\n  static async writeSymbolicRef({\n    fs,\n    gitdir,\n    ref,\n    value\n  }) {\n    await fs.write(join(gitdir, ref), 'ref: ' + `${value.trim()}\\n`, 'utf8');\n  }\n  static async deleteRef({\n    fs,\n    gitdir,\n    ref\n  }) {\n    return GitRefManager.deleteRefs({\n      fs,\n      gitdir,\n      refs: [ref]\n    });\n  }\n  static async deleteRefs({\n    fs,\n    gitdir,\n    refs\n  }) {\n    // Delete regular ref\n    await Promise.all(refs.map(ref => fs.rm(join(gitdir, ref))));\n    // Delete any packed ref\n    let text = await fs.read(`${gitdir}/packed-refs`, {\n      encoding: 'utf8'\n    });\n    const packed = GitPackedRefs.from(text);\n    const beforeSize = packed.refs.size;\n    for (const ref of refs) {\n      if (packed.refs.has(ref)) {\n        packed.delete(ref);\n      }\n    }\n    if (packed.refs.size < beforeSize) {\n      text = packed.toString();\n      await fs.write(`${gitdir}/packed-refs`, text, {\n        encoding: 'utf8'\n      });\n    }\n  }\n\n  /**\n   * @param {object} args\n   * @param {import('../models/FileSystem.js').FileSystem} args.fs\n   * @param {string} args.gitdir\n   * @param {string} args.ref\n   * @param {number} [args.depth]\n   * @returns {Promise<string>}\n   */\n  static async resolve({\n    fs,\n    gitdir,\n    ref,\n    depth = undefined\n  }) {\n    if (depth !== undefined) {\n      depth--;\n      if (depth === -1) {\n        return ref;\n      }\n    }\n    let sha;\n    // Is it a ref pointer?\n    if (ref.startsWith('ref: ')) {\n      ref = ref.slice('ref: '.length);\n      return GitRefManager.resolve({\n        fs,\n        gitdir,\n        ref,\n        depth\n      });\n    }\n    // Is it a complete and valid SHA?\n    if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {\n      return ref;\n    }\n    // We need to alternate between the file system and the packed-refs\n    const packedMap = await GitRefManager.packedRefs({\n      fs,\n      gitdir\n    });\n    // Look in all the proper paths, in this order\n    const allpaths = refpaths(ref).filter(p => !GIT_FILES.includes(p)); // exclude git system files (#709)\n\n    for (const ref of allpaths) {\n      sha = (await fs.read(`${gitdir}/${ref}`, {\n        encoding: 'utf8'\n      })) || packedMap.get(ref);\n      if (sha) {\n        return GitRefManager.resolve({\n          fs,\n          gitdir,\n          ref: sha.trim(),\n          depth\n        });\n      }\n    }\n    // Do we give up?\n    throw new NotFoundError(ref);\n  }\n  static async exists({\n    fs,\n    gitdir,\n    ref\n  }) {\n    try {\n      await GitRefManager.expand({\n        fs,\n        gitdir,\n        ref\n      });\n      return true;\n    } catch (err) {\n      return false;\n    }\n  }\n  static async expand({\n    fs,\n    gitdir,\n    ref\n  }) {\n    // Is it a complete and valid SHA?\n    if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {\n      return ref;\n    }\n    // We need to alternate between the file system and the packed-refs\n    const packedMap = await GitRefManager.packedRefs({\n      fs,\n      gitdir\n    });\n    // Look in all the proper paths, in this order\n    const allpaths = refpaths(ref);\n    for (const ref of allpaths) {\n      if (await fs.exists(`${gitdir}/${ref}`)) return ref;\n      if (packedMap.has(ref)) return ref;\n    }\n    // Do we give up?\n    throw new NotFoundError(ref);\n  }\n  static async expandAgainstMap({\n    ref,\n    map\n  }) {\n    // Look in all the proper paths, in this order\n    const allpaths = refpaths(ref);\n    for (const ref of allpaths) {\n      if (await map.has(ref)) return ref;\n    }\n    // Do we give up?\n    throw new NotFoundError(ref);\n  }\n  static resolveAgainstMap({\n    ref,\n    fullref = ref,\n    depth = undefined,\n    map\n  }) {\n    if (depth !== undefined) {\n      depth--;\n      if (depth === -1) {\n        return {\n          fullref,\n          oid: ref\n        };\n      }\n    }\n    // Is it a ref pointer?\n    if (ref.startsWith('ref: ')) {\n      ref = ref.slice('ref: '.length);\n      return GitRefManager.resolveAgainstMap({\n        ref,\n        fullref,\n        depth,\n        map\n      });\n    }\n    // Is it a complete and valid SHA?\n    if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {\n      return {\n        fullref,\n        oid: ref\n      };\n    }\n    // Look in all the proper paths, in this order\n    const allpaths = refpaths(ref);\n    for (const ref of allpaths) {\n      const sha = map.get(ref);\n      if (sha) {\n        return GitRefManager.resolveAgainstMap({\n          ref: sha.trim(),\n          fullref: ref,\n          depth,\n          map\n        });\n      }\n    }\n    // Do we give up?\n    throw new NotFoundError(ref);\n  }\n  static async packedRefs({\n    fs,\n    gitdir\n  }) {\n    const text = await fs.read(`${gitdir}/packed-refs`, {\n      encoding: 'utf8'\n    });\n    const packed = GitPackedRefs.from(text);\n    return packed.refs;\n  }\n\n  // List all the refs that match the `filepath` prefix\n  static async listRefs({\n    fs,\n    gitdir,\n    filepath\n  }) {\n    const packedMap = GitRefManager.packedRefs({\n      fs,\n      gitdir\n    });\n    let files = null;\n    try {\n      files = await fs.readdirDeep(`${gitdir}/${filepath}`);\n      files = files.map(x => x.replace(`${gitdir}/${filepath}/`, ''));\n    } catch (err) {\n      files = [];\n    }\n    for (let key of (await packedMap).keys()) {\n      // filter by prefix\n      if (key.startsWith(filepath)) {\n        // remove prefix\n        key = key.replace(filepath + '/', '');\n        // Don't include duplicates; the loose files have precedence anyway\n        if (!files.includes(key)) {\n          files.push(key);\n        }\n      }\n    }\n    // since we just appended things onto an array, we need to sort them now\n    files.sort(compareRefNames);\n    return files;\n  }\n  static async listBranches({\n    fs,\n    gitdir,\n    remote\n  }) {\n    if (remote) {\n      return GitRefManager.listRefs({\n        fs,\n        gitdir,\n        filepath: `refs/remotes/${remote}`\n      });\n    } else {\n      return GitRefManager.listRefs({\n        fs,\n        gitdir,\n        filepath: `refs/heads`\n      });\n    }\n  }\n  static async listTags({\n    fs,\n    gitdir\n  }) {\n    const tags = await GitRefManager.listRefs({\n      fs,\n      gitdir,\n      filepath: `refs/tags`\n    });\n    return tags.filter(x => !x.endsWith('^{}'));\n  }\n}\nfunction compareTreeEntryPath(a, b) {\n  // Git sorts tree entries as if there is a trailing slash on directory names.\n  return compareStrings(appendSlashIfDir(a), appendSlashIfDir(b));\n}\nfunction appendSlashIfDir(entry) {\n  return entry.mode === '040000' ? entry.path + '/' : entry.path;\n}\n\n/**\n *\n * @typedef {Object} TreeEntry\n * @property {string} mode - the 6 digit hexadecimal mode\n * @property {string} path - the name of the file or directory\n * @property {string} oid - the SHA-1 object id of the blob or tree\n * @property {'commit'|'blob'|'tree'} type - the type of object\n */\n\nfunction mode2type$1(mode) {\n  // prettier-ignore\n  switch (mode) {\n    case '040000':\n      return 'tree';\n    case '100644':\n      return 'blob';\n    case '100755':\n      return 'blob';\n    case '120000':\n      return 'blob';\n    case '160000':\n      return 'commit';\n  }\n  throw new InternalError(`Unexpected GitTree entry mode: ${mode}`);\n}\nfunction parseBuffer(buffer) {\n  const _entries = [];\n  let cursor = 0;\n  while (cursor < buffer.length) {\n    const space = buffer.indexOf(32, cursor);\n    if (space === -1) {\n      throw new InternalError(`GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next space character.`);\n    }\n    const nullchar = buffer.indexOf(0, cursor);\n    if (nullchar === -1) {\n      throw new InternalError(`GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next null character.`);\n    }\n    let mode = buffer.slice(cursor, space).toString('utf8');\n    if (mode === '40000') mode = '040000'; // makes it line up neater in printed output\n    const type = mode2type$1(mode);\n    const path = buffer.slice(space + 1, nullchar).toString('utf8');\n\n    // Prevent malicious git repos from writing to \"..\\foo\" on clone etc\n    if (path.includes('\\\\') || path.includes('/')) {\n      throw new UnsafeFilepathError(path);\n    }\n    const oid = buffer.slice(nullchar + 1, nullchar + 21).toString('hex');\n    cursor = nullchar + 21;\n    _entries.push({\n      mode,\n      path,\n      oid,\n      type\n    });\n  }\n  return _entries;\n}\nfunction limitModeToAllowed(mode) {\n  if (typeof mode === 'number') {\n    mode = mode.toString(8);\n  }\n  // tree\n  if (mode.match(/^0?4.*/)) return '040000'; // Directory\n  if (mode.match(/^1006.*/)) return '100644'; // Regular non-executable file\n  if (mode.match(/^1007.*/)) return '100755'; // Regular executable file\n  if (mode.match(/^120.*/)) return '120000'; // Symbolic link\n  if (mode.match(/^160.*/)) return '160000'; // Commit (git submodule reference)\n  throw new InternalError(`Could not understand file mode: ${mode}`);\n}\nfunction nudgeIntoShape(entry) {\n  if (!entry.oid && entry.sha) {\n    entry.oid = entry.sha; // Github\n  }\n  entry.mode = limitModeToAllowed(entry.mode); // index\n  if (!entry.type) {\n    entry.type = mode2type$1(entry.mode); // index\n  }\n  return entry;\n}\nclass GitTree {\n  constructor(entries) {\n    if (Buffer.isBuffer(entries)) {\n      this._entries = parseBuffer(entries);\n    } else if (Array.isArray(entries)) {\n      this._entries = entries.map(nudgeIntoShape);\n    } else {\n      throw new InternalError('invalid type passed to GitTree constructor');\n    }\n    // Tree entries are not sorted alphabetically in the usual sense (see `compareTreeEntryPath`)\n    // but it is important later on that these be sorted in the same order as they would be returned from readdir.\n    this._entries.sort(comparePath);\n  }\n  static from(tree) {\n    return new GitTree(tree);\n  }\n  render() {\n    return this._entries.map(entry => `${entry.mode} ${entry.type} ${entry.oid}    ${entry.path}`).join('\\n');\n  }\n  toObject() {\n    // Adjust the sort order to match git's\n    const entries = [...this._entries];\n    entries.sort(compareTreeEntryPath);\n    return Buffer.concat(entries.map(entry => {\n      const mode = Buffer.from(entry.mode.replace(/^0/, ''));\n      const space = Buffer.from(' ');\n      const path = Buffer.from(entry.path, 'utf8');\n      const nullchar = Buffer.from([0]);\n      const oid = Buffer.from(entry.oid, 'hex');\n      return Buffer.concat([mode, space, path, nullchar, oid]);\n    }));\n  }\n\n  /**\n   * @returns {TreeEntry[]}\n   */\n  entries() {\n    return this._entries;\n  }\n  *[Symbol.iterator]() {\n    for (const entry of this._entries) {\n      yield entry;\n    }\n  }\n}\nclass GitObject {\n  static wrap({\n    type,\n    object\n  }) {\n    return Buffer.concat([Buffer.from(`${type} ${object.byteLength.toString()}\\x00`), Buffer.from(object)]);\n  }\n  static unwrap(buffer) {\n    const s = buffer.indexOf(32); // first space\n    const i = buffer.indexOf(0); // first null value\n    const type = buffer.slice(0, s).toString('utf8'); // get type of object\n    const length = buffer.slice(s + 1, i).toString('utf8'); // get type of object\n    const actualLength = buffer.length - (i + 1);\n    // verify length\n    if (parseInt(length) !== actualLength) {\n      throw new InternalError(`Length mismatch: expected ${length} bytes but got ${actualLength} instead.`);\n    }\n    return {\n      type,\n      object: Buffer.from(buffer.slice(i + 1))\n    };\n  }\n}\nasync function readObjectLoose({\n  fs,\n  gitdir,\n  oid\n}) {\n  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;\n  const file = await fs.read(`${gitdir}/${source}`);\n  if (!file) {\n    return null;\n  }\n  return {\n    object: file,\n    format: 'deflated',\n    source\n  };\n}\n\n/**\n * @param {Buffer} delta\n * @param {Buffer} source\n * @returns {Buffer}\n */\nfunction applyDelta(delta, source) {\n  const reader = new BufferCursor(delta);\n  const sourceSize = readVarIntLE(reader);\n  if (sourceSize !== source.byteLength) {\n    throw new InternalError(`applyDelta expected source buffer to be ${sourceSize} bytes but the provided buffer was ${source.length} bytes`);\n  }\n  const targetSize = readVarIntLE(reader);\n  let target;\n  const firstOp = readOp(reader, source);\n  // Speed optimization - return raw buffer if it's just single simple copy\n  if (firstOp.byteLength === targetSize) {\n    target = firstOp;\n  } else {\n    // Otherwise, allocate a fresh buffer and slices\n    target = Buffer.alloc(targetSize);\n    const writer = new BufferCursor(target);\n    writer.copy(firstOp);\n    while (!reader.eof()) {\n      writer.copy(readOp(reader, source));\n    }\n    const tell = writer.tell();\n    if (targetSize !== tell) {\n      throw new InternalError(`applyDelta expected target buffer to be ${targetSize} bytes but the resulting buffer was ${tell} bytes`);\n    }\n  }\n  return target;\n}\nfunction readVarIntLE(reader) {\n  let result = 0;\n  let shift = 0;\n  let byte = null;\n  do {\n    byte = reader.readUInt8();\n    result |= (byte & 0b01111111) << shift;\n    shift += 7;\n  } while (byte & 0b10000000);\n  return result;\n}\nfunction readCompactLE(reader, flags, size) {\n  let result = 0;\n  let shift = 0;\n  while (size--) {\n    if (flags & 0b00000001) {\n      result |= reader.readUInt8() << shift;\n    }\n    flags >>= 1;\n    shift += 8;\n  }\n  return result;\n}\nfunction readOp(reader, source) {\n  /** @type {number} */\n  const byte = reader.readUInt8();\n  const COPY = 0b10000000;\n  const OFFS = 0b00001111;\n  const SIZE = 0b01110000;\n  if (byte & COPY) {\n    // copy consists of 4 byte offset, 3 byte size (in LE order)\n    const offset = readCompactLE(reader, byte & OFFS, 4);\n    let size = readCompactLE(reader, (byte & SIZE) >> 4, 3);\n    // Yup. They really did this optimization.\n    if (size === 0) size = 0x10000;\n    return source.slice(offset, offset + size);\n  } else {\n    // insert\n    return reader.slice(byte);\n  }\n}\n\n// Convert a value to an Async Iterator\n// This will be easier with async generator functions.\nfunction fromValue(value) {\n  let queue = [value];\n  return {\n    next() {\n      return Promise.resolve({\n        done: queue.length === 0,\n        value: queue.pop()\n      });\n    },\n    return() {\n      queue = [];\n      return {};\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n}\nfunction getIterator(iterable) {\n  if (iterable[Symbol.asyncIterator]) {\n    return iterable[Symbol.asyncIterator]();\n  }\n  if (iterable[Symbol.iterator]) {\n    return iterable[Symbol.iterator]();\n  }\n  if (iterable.next) {\n    return iterable;\n  }\n  return fromValue(iterable);\n}\n\n// inspired by 'gartal' but lighter-weight and more battle-tested.\nclass StreamReader {\n  constructor(stream) {\n    this.stream = getIterator(stream);\n    this.buffer = null;\n    this.cursor = 0;\n    this.undoCursor = 0;\n    this.started = false;\n    this._ended = false;\n    this._discardedBytes = 0;\n  }\n  eof() {\n    return this._ended && this.cursor === this.buffer.length;\n  }\n  tell() {\n    return this._discardedBytes + this.cursor;\n  }\n  async byte() {\n    if (this.eof()) return;\n    if (!this.started) await this._init();\n    if (this.cursor === this.buffer.length) {\n      await this._loadnext();\n      if (this._ended) return;\n    }\n    this._moveCursor(1);\n    return this.buffer[this.undoCursor];\n  }\n  async chunk() {\n    if (this.eof()) return;\n    if (!this.started) await this._init();\n    if (this.cursor === this.buffer.length) {\n      await this._loadnext();\n      if (this._ended) return;\n    }\n    this._moveCursor(this.buffer.length);\n    return this.buffer.slice(this.undoCursor, this.cursor);\n  }\n  async read(n) {\n    if (this.eof()) return;\n    if (!this.started) await this._init();\n    if (this.cursor + n > this.buffer.length) {\n      this._trim();\n      await this._accumulate(n);\n    }\n    this._moveCursor(n);\n    return this.buffer.slice(this.undoCursor, this.cursor);\n  }\n  async skip(n) {\n    if (this.eof()) return;\n    if (!this.started) await this._init();\n    if (this.cursor + n > this.buffer.length) {\n      this._trim();\n      await this._accumulate(n);\n    }\n    this._moveCursor(n);\n  }\n  async undo() {\n    this.cursor = this.undoCursor;\n  }\n  async _next() {\n    this.started = true;\n    let {\n      done,\n      value\n    } = await this.stream.next();\n    if (done) {\n      this._ended = true;\n    }\n    if (value) {\n      value = Buffer.from(value);\n    }\n    return value;\n  }\n  _trim() {\n    // Throw away parts of the buffer we don't need anymore\n    // assert(this.cursor <= this.buffer.length)\n    this.buffer = this.buffer.slice(this.undoCursor);\n    this.cursor -= this.undoCursor;\n    this._discardedBytes += this.undoCursor;\n    this.undoCursor = 0;\n  }\n  _moveCursor(n) {\n    this.undoCursor = this.cursor;\n    this.cursor += n;\n    if (this.cursor > this.buffer.length) {\n      this.cursor = this.buffer.length;\n    }\n  }\n  async _accumulate(n) {\n    if (this._ended) return;\n    // Expand the buffer until we have N bytes of data\n    // or we've reached the end of the stream\n    const buffers = [this.buffer];\n    while (this.cursor + n > lengthBuffers(buffers)) {\n      const nextbuffer = await this._next();\n      if (this._ended) break;\n      buffers.push(nextbuffer);\n    }\n    this.buffer = Buffer.concat(buffers);\n  }\n  async _loadnext() {\n    this._discardedBytes += this.buffer.length;\n    this.undoCursor = 0;\n    this.cursor = 0;\n    this.buffer = await this._next();\n  }\n  async _init() {\n    this.buffer = await this._next();\n  }\n}\n\n// This helper function helps us postpone concatenating buffers, which\n// would create intermediate buffer objects,\nfunction lengthBuffers(buffers) {\n  return buffers.reduce((acc, buffer) => acc + buffer.length, 0);\n}\n\n// My version of git-list-pack - roughly 15x faster than the original\n\nasync function listpack(stream, onData) {\n  const reader = new StreamReader(stream);\n  let PACK = await reader.read(4);\n  PACK = PACK.toString('utf8');\n  if (PACK !== 'PACK') {\n    throw new InternalError(`Invalid PACK header '${PACK}'`);\n  }\n  let version = await reader.read(4);\n  version = version.readUInt32BE(0);\n  if (version !== 2) {\n    throw new InternalError(`Invalid packfile version: ${version}`);\n  }\n  let numObjects = await reader.read(4);\n  numObjects = numObjects.readUInt32BE(0);\n  // If (for some godforsaken reason) this is an empty packfile, abort now.\n  if (numObjects < 1) return;\n  while (!reader.eof() && numObjects--) {\n    const offset = reader.tell();\n    const {\n      type,\n      length,\n      ofs,\n      reference\n    } = await parseHeader(reader);\n    const inflator = new pako.Inflate();\n    while (!inflator.result) {\n      const chunk = await reader.chunk();\n      if (!chunk) break;\n      inflator.push(chunk, false);\n      if (inflator.err) {\n        throw new InternalError(`Pako error: ${inflator.msg}`);\n      }\n      if (inflator.result) {\n        if (inflator.result.length !== length) {\n          throw new InternalError(`Inflated object size is different from that stated in packfile.`);\n        }\n\n        // Backtrack parser to where deflated data ends\n        await reader.undo();\n        await reader.read(chunk.length - inflator.strm.avail_in);\n        const end = reader.tell();\n        await onData({\n          data: inflator.result,\n          type,\n          num: numObjects,\n          offset,\n          end,\n          reference,\n          ofs\n        });\n      }\n    }\n  }\n}\nasync function parseHeader(reader) {\n  // Object type is encoded in bits 654\n  let byte = await reader.byte();\n  const type = byte >> 4 & 0b111;\n  // The length encoding get complicated.\n  // Last four bits of length is encoded in bits 3210\n  let length = byte & 0b1111;\n  // Whether the next byte is part of the variable-length encoded number\n  // is encoded in bit 7\n  if (byte & 0b10000000) {\n    let shift = 4;\n    do {\n      byte = await reader.byte();\n      length |= (byte & 0b01111111) << shift;\n      shift += 7;\n    } while (byte & 0b10000000);\n  }\n  // Handle deltified objects\n  let ofs;\n  let reference;\n  if (type === 6) {\n    let shift = 0;\n    ofs = 0;\n    const bytes = [];\n    do {\n      byte = await reader.byte();\n      ofs |= (byte & 0b01111111) << shift;\n      shift += 7;\n      bytes.push(byte);\n    } while (byte & 0b10000000);\n    reference = Buffer.from(bytes);\n  }\n  if (type === 7) {\n    const buf = await reader.read(20);\n    reference = buf;\n  }\n  return {\n    type,\n    length,\n    ofs,\n    reference\n  };\n}\n\n/* eslint-env node, browser */\n\nlet supportsDecompressionStream = false;\nasync function inflate(buffer) {\n  if (supportsDecompressionStream === null) {\n    supportsDecompressionStream = testDecompressionStream();\n  }\n  return supportsDecompressionStream ? browserInflate(buffer) : pako.inflate(buffer);\n}\nasync function browserInflate(buffer) {\n  const ds = new DecompressionStream('deflate');\n  const d = new Blob([buffer]).stream().pipeThrough(ds);\n  return new Uint8Array(await new Response(d).arrayBuffer());\n}\nfunction testDecompressionStream() {\n  try {\n    const ds = new DecompressionStream('deflate');\n    if (ds) return true;\n  } catch (_) {\n    // no bother\n  }\n  return false;\n}\nfunction decodeVarInt(reader) {\n  const bytes = [];\n  let byte = 0;\n  let multibyte = 0;\n  do {\n    byte = reader.readUInt8();\n    // We keep bits 6543210\n    const lastSeven = byte & 0b01111111;\n    bytes.push(lastSeven);\n    // Whether the next byte is part of the variable-length encoded number\n    // is encoded in bit 7\n    multibyte = byte & 0b10000000;\n  } while (multibyte);\n  // Now that all the bytes are in big-endian order,\n  // alternate shifting the bits left by 7 and OR-ing the next byte.\n  // And... do a weird increment-by-one thing that I don't quite understand.\n  return bytes.reduce((a, b) => a + 1 << 7 | b, -1);\n}\n\n// I'm pretty much copying this one from the git C source code,\n// because it makes no sense.\nfunction otherVarIntDecode(reader, startWith) {\n  let result = startWith;\n  let shift = 4;\n  let byte = null;\n  do {\n    byte = reader.readUInt8();\n    result |= (byte & 0b01111111) << shift;\n    shift += 7;\n  } while (byte & 0b10000000);\n  return result;\n}\nclass GitPackIndex {\n  constructor(stuff) {\n    Object.assign(this, stuff);\n    this.offsetCache = {};\n  }\n  static async fromIdx({\n    idx,\n    getExternalRefDelta\n  }) {\n    const reader = new BufferCursor(idx);\n    const magic = reader.slice(4).toString('hex');\n    // Check for IDX v2 magic number\n    if (magic !== 'ff744f63') {\n      return; // undefined\n    }\n    const version = reader.readUInt32BE();\n    if (version !== 2) {\n      throw new InternalError(`Unable to read version ${version} packfile IDX. (Only version 2 supported)`);\n    }\n    if (idx.byteLength > 2048 * 1024 * 1024) {\n      throw new InternalError(`To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.`);\n    }\n    // Skip over fanout table\n    reader.seek(reader.tell() + 4 * 255);\n    // Get hashes\n    const size = reader.readUInt32BE();\n    const hashes = [];\n    for (let i = 0; i < size; i++) {\n      const hash = reader.slice(20).toString('hex');\n      hashes[i] = hash;\n    }\n    reader.seek(reader.tell() + 4 * size);\n    // Skip over CRCs\n    // Get offsets\n    const offsets = new Map();\n    for (let i = 0; i < size; i++) {\n      offsets.set(hashes[i], reader.readUInt32BE());\n    }\n    const packfileSha = reader.slice(20).toString('hex');\n    return new GitPackIndex({\n      hashes,\n      crcs: {},\n      offsets,\n      packfileSha,\n      getExternalRefDelta\n    });\n  }\n  static async fromPack({\n    pack,\n    getExternalRefDelta,\n    onProgress\n  }) {\n    const listpackTypes = {\n      1: 'commit',\n      2: 'tree',\n      3: 'blob',\n      4: 'tag',\n      6: 'ofs-delta',\n      7: 'ref-delta'\n    };\n    const offsetToObject = {};\n\n    // Older packfiles do NOT use the shasum of the pack itself,\n    // so it is recommended to just use whatever bytes are in the trailer.\n    // Source: https://github.com/git/git/commit/1190a1acf800acdcfd7569f87ac1560e2d077414\n    const packfileSha = pack.slice(-20).toString('hex');\n    const hashes = [];\n    const crcs = {};\n    const offsets = new Map();\n    let totalObjectCount = null;\n    let lastPercent = null;\n    await listpack([pack], async ({\n      data,\n      type,\n      reference,\n      offset,\n      num\n    }) => {\n      if (totalObjectCount === null) totalObjectCount = num;\n      const percent = Math.floor((totalObjectCount - num) * 100 / totalObjectCount);\n      if (percent !== lastPercent) {\n        if (onProgress) {\n          await onProgress({\n            phase: 'Receiving objects',\n            loaded: totalObjectCount - num,\n            total: totalObjectCount\n          });\n        }\n      }\n      lastPercent = percent;\n      // Change type from a number to a meaningful string\n      type = listpackTypes[type];\n      if (['commit', 'tree', 'blob', 'tag'].includes(type)) {\n        offsetToObject[offset] = {\n          type,\n          offset\n        };\n      } else if (type === 'ofs-delta') {\n        offsetToObject[offset] = {\n          type,\n          offset\n        };\n      } else if (type === 'ref-delta') {\n        offsetToObject[offset] = {\n          type,\n          offset\n        };\n      }\n    });\n\n    // We need to know the lengths of the slices to compute the CRCs.\n    const offsetArray = Object.keys(offsetToObject).map(Number);\n    for (const [i, start] of offsetArray.entries()) {\n      const end = i + 1 === offsetArray.length ? pack.byteLength - 20 : offsetArray[i + 1];\n      const o = offsetToObject[start];\n      const crc = crc32.buf(pack.slice(start, end)) >>> 0;\n      o.end = end;\n      o.crc = crc;\n    }\n\n    // We don't have the hashes yet. But we can generate them using the .readSlice function!\n    const p = new GitPackIndex({\n      pack: Promise.resolve(pack),\n      packfileSha,\n      crcs,\n      hashes,\n      offsets,\n      getExternalRefDelta\n    });\n\n    // Resolve deltas and compute the oids\n    lastPercent = null;\n    let count = 0;\n    const objectsByDepth = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    for (let offset in offsetToObject) {\n      offset = Number(offset);\n      const percent = Math.floor(count * 100 / totalObjectCount);\n      if (percent !== lastPercent) {\n        if (onProgress) {\n          await onProgress({\n            phase: 'Resolving deltas',\n            loaded: count,\n            total: totalObjectCount\n          });\n        }\n      }\n      count++;\n      lastPercent = percent;\n      const o = offsetToObject[offset];\n      if (o.oid) continue;\n      try {\n        p.readDepth = 0;\n        p.externalReadDepth = 0;\n        const {\n          type,\n          object\n        } = await p.readSlice({\n          start: offset\n        });\n        objectsByDepth[p.readDepth] += 1;\n        const oid = await shasum(GitObject.wrap({\n          type,\n          object\n        }));\n        o.oid = oid;\n        hashes.push(oid);\n        offsets.set(oid, offset);\n        crcs[oid] = o.crc;\n      } catch (err) {\n        continue;\n      }\n    }\n    hashes.sort();\n    return p;\n  }\n  async toBuffer() {\n    const buffers = [];\n    const write = (str, encoding) => {\n      buffers.push(Buffer.from(str, encoding));\n    };\n    // Write out IDX v2 magic number\n    write('ff744f63', 'hex');\n    // Write out version number 2\n    write('00000002', 'hex');\n    // Write fanout table\n    const fanoutBuffer = new BufferCursor(Buffer.alloc(256 * 4));\n    for (let i = 0; i < 256; i++) {\n      let count = 0;\n      for (const hash of this.hashes) {\n        if (parseInt(hash.slice(0, 2), 16) <= i) count++;\n      }\n      fanoutBuffer.writeUInt32BE(count);\n    }\n    buffers.push(fanoutBuffer.buffer);\n    // Write out hashes\n    for (const hash of this.hashes) {\n      write(hash, 'hex');\n    }\n    // Write out crcs\n    const crcsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length * 4));\n    for (const hash of this.hashes) {\n      crcsBuffer.writeUInt32BE(this.crcs[hash]);\n    }\n    buffers.push(crcsBuffer.buffer);\n    // Write out offsets\n    const offsetsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length * 4));\n    for (const hash of this.hashes) {\n      offsetsBuffer.writeUInt32BE(this.offsets.get(hash));\n    }\n    buffers.push(offsetsBuffer.buffer);\n    // Write out packfile checksum\n    write(this.packfileSha, 'hex');\n    // Write out shasum\n    const totalBuffer = Buffer.concat(buffers);\n    const sha = await shasum(totalBuffer);\n    const shaBuffer = Buffer.alloc(20);\n    shaBuffer.write(sha, 'hex');\n    return Buffer.concat([totalBuffer, shaBuffer]);\n  }\n  async load({\n    pack\n  }) {\n    this.pack = pack;\n  }\n  async unload() {\n    this.pack = null;\n  }\n  async read({\n    oid\n  }) {\n    if (!this.offsets.get(oid)) {\n      if (this.getExternalRefDelta) {\n        this.externalReadDepth++;\n        return this.getExternalRefDelta(oid);\n      } else {\n        throw new InternalError(`Could not read object ${oid} from packfile`);\n      }\n    }\n    const start = this.offsets.get(oid);\n    return this.readSlice({\n      start\n    });\n  }\n  async readSlice({\n    start\n  }) {\n    if (this.offsetCache[start]) {\n      return Object.assign({}, this.offsetCache[start]);\n    }\n    this.readDepth++;\n    const types = {\n      0b0010000: 'commit',\n      0b0100000: 'tree',\n      0b0110000: 'blob',\n      0b1000000: 'tag',\n      0b1100000: 'ofs_delta',\n      0b1110000: 'ref_delta'\n    };\n    if (!this.pack) {\n      throw new InternalError('Tried to read from a GitPackIndex with no packfile loaded into memory');\n    }\n    const raw = (await this.pack).slice(start);\n    const reader = new BufferCursor(raw);\n    const byte = reader.readUInt8();\n    // Object type is encoded in bits 654\n    const btype = byte & 0b1110000;\n    let type = types[btype];\n    if (type === undefined) {\n      throw new InternalError('Unrecognized type: 0b' + btype.toString(2));\n    }\n    // The length encoding get complicated.\n    // Last four bits of length is encoded in bits 3210\n    const lastFour = byte & 0b1111;\n    let length = lastFour;\n    // Whether the next byte is part of the variable-length encoded number\n    // is encoded in bit 7\n    const multibyte = byte & 0b10000000;\n    if (multibyte) {\n      length = otherVarIntDecode(reader, lastFour);\n    }\n    let base = null;\n    let object = null;\n    // Handle deltified objects\n    if (type === 'ofs_delta') {\n      const offset = decodeVarInt(reader);\n      const baseOffset = start - offset;\n      ({\n        object: base,\n        type\n      } = await this.readSlice({\n        start: baseOffset\n      }));\n    }\n    if (type === 'ref_delta') {\n      const oid = reader.slice(20).toString('hex');\n      ({\n        object: base,\n        type\n      } = await this.read({\n        oid\n      }));\n    }\n    // Handle undeltified objects\n    const buffer = raw.slice(reader.tell());\n    object = Buffer.from(await inflate(buffer));\n    // Assert that the object length is as expected.\n    if (object.byteLength !== length) {\n      throw new InternalError(`Packfile told us object would have length ${length} but it had length ${object.byteLength}`);\n    }\n    if (base) {\n      object = Buffer.from(applyDelta(object, base));\n    }\n    // Cache the result based on depth.\n    if (this.readDepth > 3) {\n      // hand tuned for speed / memory usage tradeoff\n      this.offsetCache[start] = {\n        type,\n        object\n      };\n    }\n    return {\n      type,\n      format: 'content',\n      object\n    };\n  }\n}\nconst PackfileCache = Symbol('PackfileCache');\nasync function loadPackIndex({\n  fs,\n  filename,\n  getExternalRefDelta,\n  emitter,\n  emitterPrefix\n}) {\n  const idx = await fs.read(filename);\n  return GitPackIndex.fromIdx({\n    idx,\n    getExternalRefDelta\n  });\n}\nfunction readPackIndex({\n  fs,\n  cache,\n  filename,\n  getExternalRefDelta,\n  emitter,\n  emitterPrefix\n}) {\n  // Try to get the packfile index from the in-memory cache\n  if (!cache[PackfileCache]) cache[PackfileCache] = new Map();\n  let p = cache[PackfileCache].get(filename);\n  if (!p) {\n    p = loadPackIndex({\n      fs,\n      filename,\n      getExternalRefDelta,\n      emitter,\n      emitterPrefix\n    });\n    cache[PackfileCache].set(filename, p);\n  }\n  return p;\n}\nasync function readObjectPacked({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  format = 'content',\n  getExternalRefDelta\n}) {\n  // Check to see if it's in a packfile.\n  // Iterate through all the .idx files\n  let list = await fs.readdir(join(gitdir, 'objects/pack'));\n  list = list.filter(x => x.endsWith('.idx'));\n  for (const filename of list) {\n    const indexFile = `${gitdir}/objects/pack/${filename}`;\n    const p = await readPackIndex({\n      fs,\n      cache,\n      filename: indexFile,\n      getExternalRefDelta\n    });\n    if (p.error) throw new InternalError(p.error);\n    // If the packfile DOES have the oid we're looking for...\n    if (p.offsets.has(oid)) {\n      // Get the resolved git object from the packfile\n      if (!p.pack) {\n        const packFile = indexFile.replace(/idx$/, 'pack');\n        p.pack = fs.read(packFile);\n      }\n      const result = await p.read({\n        oid,\n        getExternalRefDelta\n      });\n      result.format = 'content';\n      result.source = `objects/pack/${filename.replace(/idx$/, 'pack')}`;\n      return result;\n    }\n  }\n  // Failed to find it\n  return null;\n}\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} args.oid\n * @param {string} [args.format]\n */\nasync function _readObject({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  format = 'content'\n}) {\n  // Curry the current read method so that the packfile un-deltification\n  // process can acquire external ref-deltas.\n  const getExternalRefDelta = oid => _readObject({\n    fs,\n    cache,\n    gitdir,\n    oid\n  });\n  let result;\n  // Empty tree - hard-coded so we can use it as a shorthand.\n  // Note: I think the canonical git implementation must do this too because\n  // `git cat-file -t 4b825dc642cb6eb9a060e54bf8d69288fbee4904` prints \"tree\" even in empty repos.\n  if (oid === '4b825dc642cb6eb9a060e54bf8d69288fbee4904') {\n    result = {\n      format: 'wrapped',\n      object: Buffer.from(`tree 0\\x00`)\n    };\n  }\n  // Look for it in the loose object directory.\n  if (!result) {\n    result = await readObjectLoose({\n      fs,\n      gitdir,\n      oid\n    });\n  }\n  // Check to see if it's in a packfile.\n  if (!result) {\n    result = await readObjectPacked({\n      fs,\n      cache,\n      gitdir,\n      oid,\n      getExternalRefDelta\n    });\n  }\n  // Finally\n  if (!result) {\n    throw new NotFoundError(oid);\n  }\n  if (format === 'deflated') {\n    return result;\n  }\n  if (result.format === 'deflated') {\n    result.object = Buffer.from(await inflate(result.object));\n    result.format = 'wrapped';\n  }\n  if (result.format === 'wrapped') {\n    if (format === 'wrapped' && result.format === 'wrapped') {\n      return result;\n    }\n    const sha = await shasum(result.object);\n    if (sha !== oid) {\n      throw new InternalError(`SHA check failed! Expected ${oid}, computed ${sha}`);\n    }\n    const {\n      object,\n      type\n    } = GitObject.unwrap(result.object);\n    result.type = type;\n    result.object = object;\n    result.format = 'content';\n  }\n  if (result.format === 'content') {\n    if (format === 'content') return result;\n    return;\n  }\n  throw new InternalError(`invalid format \"${result.format}\"`);\n}\nclass AlreadyExistsError extends BaseError {\n  /**\n   * @param {'note'|'remote'|'tag'|'branch'} noun\n   * @param {string} where\n   * @param {boolean} canForce\n   */\n  constructor(noun, where, canForce = true) {\n    super(`Failed to create ${noun} at ${where} because it already exists.${canForce ? ` (Hint: use 'force: true' parameter to overwrite existing ${noun}.)` : ''}`);\n    this.code = this.name = AlreadyExistsError.code;\n    this.data = {\n      noun,\n      where,\n      canForce\n    };\n  }\n}\n/** @type {'AlreadyExistsError'} */\nAlreadyExistsError.code = 'AlreadyExistsError';\nclass AmbiguousError extends BaseError {\n  /**\n   * @param {'oids'|'refs'} nouns\n   * @param {string} short\n   * @param {string[]} matches\n   */\n  constructor(nouns, short, matches) {\n    super(`Found multiple ${nouns} matching \"${short}\" (${matches.join(', ')}). Use a longer abbreviation length to disambiguate them.`);\n    this.code = this.name = AmbiguousError.code;\n    this.data = {\n      nouns,\n      short,\n      matches\n    };\n  }\n}\n/** @type {'AmbiguousError'} */\nAmbiguousError.code = 'AmbiguousError';\nclass CheckoutConflictError extends BaseError {\n  /**\n   * @param {string[]} filepaths\n   */\n  constructor(filepaths) {\n    super(`Your local changes to the following files would be overwritten by checkout: ${filepaths.join(', ')}`);\n    this.code = this.name = CheckoutConflictError.code;\n    this.data = {\n      filepaths\n    };\n  }\n}\n/** @type {'CheckoutConflictError'} */\nCheckoutConflictError.code = 'CheckoutConflictError';\nclass CommitNotFetchedError extends BaseError {\n  /**\n   * @param {string} ref\n   * @param {string} oid\n   */\n  constructor(ref, oid) {\n    super(`Failed to checkout \"${ref}\" because commit ${oid} is not available locally. Do a git fetch to make the branch available locally.`);\n    this.code = this.name = CommitNotFetchedError.code;\n    this.data = {\n      ref,\n      oid\n    };\n  }\n}\n/** @type {'CommitNotFetchedError'} */\nCommitNotFetchedError.code = 'CommitNotFetchedError';\nclass EmptyServerResponseError extends BaseError {\n  constructor() {\n    super(`Empty response from git server.`);\n    this.code = this.name = EmptyServerResponseError.code;\n    this.data = {};\n  }\n}\n/** @type {'EmptyServerResponseError'} */\nEmptyServerResponseError.code = 'EmptyServerResponseError';\nclass FastForwardError extends BaseError {\n  constructor() {\n    super(`A simple fast-forward merge was not possible.`);\n    this.code = this.name = FastForwardError.code;\n    this.data = {};\n  }\n}\n/** @type {'FastForwardError'} */\nFastForwardError.code = 'FastForwardError';\nclass GitPushError extends BaseError {\n  /**\n   * @param {string} prettyDetails\n   * @param {PushResult} result\n   */\n  constructor(prettyDetails, result) {\n    super(`One or more branches were not updated: ${prettyDetails}`);\n    this.code = this.name = GitPushError.code;\n    this.data = {\n      prettyDetails,\n      result\n    };\n  }\n}\n/** @type {'GitPushError'} */\nGitPushError.code = 'GitPushError';\nclass HttpError extends BaseError {\n  /**\n   * @param {number} statusCode\n   * @param {string} statusMessage\n   * @param {string} response\n   */\n  constructor(statusCode, statusMessage, response) {\n    super(`HTTP Error: ${statusCode} ${statusMessage}`);\n    this.code = this.name = HttpError.code;\n    this.data = {\n      statusCode,\n      statusMessage,\n      response\n    };\n  }\n}\n/** @type {'HttpError'} */\nHttpError.code = 'HttpError';\nclass InvalidFilepathError extends BaseError {\n  /**\n   * @param {'leading-slash'|'trailing-slash'|'directory'} [reason]\n   */\n  constructor(reason) {\n    let message = 'invalid filepath';\n    if (reason === 'leading-slash' || reason === 'trailing-slash') {\n      message = `\"filepath\" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.`;\n    } else if (reason === 'directory') {\n      message = `\"filepath\" should not be a directory.`;\n    }\n    super(message);\n    this.code = this.name = InvalidFilepathError.code;\n    this.data = {\n      reason\n    };\n  }\n}\n/** @type {'InvalidFilepathError'} */\nInvalidFilepathError.code = 'InvalidFilepathError';\nclass InvalidRefNameError extends BaseError {\n  /**\n   * @param {string} ref\n   * @param {string} suggestion\n   * @param {boolean} canForce\n   */\n  constructor(ref, suggestion) {\n    super(`\"${ref}\" would be an invalid git reference. (Hint: a valid alternative would be \"${suggestion}\".)`);\n    this.code = this.name = InvalidRefNameError.code;\n    this.data = {\n      ref,\n      suggestion\n    };\n  }\n}\n/** @type {'InvalidRefNameError'} */\nInvalidRefNameError.code = 'InvalidRefNameError';\nclass MaxDepthError extends BaseError {\n  /**\n   * @param {number} depth\n   */\n  constructor(depth) {\n    super(`Maximum search depth of ${depth} exceeded.`);\n    this.code = this.name = MaxDepthError.code;\n    this.data = {\n      depth\n    };\n  }\n}\n/** @type {'MaxDepthError'} */\nMaxDepthError.code = 'MaxDepthError';\nclass MergeNotSupportedError extends BaseError {\n  constructor() {\n    super(`Merges with conflicts are not supported yet.`);\n    this.code = this.name = MergeNotSupportedError.code;\n    this.data = {};\n  }\n}\n/** @type {'MergeNotSupportedError'} */\nMergeNotSupportedError.code = 'MergeNotSupportedError';\nclass MergeConflictError extends BaseError {\n  /**\n   * @param {Array<string>} filepaths\n   * @param {Array<string>} bothModified\n   * @param {Array<string>} deleteByUs\n   * @param {Array<string>} deleteByTheirs\n   */\n  constructor(filepaths, bothModified, deleteByUs, deleteByTheirs) {\n    super(`Automatic merge failed with one or more merge conflicts in the following files: ${filepaths.toString()}. Fix conflicts then commit the result.`);\n    this.code = this.name = MergeConflictError.code;\n    this.data = {\n      filepaths,\n      bothModified,\n      deleteByUs,\n      deleteByTheirs\n    };\n  }\n}\n/** @type {'MergeConflictError'} */\nMergeConflictError.code = 'MergeConflictError';\nclass MissingNameError extends BaseError {\n  /**\n   * @param {'author'|'committer'|'tagger'} role\n   */\n  constructor(role) {\n    super(`No name was provided for ${role} in the argument or in the .git/config file.`);\n    this.code = this.name = MissingNameError.code;\n    this.data = {\n      role\n    };\n  }\n}\n/** @type {'MissingNameError'} */\nMissingNameError.code = 'MissingNameError';\nclass MissingParameterError extends BaseError {\n  /**\n   * @param {string} parameter\n   */\n  constructor(parameter) {\n    super(`The function requires a \"${parameter}\" parameter but none was provided.`);\n    this.code = this.name = MissingParameterError.code;\n    this.data = {\n      parameter\n    };\n  }\n}\n/** @type {'MissingParameterError'} */\nMissingParameterError.code = 'MissingParameterError';\nclass MultipleGitError extends BaseError {\n  /**\n   * @param {Error[]} errors\n   * @param {string} message\n   */\n  constructor(errors) {\n    super(`There are multiple errors that were thrown by the method. Please refer to the \"errors\" property to see more`);\n    this.code = this.name = MultipleGitError.code;\n    this.data = {\n      errors\n    };\n    this.errors = errors;\n  }\n}\n/** @type {'MultipleGitError'} */\nMultipleGitError.code = 'MultipleGitError';\nclass ParseError extends BaseError {\n  /**\n   * @param {string} expected\n   * @param {string} actual\n   */\n  constructor(expected, actual) {\n    super(`Expected \"${expected}\" but received \"${actual}\".`);\n    this.code = this.name = ParseError.code;\n    this.data = {\n      expected,\n      actual\n    };\n  }\n}\n/** @type {'ParseError'} */\nParseError.code = 'ParseError';\nclass PushRejectedError extends BaseError {\n  /**\n   * @param {'not-fast-forward'|'tag-exists'} reason\n   */\n  constructor(reason) {\n    let message = '';\n    if (reason === 'not-fast-forward') {\n      message = ' because it was not a simple fast-forward';\n    } else if (reason === 'tag-exists') {\n      message = ' because tag already exists';\n    }\n    super(`Push rejected${message}. Use \"force: true\" to override.`);\n    this.code = this.name = PushRejectedError.code;\n    this.data = {\n      reason\n    };\n  }\n}\n/** @type {'PushRejectedError'} */\nPushRejectedError.code = 'PushRejectedError';\nclass RemoteCapabilityError extends BaseError {\n  /**\n   * @param {'shallow'|'deepen-since'|'deepen-not'|'deepen-relative'} capability\n   * @param {'depth'|'since'|'exclude'|'relative'} parameter\n   */\n  constructor(capability, parameter) {\n    super(`Remote does not support the \"${capability}\" so the \"${parameter}\" parameter cannot be used.`);\n    this.code = this.name = RemoteCapabilityError.code;\n    this.data = {\n      capability,\n      parameter\n    };\n  }\n}\n/** @type {'RemoteCapabilityError'} */\nRemoteCapabilityError.code = 'RemoteCapabilityError';\nclass SmartHttpError extends BaseError {\n  /**\n   * @param {string} preview\n   * @param {string} response\n   */\n  constructor(preview, response) {\n    super(`Remote did not reply using the \"smart\" HTTP protocol. Expected \"001e# service=git-upload-pack\" but received: ${preview}`);\n    this.code = this.name = SmartHttpError.code;\n    this.data = {\n      preview,\n      response\n    };\n  }\n}\n/** @type {'SmartHttpError'} */\nSmartHttpError.code = 'SmartHttpError';\nclass UnknownTransportError extends BaseError {\n  /**\n   * @param {string} url\n   * @param {string} transport\n   * @param {string} [suggestion]\n   */\n  constructor(url, transport, suggestion) {\n    super(`Git remote \"${url}\" uses an unrecognized transport protocol: \"${transport}\"`);\n    this.code = this.name = UnknownTransportError.code;\n    this.data = {\n      url,\n      transport,\n      suggestion\n    };\n  }\n}\n/** @type {'UnknownTransportError'} */\nUnknownTransportError.code = 'UnknownTransportError';\nclass UrlParseError extends BaseError {\n  /**\n   * @param {string} url\n   */\n  constructor(url) {\n    super(`Cannot parse remote URL: \"${url}\"`);\n    this.code = this.name = UrlParseError.code;\n    this.data = {\n      url\n    };\n  }\n}\n/** @type {'UrlParseError'} */\nUrlParseError.code = 'UrlParseError';\nclass UserCanceledError extends BaseError {\n  constructor() {\n    super(`The operation was canceled.`);\n    this.code = this.name = UserCanceledError.code;\n    this.data = {};\n  }\n}\n/** @type {'UserCanceledError'} */\nUserCanceledError.code = 'UserCanceledError';\nclass IndexResetError extends BaseError {\n  /**\n   * @param {Array<string>} filepaths\n   */\n  constructor(filepath) {\n    super(`Could not merge index: Entry for '${filepath}' is not up to date. Either reset the index entry to HEAD, or stage your unstaged chages.`);\n    this.code = this.name = IndexResetError.code;\n    this.data = {\n      filepath\n    };\n  }\n}\n/** @type {'IndexResetError'} */\nIndexResetError.code = 'IndexResetError';\nvar Errors = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  AlreadyExistsError: AlreadyExistsError,\n  AmbiguousError: AmbiguousError,\n  CheckoutConflictError: CheckoutConflictError,\n  CommitNotFetchedError: CommitNotFetchedError,\n  EmptyServerResponseError: EmptyServerResponseError,\n  FastForwardError: FastForwardError,\n  GitPushError: GitPushError,\n  HttpError: HttpError,\n  InternalError: InternalError,\n  InvalidFilepathError: InvalidFilepathError,\n  InvalidOidError: InvalidOidError,\n  InvalidRefNameError: InvalidRefNameError,\n  MaxDepthError: MaxDepthError,\n  MergeNotSupportedError: MergeNotSupportedError,\n  MergeConflictError: MergeConflictError,\n  MissingNameError: MissingNameError,\n  MissingParameterError: MissingParameterError,\n  MultipleGitError: MultipleGitError,\n  NoRefspecError: NoRefspecError,\n  NotFoundError: NotFoundError,\n  ObjectTypeError: ObjectTypeError,\n  ParseError: ParseError,\n  PushRejectedError: PushRejectedError,\n  RemoteCapabilityError: RemoteCapabilityError,\n  SmartHttpError: SmartHttpError,\n  UnknownTransportError: UnknownTransportError,\n  UnsafeFilepathError: UnsafeFilepathError,\n  UrlParseError: UrlParseError,\n  UserCanceledError: UserCanceledError,\n  UnmergedPathsError: UnmergedPathsError,\n  IndexResetError: IndexResetError\n});\nfunction formatAuthor({\n  name,\n  email,\n  timestamp,\n  timezoneOffset\n}) {\n  timezoneOffset = formatTimezoneOffset(timezoneOffset);\n  return `${name} <${email}> ${timestamp} ${timezoneOffset}`;\n}\n\n// The amount of effort that went into crafting these cases to handle\n// -0 (just so we don't lose that information when parsing and reconstructing)\n// but can also default to +0 was extraordinary.\n\nfunction formatTimezoneOffset(minutes) {\n  const sign = simpleSign(negateExceptForZero(minutes));\n  minutes = Math.abs(minutes);\n  const hours = Math.floor(minutes / 60);\n  minutes -= hours * 60;\n  let strHours = String(hours);\n  let strMinutes = String(minutes);\n  if (strHours.length < 2) strHours = '0' + strHours;\n  if (strMinutes.length < 2) strMinutes = '0' + strMinutes;\n  return (sign === -1 ? '-' : '+') + strHours + strMinutes;\n}\nfunction simpleSign(n) {\n  return Math.sign(n) || (Object.is(n, -0) ? -1 : 1);\n}\nfunction negateExceptForZero(n) {\n  return n === 0 ? n : -n;\n}\nfunction normalizeNewlines(str) {\n  // remove all <CR>\n  str = str.replace(/\\r/g, '');\n  // no extra newlines up front\n  str = str.replace(/^\\n+/, '');\n  // and a single newline at the end\n  str = str.replace(/\\n+$/, '') + '\\n';\n  return str;\n}\nfunction parseAuthor(author) {\n  const [, name, email, timestamp, offset] = author.match(/^(.*) <(.*)> (.*) (.*)$/);\n  return {\n    name: name,\n    email: email,\n    timestamp: Number(timestamp),\n    timezoneOffset: parseTimezoneOffset(offset)\n  };\n}\n\n// The amount of effort that went into crafting these cases to handle\n// -0 (just so we don't lose that information when parsing and reconstructing)\n// but can also default to +0 was extraordinary.\n\nfunction parseTimezoneOffset(offset) {\n  let [, sign, hours, minutes] = offset.match(/(\\+|-)(\\d\\d)(\\d\\d)/);\n  minutes = (sign === '+' ? 1 : -1) * (Number(hours) * 60 + Number(minutes));\n  return negateExceptForZero$1(minutes);\n}\nfunction negateExceptForZero$1(n) {\n  return n === 0 ? n : -n;\n}\nclass GitAnnotatedTag {\n  constructor(tag) {\n    if (typeof tag === 'string') {\n      this._tag = tag;\n    } else if (Buffer.isBuffer(tag)) {\n      this._tag = tag.toString('utf8');\n    } else if (typeof tag === 'object') {\n      this._tag = GitAnnotatedTag.render(tag);\n    } else {\n      throw new InternalError('invalid type passed to GitAnnotatedTag constructor');\n    }\n  }\n  static from(tag) {\n    return new GitAnnotatedTag(tag);\n  }\n  static render(obj) {\n    return `object ${obj.object}\ntype ${obj.type}\ntag ${obj.tag}\ntagger ${formatAuthor(obj.tagger)}\n\n${obj.message}\n${obj.gpgsig ? obj.gpgsig : ''}`;\n  }\n  justHeaders() {\n    return this._tag.slice(0, this._tag.indexOf('\\n\\n'));\n  }\n  message() {\n    const tag = this.withoutSignature();\n    return tag.slice(tag.indexOf('\\n\\n') + 2);\n  }\n  parse() {\n    return Object.assign(this.headers(), {\n      message: this.message(),\n      gpgsig: this.gpgsig()\n    });\n  }\n  render() {\n    return this._tag;\n  }\n  headers() {\n    const headers = this.justHeaders().split('\\n');\n    const hs = [];\n    for (const h of headers) {\n      if (h[0] === ' ') {\n        // combine with previous header (without space indent)\n        hs[hs.length - 1] += '\\n' + h.slice(1);\n      } else {\n        hs.push(h);\n      }\n    }\n    const obj = {};\n    for (const h of hs) {\n      const key = h.slice(0, h.indexOf(' '));\n      const value = h.slice(h.indexOf(' ') + 1);\n      if (Array.isArray(obj[key])) {\n        obj[key].push(value);\n      } else {\n        obj[key] = value;\n      }\n    }\n    if (obj.tagger) {\n      obj.tagger = parseAuthor(obj.tagger);\n    }\n    if (obj.committer) {\n      obj.committer = parseAuthor(obj.committer);\n    }\n    return obj;\n  }\n  withoutSignature() {\n    const tag = normalizeNewlines(this._tag);\n    if (tag.indexOf('\\n-----BEGIN PGP SIGNATURE-----') === -1) return tag;\n    return tag.slice(0, tag.lastIndexOf('\\n-----BEGIN PGP SIGNATURE-----'));\n  }\n  gpgsig() {\n    if (this._tag.indexOf('\\n-----BEGIN PGP SIGNATURE-----') === -1) return;\n    const signature = this._tag.slice(this._tag.indexOf('-----BEGIN PGP SIGNATURE-----'), this._tag.indexOf('-----END PGP SIGNATURE-----') + '-----END PGP SIGNATURE-----'.length);\n    return normalizeNewlines(signature);\n  }\n  payload() {\n    return this.withoutSignature() + '\\n';\n  }\n  toObject() {\n    return Buffer.from(this._tag, 'utf8');\n  }\n  static async sign(tag, sign, secretKey) {\n    const payload = tag.payload();\n    let {\n      signature\n    } = await sign({\n      payload,\n      secretKey\n    });\n    // renormalize the line endings to the one true line-ending\n    signature = normalizeNewlines(signature);\n    const signedTag = payload + signature;\n    // return a new tag object\n    return GitAnnotatedTag.from(signedTag);\n  }\n}\nfunction indent(str) {\n  return str.trim().split('\\n').map(x => ' ' + x).join('\\n') + '\\n';\n}\nfunction outdent(str) {\n  return str.split('\\n').map(x => x.replace(/^ /, '')).join('\\n');\n}\nclass GitCommit {\n  constructor(commit) {\n    if (typeof commit === 'string') {\n      this._commit = commit;\n    } else if (Buffer.isBuffer(commit)) {\n      this._commit = commit.toString('utf8');\n    } else if (typeof commit === 'object') {\n      this._commit = GitCommit.render(commit);\n    } else {\n      throw new InternalError('invalid type passed to GitCommit constructor');\n    }\n  }\n  static fromPayloadSignature({\n    payload,\n    signature\n  }) {\n    const headers = GitCommit.justHeaders(payload);\n    const message = GitCommit.justMessage(payload);\n    const commit = normalizeNewlines(headers + '\\ngpgsig' + indent(signature) + '\\n' + message);\n    return new GitCommit(commit);\n  }\n  static from(commit) {\n    return new GitCommit(commit);\n  }\n  toObject() {\n    return Buffer.from(this._commit, 'utf8');\n  }\n\n  // Todo: allow setting the headers and message\n  headers() {\n    return this.parseHeaders();\n  }\n\n  // Todo: allow setting the headers and message\n  message() {\n    return GitCommit.justMessage(this._commit);\n  }\n  parse() {\n    return Object.assign({\n      message: this.message()\n    }, this.headers());\n  }\n  static justMessage(commit) {\n    return normalizeNewlines(commit.slice(commit.indexOf('\\n\\n') + 2));\n  }\n  static justHeaders(commit) {\n    return commit.slice(0, commit.indexOf('\\n\\n'));\n  }\n  parseHeaders() {\n    const headers = GitCommit.justHeaders(this._commit).split('\\n');\n    const hs = [];\n    for (const h of headers) {\n      if (h[0] === ' ') {\n        // combine with previous header (without space indent)\n        hs[hs.length - 1] += '\\n' + h.slice(1);\n      } else {\n        hs.push(h);\n      }\n    }\n    const obj = {\n      parent: []\n    };\n    for (const h of hs) {\n      const key = h.slice(0, h.indexOf(' '));\n      const value = h.slice(h.indexOf(' ') + 1);\n      if (Array.isArray(obj[key])) {\n        obj[key].push(value);\n      } else {\n        obj[key] = value;\n      }\n    }\n    if (obj.author) {\n      obj.author = parseAuthor(obj.author);\n    }\n    if (obj.committer) {\n      obj.committer = parseAuthor(obj.committer);\n    }\n    return obj;\n  }\n  static renderHeaders(obj) {\n    let headers = '';\n    if (obj.tree) {\n      headers += `tree ${obj.tree}\\n`;\n    } else {\n      headers += `tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904\\n`; // the null tree\n    }\n    if (obj.parent) {\n      if (obj.parent.length === undefined) {\n        throw new InternalError(`commit 'parent' property should be an array`);\n      }\n      for (const p of obj.parent) {\n        headers += `parent ${p}\\n`;\n      }\n    }\n    const author = obj.author;\n    headers += `author ${formatAuthor(author)}\\n`;\n    const committer = obj.committer || obj.author;\n    headers += `committer ${formatAuthor(committer)}\\n`;\n    if (obj.gpgsig) {\n      headers += 'gpgsig' + indent(obj.gpgsig);\n    }\n    return headers;\n  }\n  static render(obj) {\n    return GitCommit.renderHeaders(obj) + '\\n' + normalizeNewlines(obj.message);\n  }\n  render() {\n    return this._commit;\n  }\n  withoutSignature() {\n    const commit = normalizeNewlines(this._commit);\n    if (commit.indexOf('\\ngpgsig') === -1) return commit;\n    const headers = commit.slice(0, commit.indexOf('\\ngpgsig'));\n    const message = commit.slice(commit.indexOf('-----END PGP SIGNATURE-----\\n') + '-----END PGP SIGNATURE-----\\n'.length);\n    return normalizeNewlines(headers + '\\n' + message);\n  }\n  isolateSignature() {\n    const signature = this._commit.slice(this._commit.indexOf('-----BEGIN PGP SIGNATURE-----'), this._commit.indexOf('-----END PGP SIGNATURE-----') + '-----END PGP SIGNATURE-----'.length);\n    return outdent(signature);\n  }\n  static async sign(commit, sign, secretKey) {\n    const payload = commit.withoutSignature();\n    const message = GitCommit.justMessage(commit._commit);\n    let {\n      signature\n    } = await sign({\n      payload,\n      secretKey\n    });\n    // renormalize the line endings to the one true line-ending\n    signature = normalizeNewlines(signature);\n    const headers = GitCommit.justHeaders(commit._commit);\n    const signedCommit = headers + '\\n' + 'gpgsig' + indent(signature) + '\\n' + message;\n    // return a new commit object\n    return GitCommit.from(signedCommit);\n  }\n}\nasync function resolveTree({\n  fs,\n  cache,\n  gitdir,\n  oid\n}) {\n  // Empty tree - bypass `readObject`\n  if (oid === '4b825dc642cb6eb9a060e54bf8d69288fbee4904') {\n    return {\n      tree: GitTree.from([]),\n      oid\n    };\n  }\n  const {\n    type,\n    object\n  } = await _readObject({\n    fs,\n    cache,\n    gitdir,\n    oid\n  });\n  // Resolve annotated tag objects to whatever\n  if (type === 'tag') {\n    oid = GitAnnotatedTag.from(object).parse().object;\n    return resolveTree({\n      fs,\n      cache,\n      gitdir,\n      oid\n    });\n  }\n  // Resolve commits to trees\n  if (type === 'commit') {\n    oid = GitCommit.from(object).parse().tree;\n    return resolveTree({\n      fs,\n      cache,\n      gitdir,\n      oid\n    });\n  }\n  if (type !== 'tree') {\n    throw new ObjectTypeError(oid, type, 'tree');\n  }\n  return {\n    tree: GitTree.from(object),\n    oid\n  };\n}\nclass GitWalkerRepo {\n  constructor({\n    fs,\n    gitdir,\n    ref,\n    cache\n  }) {\n    this.fs = fs;\n    this.cache = cache;\n    this.gitdir = gitdir;\n    this.mapPromise = (async () => {\n      const map = new Map();\n      let oid;\n      try {\n        oid = await GitRefManager.resolve({\n          fs,\n          gitdir,\n          ref\n        });\n      } catch (e) {\n        if (e instanceof NotFoundError) {\n          // Handle fresh branches with no commits\n          oid = '4b825dc642cb6eb9a060e54bf8d69288fbee4904';\n        }\n      }\n      const tree = await resolveTree({\n        fs,\n        cache: this.cache,\n        gitdir,\n        oid\n      });\n      tree.type = 'tree';\n      tree.mode = '40000';\n      map.set('.', tree);\n      return map;\n    })();\n    const walker = this;\n    this.ConstructEntry = class TreeEntry {\n      constructor(fullpath) {\n        this._fullpath = fullpath;\n        this._type = false;\n        this._mode = false;\n        this._stat = false;\n        this._content = false;\n        this._oid = false;\n      }\n      async type() {\n        return walker.type(this);\n      }\n      async mode() {\n        return walker.mode(this);\n      }\n      async stat() {\n        return walker.stat(this);\n      }\n      async content() {\n        return walker.content(this);\n      }\n      async oid() {\n        return walker.oid(this);\n      }\n    };\n  }\n  async readdir(entry) {\n    const filepath = entry._fullpath;\n    const {\n      fs,\n      cache,\n      gitdir\n    } = this;\n    const map = await this.mapPromise;\n    const obj = map.get(filepath);\n    if (!obj) throw new Error(`No obj for ${filepath}`);\n    const oid = obj.oid;\n    if (!oid) throw new Error(`No oid for obj ${JSON.stringify(obj)}`);\n    if (obj.type !== 'tree') {\n      // TODO: support submodules (type === 'commit')\n      return null;\n    }\n    const {\n      type,\n      object\n    } = await _readObject({\n      fs,\n      cache,\n      gitdir,\n      oid\n    });\n    if (type !== obj.type) {\n      throw new ObjectTypeError(oid, type, obj.type);\n    }\n    const tree = GitTree.from(object);\n    // cache all entries\n    for (const entry of tree) {\n      map.set(join(filepath, entry.path), entry);\n    }\n    return tree.entries().map(entry => join(filepath, entry.path));\n  }\n  async type(entry) {\n    if (entry._type === false) {\n      const map = await this.mapPromise;\n      const {\n        type\n      } = map.get(entry._fullpath);\n      entry._type = type;\n    }\n    return entry._type;\n  }\n  async mode(entry) {\n    if (entry._mode === false) {\n      const map = await this.mapPromise;\n      const {\n        mode\n      } = map.get(entry._fullpath);\n      entry._mode = normalizeMode(parseInt(mode, 8));\n    }\n    return entry._mode;\n  }\n  async stat(_entry) {}\n  async content(entry) {\n    if (entry._content === false) {\n      const map = await this.mapPromise;\n      const {\n        fs,\n        cache,\n        gitdir\n      } = this;\n      const obj = map.get(entry._fullpath);\n      const oid = obj.oid;\n      const {\n        type,\n        object\n      } = await _readObject({\n        fs,\n        cache,\n        gitdir,\n        oid\n      });\n      if (type !== 'blob') {\n        entry._content = undefined;\n      } else {\n        entry._content = new Uint8Array(object);\n      }\n    }\n    return entry._content;\n  }\n  async oid(entry) {\n    if (entry._oid === false) {\n      const map = await this.mapPromise;\n      const obj = map.get(entry._fullpath);\n      entry._oid = obj.oid;\n    }\n    return entry._oid;\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {string} [args.ref='HEAD']\n * @returns {Walker}\n */\nfunction TREE({\n  ref = 'HEAD'\n} = {}) {\n  const o = Object.create(null);\n  Object.defineProperty(o, GitWalkSymbol, {\n    value: function ({\n      fs,\n      gitdir,\n      cache\n    }) {\n      return new GitWalkerRepo({\n        fs,\n        gitdir,\n        ref,\n        cache\n      });\n    }\n  });\n  Object.freeze(o);\n  return o;\n}\n\n// @ts-check\n\nclass GitWalkerFs {\n  constructor({\n    fs,\n    dir,\n    gitdir,\n    cache\n  }) {\n    this.fs = fs;\n    this.cache = cache;\n    this.dir = dir;\n    this.gitdir = gitdir;\n    const walker = this;\n    this.ConstructEntry = class WorkdirEntry {\n      constructor(fullpath) {\n        this._fullpath = fullpath;\n        this._type = false;\n        this._mode = false;\n        this._stat = false;\n        this._content = false;\n        this._oid = false;\n      }\n      async type() {\n        return walker.type(this);\n      }\n      async mode() {\n        return walker.mode(this);\n      }\n      async stat() {\n        return walker.stat(this);\n      }\n      async content() {\n        return walker.content(this);\n      }\n      async oid() {\n        return walker.oid(this);\n      }\n    };\n  }\n  async readdir(entry) {\n    const filepath = entry._fullpath;\n    const {\n      fs,\n      dir\n    } = this;\n    const names = await fs.readdir(join(dir, filepath));\n    if (names === null) return null;\n    return names.map(name => join(filepath, name));\n  }\n  async type(entry) {\n    if (entry._type === false) {\n      await entry.stat();\n    }\n    return entry._type;\n  }\n  async mode(entry) {\n    if (entry._mode === false) {\n      await entry.stat();\n    }\n    return entry._mode;\n  }\n  async stat(entry) {\n    if (entry._stat === false) {\n      const {\n        fs,\n        dir\n      } = this;\n      let stat = await fs.lstat(`${dir}/${entry._fullpath}`);\n      if (!stat) {\n        throw new Error(`ENOENT: no such file or directory, lstat '${entry._fullpath}'`);\n      }\n      let type = stat.isDirectory() ? 'tree' : 'blob';\n      if (type === 'blob' && !stat.isFile() && !stat.isSymbolicLink()) {\n        type = 'special';\n      }\n      entry._type = type;\n      stat = normalizeStats(stat);\n      entry._mode = stat.mode;\n      // workaround for a BrowserFS edge case\n      if (stat.size === -1 && entry._actualSize) {\n        stat.size = entry._actualSize;\n      }\n      entry._stat = stat;\n    }\n    return entry._stat;\n  }\n  async content(entry) {\n    if (entry._content === false) {\n      const {\n        fs,\n        dir\n      } = this;\n      if ((await entry.type()) === 'tree') {\n        entry._content = undefined;\n      } else {\n        const content = await fs.read(`${dir}/${entry._fullpath}`);\n        // workaround for a BrowserFS edge case\n        entry._actualSize = content.length;\n        if (entry._stat && entry._stat.size === -1) {\n          entry._stat.size = entry._actualSize;\n        }\n        entry._content = new Uint8Array(content);\n      }\n    }\n    return entry._content;\n  }\n  async oid(entry) {\n    if (entry._oid === false) {\n      const {\n        fs,\n        gitdir,\n        cache\n      } = this;\n      let oid;\n      // See if we can use the SHA1 hash in the index.\n      await GitIndexManager.acquire({\n        fs,\n        gitdir,\n        cache\n      }, async function (index) {\n        const stage = index.entriesMap.get(entry._fullpath);\n        const stats = await entry.stat();\n        if (!stage || compareStats(stats, stage)) {\n          const content = await entry.content();\n          if (content === undefined) {\n            oid = undefined;\n          } else {\n            oid = await shasum(GitObject.wrap({\n              type: 'blob',\n              object: await entry.content()\n            }));\n            // Update the stats in the index so we will get a \"cache hit\" next time\n            // 1) if we can (because the oid and mode are the same)\n            // 2) and only if we need to (because other stats differ)\n            if (stage && oid === stage.oid && stats.mode === stage.mode && compareStats(stats, stage)) {\n              index.insert({\n                filepath: entry._fullpath,\n                stats,\n                oid: oid\n              });\n            }\n          }\n        } else {\n          // Use the index SHA1 rather than compute it\n          oid = stage.oid;\n        }\n      });\n      entry._oid = oid;\n    }\n    return entry._oid;\n  }\n}\n\n// @ts-check\n\n/**\n * @returns {Walker}\n */\nfunction WORKDIR() {\n  const o = Object.create(null);\n  Object.defineProperty(o, GitWalkSymbol, {\n    value: function ({\n      fs,\n      dir,\n      gitdir,\n      cache\n    }) {\n      return new GitWalkerFs({\n        fs,\n        dir,\n        gitdir,\n        cache\n      });\n    }\n  });\n  Object.freeze(o);\n  return o;\n}\n\n// @ts-check\n\n// https://dev.to/namirsab/comment/2050\nfunction arrayRange(start, end) {\n  const length = end - start;\n  return Array.from({\n    length\n  }, (_, i) => start + i);\n}\n\n// TODO: Should I just polyfill Array.flat?\nconst flat = typeof Array.prototype.flat === 'undefined' ? entries => entries.reduce((acc, x) => acc.concat(x), []) : entries => entries.flat();\n\n// This is convenient for computing unions/joins of sorted lists.\nclass RunningMinimum {\n  constructor() {\n    // Using a getter for 'value' would just bloat the code.\n    // You know better than to set it directly right?\n    this.value = null;\n  }\n  consider(value) {\n    if (value === null || value === undefined) return;\n    if (this.value === null) {\n      this.value = value;\n    } else if (value < this.value) {\n      this.value = value;\n    }\n  }\n  reset() {\n    this.value = null;\n  }\n}\n\n// Take an array of length N of\n//   iterators of length Q_n\n//     of strings\n// and return an iterator of length max(Q_n) for all n\n//   of arrays of length N\n//     of string|null who all have the same string value\nfunction* unionOfIterators(sets) {\n  /* NOTE: We can assume all arrays are sorted.\n   * Indexes are sorted because they are defined that way:\n   *\n   * > Index entries are sorted in ascending order on the name field,\n   * > interpreted as a string of unsigned bytes (i.e. memcmp() order, no\n   * > localization, no special casing of directory separator '/'). Entries\n   * > with the same name are sorted by their stage field.\n   *\n   * Trees should be sorted because they are created directly from indexes.\n   * They definitely should be sorted, or else they wouldn't have a unique SHA1.\n   * So that would be very naughty on the part of the tree-creator.\n   *\n   * Lastly, the working dir entries are sorted because I choose to sort them\n   * in my FileSystem.readdir() implementation.\n   */\n\n  // Init\n  const min = new RunningMinimum();\n  let minimum;\n  const heads = [];\n  const numsets = sets.length;\n  for (let i = 0; i < numsets; i++) {\n    // Abuse the fact that iterators continue to return 'undefined' for value\n    // once they are done\n    heads[i] = sets[i].next().value;\n    if (heads[i] !== undefined) {\n      min.consider(heads[i]);\n    }\n  }\n  if (min.value === null) return;\n  // Iterate\n  while (true) {\n    const result = [];\n    minimum = min.value;\n    min.reset();\n    for (let i = 0; i < numsets; i++) {\n      if (heads[i] !== undefined && heads[i] === minimum) {\n        result[i] = heads[i];\n        heads[i] = sets[i].next().value;\n      } else {\n        // A little hacky, but eh\n        result[i] = null;\n      }\n      if (heads[i] !== undefined) {\n        min.consider(heads[i]);\n      }\n    }\n    yield result;\n    if (min.value === null) return;\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {string} [args.dir]\n * @param {string} [args.gitdir=join(dir,'.git')]\n * @param {Walker[]} args.trees\n * @param {WalkerMap} [args.map]\n * @param {WalkerReduce} [args.reduce]\n * @param {WalkerIterate} [args.iterate]\n *\n * @returns {Promise<any>} The finished tree-walking result\n *\n * @see {WalkerMap}\n *\n */\nasync function _walk({\n  fs,\n  cache,\n  dir,\n  gitdir,\n  trees,\n  // @ts-ignore\n  map = async (_, entry) => entry,\n  // The default reducer is a flatmap that filters out undefineds.\n  reduce = async (parent, children) => {\n    const flatten = flat(children);\n    if (parent !== undefined) flatten.unshift(parent);\n    return flatten;\n  },\n  // The default iterate function walks all children concurrently\n  iterate = (walk, children) => Promise.all([...children].map(walk))\n}) {\n  const walkers = trees.map(proxy => proxy[GitWalkSymbol]({\n    fs,\n    dir,\n    gitdir,\n    cache\n  }));\n  const root = new Array(walkers.length).fill('.');\n  const range = arrayRange(0, walkers.length);\n  const unionWalkerFromReaddir = async entries => {\n    range.map(i => {\n      entries[i] = entries[i] && new walkers[i].ConstructEntry(entries[i]);\n    });\n    const subdirs = await Promise.all(range.map(i => entries[i] ? walkers[i].readdir(entries[i]) : []));\n    // Now process child directories\n    const iterators = subdirs.map(array => array === null ? [] : array).map(array => array[Symbol.iterator]());\n    return {\n      entries,\n      children: unionOfIterators(iterators)\n    };\n  };\n  const walk = async root => {\n    const {\n      entries,\n      children\n    } = await unionWalkerFromReaddir(root);\n    const fullpath = entries.find(entry => entry && entry._fullpath)._fullpath;\n    const parent = await map(fullpath, entries);\n    if (parent !== null) {\n      let walkedChildren = await iterate(walk, children);\n      walkedChildren = walkedChildren.filter(x => x !== undefined);\n      return reduce(parent, walkedChildren);\n    }\n  };\n  return walk(root);\n}\n\n/**\n * Removes the directory at the specified filepath recursively. Used internally to replicate the behavior of\n * fs.promises.rm({ recursive: true, force: true }) from Node.js 14 and above when not available. If the provided\n * filepath resolves to a file, it will be removed.\n *\n * @param {import('../models/FileSystem.js').FileSystem} fs\n * @param {string} filepath - The file or directory to remove.\n */\nasync function rmRecursive(fs, filepath) {\n  const entries = await fs.readdir(filepath);\n  if (entries == null) {\n    await fs.rm(filepath);\n  } else if (entries.length) {\n    await Promise.all(entries.map(entry => {\n      const subpath = join(filepath, entry);\n      return fs.lstat(subpath).then(stat => {\n        if (!stat) return;\n        return stat.isDirectory() ? rmRecursive(fs, subpath) : fs.rm(subpath);\n      });\n    })).then(() => fs.rmdir(filepath));\n  } else {\n    await fs.rmdir(filepath);\n  }\n}\nfunction isPromiseLike(obj) {\n  return isObject(obj) && isFunction(obj.then) && isFunction(obj.catch);\n}\nfunction isObject(obj) {\n  return obj && typeof obj === 'object';\n}\nfunction isFunction(obj) {\n  return typeof obj === 'function';\n}\nfunction isPromiseFs(fs) {\n  const test = targetFs => {\n    try {\n      // If readFile returns a promise then we can probably assume the other\n      // commands do as well\n      return targetFs.readFile().catch(e => e);\n    } catch (e) {\n      return e;\n    }\n  };\n  return isPromiseLike(test(fs));\n}\n\n// List of commands all filesystems are expected to provide. `rm` is not\n// included since it may not exist and must be handled as a special case\nconst commands = ['readFile', 'writeFile', 'mkdir', 'rmdir', 'unlink', 'stat', 'lstat', 'readdir', 'readlink', 'symlink'];\nfunction bindFs(target, fs) {\n  if (isPromiseFs(fs)) {\n    for (const command of commands) {\n      target[`_${command}`] = fs[command].bind(fs);\n    }\n  } else {\n    for (const command of commands) {\n      target[`_${command}`] = pify(fs[command].bind(fs));\n    }\n  }\n\n  // Handle the special case of `rm`\n  if (isPromiseFs(fs)) {\n    if (fs.rm) target._rm = fs.rm.bind(fs);else if (fs.rmdir.length > 1) target._rm = fs.rmdir.bind(fs);else target._rm = rmRecursive.bind(null, target);\n  } else {\n    if (fs.rm) target._rm = pify(fs.rm.bind(fs));else if (fs.rmdir.length > 2) target._rm = pify(fs.rmdir.bind(fs));else target._rm = rmRecursive.bind(null, target);\n  }\n}\n\n/**\n * This is just a collection of helper functions really. At least that's how it started.\n */\nclass FileSystem {\n  constructor(fs) {\n    if (typeof fs._original_unwrapped_fs !== 'undefined') return fs;\n    const promises = Object.getOwnPropertyDescriptor(fs, 'promises');\n    if (promises && promises.enumerable) {\n      bindFs(this, fs.promises);\n    } else {\n      bindFs(this, fs);\n    }\n    this._original_unwrapped_fs = fs;\n  }\n\n  /**\n   * Return true if a file exists, false if it doesn't exist.\n   * Rethrows errors that aren't related to file existance.\n   */\n  async exists(filepath, options = {}) {\n    try {\n      await this._stat(filepath);\n      return true;\n    } catch (err) {\n      if (err.code === 'ENOENT' || err.code === 'ENOTDIR') {\n        return false;\n      } else {\n        console.log('Unhandled error in \"FileSystem.exists()\" function', err);\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Return the contents of a file if it exists, otherwise returns null.\n   *\n   * @param {string} filepath\n   * @param {object} [options]\n   *\n   * @returns {Promise<Buffer|string|null>}\n   */\n  async read(filepath, options = {}) {\n    try {\n      let buffer = await this._readFile(filepath, options);\n      // Convert plain ArrayBuffers to Buffers\n      if (typeof buffer !== 'string') {\n        buffer = Buffer.from(buffer);\n      }\n      return buffer;\n    } catch (err) {\n      return null;\n    }\n  }\n\n  /**\n   * Write a file (creating missing directories if need be) without throwing errors.\n   *\n   * @param {string} filepath\n   * @param {Buffer|Uint8Array|string} contents\n   * @param {object|string} [options]\n   */\n  async write(filepath, contents, options = {}) {\n    try {\n      await this._writeFile(filepath, contents, options);\n      return;\n    } catch (err) {\n      // Hmm. Let's try mkdirp and try again.\n      await this.mkdir(dirname(filepath));\n      await this._writeFile(filepath, contents, options);\n    }\n  }\n\n  /**\n   * Make a directory (or series of nested directories) without throwing an error if it already exists.\n   */\n  async mkdir(filepath, _selfCall = false) {\n    try {\n      await this._mkdir(filepath);\n      return;\n    } catch (err) {\n      // If err is null then operation succeeded!\n      if (err === null) return;\n      // If the directory already exists, that's OK!\n      if (err.code === 'EEXIST') return;\n      // Avoid infinite loops of failure\n      if (_selfCall) throw err;\n      // If we got a \"no such file or directory error\" backup and try again.\n      if (err.code === 'ENOENT') {\n        const parent = dirname(filepath);\n        // Check to see if we've gone too far\n        if (parent === '.' || parent === '/' || parent === filepath) throw err;\n        // Infinite recursion, what could go wrong?\n        await this.mkdir(parent);\n        await this.mkdir(filepath, true);\n      }\n    }\n  }\n\n  /**\n   * Delete a file without throwing an error if it is already deleted.\n   */\n  async rm(filepath) {\n    try {\n      await this._unlink(filepath);\n    } catch (err) {\n      if (err.code !== 'ENOENT') throw err;\n    }\n  }\n\n  /**\n   * Delete a directory without throwing an error if it is already deleted.\n   */\n  async rmdir(filepath, opts) {\n    try {\n      if (opts && opts.recursive) {\n        await this._rm(filepath, opts);\n      } else {\n        await this._rmdir(filepath);\n      }\n    } catch (err) {\n      if (err.code !== 'ENOENT') throw err;\n    }\n  }\n\n  /**\n   * Read a directory without throwing an error is the directory doesn't exist\n   */\n  async readdir(filepath) {\n    try {\n      const names = await this._readdir(filepath);\n      // Ordering is not guaranteed, and system specific (Windows vs Unix)\n      // so we must sort them ourselves.\n      names.sort(compareStrings);\n      return names;\n    } catch (err) {\n      if (err.code === 'ENOTDIR') return null;\n      return [];\n    }\n  }\n\n  /**\n   * Return a flast list of all the files nested inside a directory\n   *\n   * Based on an elegant concurrent recursive solution from SO\n   * https://stackoverflow.com/a/45130990/2168416\n   */\n  async readdirDeep(dir) {\n    const subdirs = await this._readdir(dir);\n    const files = await Promise.all(subdirs.map(async subdir => {\n      const res = dir + '/' + subdir;\n      return (await this._stat(res)).isDirectory() ? this.readdirDeep(res) : res;\n    }));\n    return files.reduce((a, f) => a.concat(f), []);\n  }\n\n  /**\n   * Return the Stats of a file/symlink if it exists, otherwise returns null.\n   * Rethrows errors that aren't related to file existance.\n   */\n  async lstat(filename) {\n    try {\n      const stats = await this._lstat(filename);\n      return stats;\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        return null;\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Reads the contents of a symlink if it exists, otherwise returns null.\n   * Rethrows errors that aren't related to file existance.\n   */\n  async readlink(filename, opts = {\n    encoding: 'buffer'\n  }) {\n    // Note: FileSystem.readlink returns a buffer by default\n    // so we can dump it into GitObject.write just like any other file.\n    try {\n      const link = await this._readlink(filename, opts);\n      return Buffer.isBuffer(link) ? link : Buffer.from(link);\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        return null;\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Write the contents of buffer to a symlink.\n   */\n  async writelink(filename, buffer) {\n    return this._symlink(buffer.toString('utf8'), filename);\n  }\n}\nfunction assertParameter(name, value) {\n  if (value === undefined) {\n    throw new MissingParameterError(name);\n  }\n}\n\n// @ts-check\n/**\n *\n * @param {WalkerEntry} entry\n * @param {WalkerEntry} base\n *\n */\nasync function modified(entry, base) {\n  if (!entry && !base) return false;\n  if (entry && !base) return true;\n  if (!entry && base) return true;\n  if ((await entry.type()) === 'tree' && (await base.type()) === 'tree') {\n    return false;\n  }\n  if ((await entry.type()) === (await base.type()) && (await entry.mode()) === (await base.mode()) && (await entry.oid()) === (await base.oid())) {\n    return false;\n  }\n  return true;\n}\n\n// @ts-check\n\n/**\n * Abort a merge in progress.\n *\n * Based on the behavior of git reset --merge, i.e.  \"Resets the index and updates the files in the working tree that are different between <commit> and HEAD, but keeps those which are different between the index and working tree (i.e. which have changes which have not been added). If a file that is different between <commit> and the index has unstaged changes, reset is aborted.\"\n *\n * Essentially, abortMerge will reset any files affected by merge conflicts to their last known good version at HEAD.\n * Any unstaged changes are saved and any staged changes are reset as well.\n *\n * NOTE: The behavior of this command differs slightly from canonical git in that an error will be thrown if a file exists in the index and nowhere else.\n * Canonical git will reset the file and continue aborting the merge in this case.\n *\n * **WARNING:** Running git merge with non-trivial uncommitted changes is discouraged: while possible, it may leave you in a state that is hard to back out of in the case of a conflict.\n * If there were uncommitted changes when the merge started (and especially if those changes were further modified after the merge was started), `git.abortMerge` will in some cases be unable to reconstruct the original (pre-merge) changes.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.commit='HEAD'] - commit to reset the index and worktree to, defaults to HEAD\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully once the git index has been updated\n *\n */\nasync function abortMerge({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  commit = 'HEAD',\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('dir', dir);\n    assertParameter('gitdir', gitdir);\n    const fs = new FileSystem(_fs);\n    const trees = [TREE({\n      ref: commit\n    }), WORKDIR(), STAGE()];\n    let unmergedPaths = [];\n    await GitIndexManager.acquire({\n      fs,\n      gitdir,\n      cache\n    }, async function (index) {\n      unmergedPaths = index.unmergedPaths;\n    });\n    const results = await _walk({\n      fs,\n      cache,\n      dir,\n      gitdir,\n      trees,\n      map: async function (path, [head, workdir, index]) {\n        const staged = !(await modified(workdir, index));\n        const unmerged = unmergedPaths.includes(path);\n        const unmodified = !(await modified(index, head));\n        if (staged || unmerged) {\n          return head ? {\n            path,\n            mode: await head.mode(),\n            oid: await head.oid(),\n            type: await head.type(),\n            content: await head.content()\n          } : undefined;\n        }\n        if (unmodified) return false;else throw new IndexResetError(path);\n      }\n    });\n    await GitIndexManager.acquire({\n      fs,\n      gitdir,\n      cache\n    }, async function (index) {\n      // Reset paths in index and worktree, this can't be done in _walk because the\n      // STAGE walker acquires its own index lock.\n\n      for (const entry of results) {\n        if (entry === false) continue;\n\n        // entry is not false, so from here we can assume index = workdir\n        if (!entry) {\n          await fs.rmdir(`${dir}/${entry.path}`, {\n            recursive: true\n          });\n          index.delete({\n            filepath: entry.path\n          });\n          continue;\n        }\n        if (entry.type === 'blob') {\n          const content = new TextDecoder().decode(entry.content);\n          await fs.write(`${dir}/${entry.path}`, content, {\n            mode: entry.mode\n          });\n          index.insert({\n            filepath: entry.path,\n            oid: entry.oid,\n            stage: 0\n          });\n        }\n      }\n    });\n  } catch (err) {\n    err.caller = 'git.abortMerge';\n    throw err;\n  }\n}\n\n// I'm putting this in a Manager because I reckon it could benefit\n// from a LOT of cacheing.\nclass GitIgnoreManager {\n  static async isIgnored({\n    fs,\n    dir,\n    gitdir = join(dir, '.git'),\n    filepath\n  }) {\n    // ALWAYS ignore \".git\" folders.\n    if (basename(filepath) === '.git') return true;\n    // '.' is not a valid gitignore entry, so '.' is never ignored\n    if (filepath === '.') return false;\n    // Check and load exclusion rules from project exclude file (.git/info/exclude)\n    let excludes = '';\n    const excludesFile = join(gitdir, 'info', 'exclude');\n    if (await fs.exists(excludesFile)) {\n      excludes = await fs.read(excludesFile, 'utf8');\n    }\n    // Find all the .gitignore files that could affect this file\n    const pairs = [{\n      gitignore: join(dir, '.gitignore'),\n      filepath\n    }];\n    const pieces = filepath.split('/').filter(Boolean);\n    for (let i = 1; i < pieces.length; i++) {\n      const folder = pieces.slice(0, i).join('/');\n      const file = pieces.slice(i).join('/');\n      pairs.push({\n        gitignore: join(dir, folder, '.gitignore'),\n        filepath: file\n      });\n    }\n    let ignoredStatus = false;\n    for (const p of pairs) {\n      let file;\n      try {\n        file = await fs.read(p.gitignore, 'utf8');\n      } catch (err) {\n        if (err.code === 'NOENT') continue;\n      }\n      const ign = ignore().add(excludes);\n      ign.add(file);\n      // If the parent directory is excluded, we are done.\n      // \"It is not possible to re-include a file if a parent directory of that file is excluded. Git doesnt list excluded directories for performance reasons, so any patterns on contained files have no effect, no matter where they are defined.\"\n      // source: https://git-scm.com/docs/gitignore\n      const parentdir = dirname(p.filepath);\n      if (parentdir !== '.' && ign.ignores(parentdir)) return true;\n      // If the file is currently ignored, test for UNignoring.\n      if (ignoredStatus) {\n        ignoredStatus = !ign.test(p.filepath).unignored;\n      } else {\n        ignoredStatus = ign.test(p.filepath).ignored;\n      }\n    }\n    return ignoredStatus;\n  }\n}\nasync function writeObjectLoose({\n  fs,\n  gitdir,\n  object,\n  format,\n  oid\n}) {\n  if (format !== 'deflated') {\n    throw new InternalError('GitObjectStoreLoose expects objects to write to be in deflated format');\n  }\n  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;\n  const filepath = `${gitdir}/${source}`;\n  // Don't overwrite existing git objects - this helps avoid EPERM errors.\n  // Although I don't know how we'd fix corrupted objects then. Perhaps delete them\n  // on read?\n  if (!(await fs.exists(filepath))) await fs.write(filepath, object);\n}\n\n/* eslint-env node, browser */\n\nlet supportsCompressionStream = null;\nasync function deflate(buffer) {\n  if (supportsCompressionStream === null) {\n    supportsCompressionStream = testCompressionStream();\n  }\n  return supportsCompressionStream ? browserDeflate(buffer) : pako.deflate(buffer);\n}\nasync function browserDeflate(buffer) {\n  const cs = new CompressionStream('deflate');\n  const c = new Blob([buffer]).stream().pipeThrough(cs);\n  return new Uint8Array(await new Response(c).arrayBuffer());\n}\nfunction testCompressionStream() {\n  try {\n    const cs = new CompressionStream('deflate');\n    // Test if `Blob.stream` is present. React Native does not have the `stream` method\n    new Blob([]).stream();\n    if (cs) return true;\n  } catch (_) {\n    // no bother\n  }\n  return false;\n}\nasync function _writeObject({\n  fs,\n  gitdir,\n  type,\n  object,\n  format = 'content',\n  oid = undefined,\n  dryRun = false\n}) {\n  if (format !== 'deflated') {\n    if (format !== 'wrapped') {\n      object = GitObject.wrap({\n        type,\n        object\n      });\n    }\n    oid = await shasum(object);\n    object = Buffer.from(await deflate(object));\n  }\n  if (!dryRun) {\n    await writeObjectLoose({\n      fs,\n      gitdir,\n      object,\n      format: 'deflated',\n      oid\n    });\n  }\n  return oid;\n}\nfunction posixifyPathBuffer(buffer) {\n  let idx;\n  while (~(idx = buffer.indexOf(92))) buffer[idx] = 47;\n  return buffer;\n}\n\n// @ts-check\n\n/**\n * Add a file to the git index (aka staging area)\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string|string[]} args.filepath - The path to the file to add to the index\n * @param {object} [args.cache] - a [cache](cache.md) object\n * @param {boolean} [args.force=false] - add to index even if matches gitignore. Think `git add --force`\n * @param {boolean} [args.parallel=false] - process each input file in parallel. Parallel processing will result in more memory consumption but less process time\n *\n * @returns {Promise<void>} Resolves successfully once the git index has been updated\n *\n * @example\n * await fs.promises.writeFile('/tutorial/README.md', `# TEST`)\n * await git.add({ fs, dir: '/tutorial', filepath: 'README.md' })\n * console.log('done')\n *\n */\nasync function add({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath,\n  cache = {},\n  force = false,\n  parallel = true\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('dir', dir);\n    assertParameter('gitdir', gitdir);\n    assertParameter('filepath', filepath);\n    const fs = new FileSystem(_fs);\n    await GitIndexManager.acquire({\n      fs,\n      gitdir,\n      cache\n    }, async index => {\n      return addToIndex({\n        dir,\n        gitdir,\n        fs,\n        filepath,\n        index,\n        force,\n        parallel\n      });\n    });\n  } catch (err) {\n    err.caller = 'git.add';\n    throw err;\n  }\n}\nasync function addToIndex({\n  dir,\n  gitdir,\n  fs,\n  filepath,\n  index,\n  force,\n  parallel\n}) {\n  // TODO: Should ignore UNLESS it's already in the index.\n  filepath = Array.isArray(filepath) ? filepath : [filepath];\n  const promises = filepath.map(async currentFilepath => {\n    if (!force) {\n      const ignored = await GitIgnoreManager.isIgnored({\n        fs,\n        dir,\n        gitdir,\n        filepath: currentFilepath\n      });\n      if (ignored) return;\n    }\n    const stats = await fs.lstat(join(dir, currentFilepath));\n    if (!stats) throw new NotFoundError(currentFilepath);\n    if (stats.isDirectory()) {\n      const children = await fs.readdir(join(dir, currentFilepath));\n      if (parallel) {\n        const promises = children.map(child => addToIndex({\n          dir,\n          gitdir,\n          fs,\n          filepath: [join(currentFilepath, child)],\n          index,\n          force,\n          parallel\n        }));\n        await Promise.all(promises);\n      } else {\n        for (const child of children) {\n          await addToIndex({\n            dir,\n            gitdir,\n            fs,\n            filepath: [join(currentFilepath, child)],\n            index,\n            force,\n            parallel\n          });\n        }\n      }\n    } else {\n      const object = stats.isSymbolicLink() ? await fs.readlink(join(dir, currentFilepath)).then(posixifyPathBuffer) : await fs.read(join(dir, currentFilepath));\n      if (object === null) throw new NotFoundError(currentFilepath);\n      const oid = await _writeObject({\n        fs,\n        gitdir,\n        type: 'blob',\n        object\n      });\n      index.insert({\n        filepath: currentFilepath,\n        stats,\n        oid\n      });\n    }\n  });\n  const settledPromises = await Promise.allSettled(promises);\n  const rejectedPromises = settledPromises.filter(settle => settle.status === 'rejected').map(settle => settle.reason);\n  if (rejectedPromises.length > 1) {\n    throw new MultipleGitError(rejectedPromises);\n  }\n  if (rejectedPromises.length === 1) {\n    throw rejectedPromises[0];\n  }\n  const fulfilledPromises = settledPromises.filter(settle => settle.status === 'fulfilled' && settle.value).map(settle => settle.value);\n  return fulfilledPromises;\n}\n\n// @ts-check\n\n/**\n *\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {SignCallback} [args.onSign]\n * @param {string} args.gitdir\n * @param {string} args.message\n * @param {Object} args.author\n * @param {string} args.author.name\n * @param {string} args.author.email\n * @param {number} args.author.timestamp\n * @param {number} args.author.timezoneOffset\n * @param {Object} args.committer\n * @param {string} args.committer.name\n * @param {string} args.committer.email\n * @param {number} args.committer.timestamp\n * @param {number} args.committer.timezoneOffset\n * @param {string} [args.signingKey]\n * @param {boolean} [args.dryRun = false]\n * @param {boolean} [args.noUpdateBranch = false]\n * @param {string} [args.ref]\n * @param {string[]} [args.parent]\n * @param {string} [args.tree]\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly created commit.\n */\nasync function _commit({\n  fs,\n  cache,\n  onSign,\n  gitdir,\n  message,\n  author,\n  committer,\n  signingKey,\n  dryRun = false,\n  noUpdateBranch = false,\n  ref,\n  parent,\n  tree\n}) {\n  if (!ref) {\n    ref = await GitRefManager.resolve({\n      fs,\n      gitdir,\n      ref: 'HEAD',\n      depth: 2\n    });\n  }\n  return GitIndexManager.acquire({\n    fs,\n    gitdir,\n    cache,\n    allowUnmerged: false\n  }, async function (index) {\n    const inodes = flatFileListToDirectoryStructure(index.entries);\n    const inode = inodes.get('.');\n    if (!tree) {\n      tree = await constructTree({\n        fs,\n        gitdir,\n        inode,\n        dryRun\n      });\n    }\n    if (!parent) {\n      try {\n        parent = [await GitRefManager.resolve({\n          fs,\n          gitdir,\n          ref\n        })];\n      } catch (err) {\n        // Probably an initial commit\n        parent = [];\n      }\n    } else {\n      // ensure that the parents are oids, not refs\n      parent = await Promise.all(parent.map(p => {\n        return GitRefManager.resolve({\n          fs,\n          gitdir,\n          ref: p\n        });\n      }));\n    }\n    let comm = GitCommit.from({\n      tree,\n      parent,\n      author,\n      committer,\n      message\n    });\n    if (signingKey) {\n      comm = await GitCommit.sign(comm, onSign, signingKey);\n    }\n    const oid = await _writeObject({\n      fs,\n      gitdir,\n      type: 'commit',\n      object: comm.toObject(),\n      dryRun\n    });\n    if (!noUpdateBranch && !dryRun) {\n      // Update branch pointer\n      await GitRefManager.writeRef({\n        fs,\n        gitdir,\n        ref,\n        value: oid\n      });\n    }\n    return oid;\n  });\n}\nasync function constructTree({\n  fs,\n  gitdir,\n  inode,\n  dryRun\n}) {\n  // use depth first traversal\n  const children = inode.children;\n  for (const inode of children) {\n    if (inode.type === 'tree') {\n      inode.metadata.mode = '040000';\n      inode.metadata.oid = await constructTree({\n        fs,\n        gitdir,\n        inode,\n        dryRun\n      });\n    }\n  }\n  const entries = children.map(inode => ({\n    mode: inode.metadata.mode,\n    path: inode.basename,\n    oid: inode.metadata.oid,\n    type: inode.type\n  }));\n  const tree = GitTree.from(entries);\n  const oid = await _writeObject({\n    fs,\n    gitdir,\n    type: 'tree',\n    object: tree.toObject(),\n    dryRun\n  });\n  return oid;\n}\n\n// @ts-check\n\nasync function resolveFilepath({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  filepath\n}) {\n  // Ensure there are no leading or trailing directory separators.\n  // I was going to do this automatically, but then found that the Git Terminal for Windows\n  // auto-expands --filepath=/src/utils to --filepath=C:/Users/Will/AppData/Local/Programs/Git/src/utils\n  // so I figured it would be wise to promote the behavior in the application layer not just the library layer.\n  if (filepath.startsWith('/')) {\n    throw new InvalidFilepathError('leading-slash');\n  } else if (filepath.endsWith('/')) {\n    throw new InvalidFilepathError('trailing-slash');\n  }\n  const _oid = oid;\n  const result = await resolveTree({\n    fs,\n    cache,\n    gitdir,\n    oid\n  });\n  const tree = result.tree;\n  if (filepath === '') {\n    oid = result.oid;\n  } else {\n    const pathArray = filepath.split('/');\n    oid = await _resolveFilepath({\n      fs,\n      cache,\n      gitdir,\n      tree,\n      pathArray,\n      oid: _oid,\n      filepath\n    });\n  }\n  return oid;\n}\nasync function _resolveFilepath({\n  fs,\n  cache,\n  gitdir,\n  tree,\n  pathArray,\n  oid,\n  filepath\n}) {\n  const name = pathArray.shift();\n  for (const entry of tree) {\n    if (entry.path === name) {\n      if (pathArray.length === 0) {\n        return entry.oid;\n      } else {\n        const {\n          type,\n          object\n        } = await _readObject({\n          fs,\n          cache,\n          gitdir,\n          oid: entry.oid\n        });\n        if (type !== 'tree') {\n          throw new ObjectTypeError(oid, type, 'tree', filepath);\n        }\n        tree = GitTree.from(object);\n        return _resolveFilepath({\n          fs,\n          cache,\n          gitdir,\n          tree,\n          pathArray,\n          oid,\n          filepath\n        });\n      }\n    }\n  }\n  throw new NotFoundError(`file or directory found at \"${oid}:${filepath}\"`);\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} ReadTreeResult - The object returned has the following schema:\n * @property {string} oid - SHA-1 object id of this tree\n * @property {TreeObject} tree - the parsed tree object\n */\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} args.oid\n * @param {string} [args.filepath]\n *\n * @returns {Promise<ReadTreeResult>}\n */\nasync function _readTree({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  filepath = undefined\n}) {\n  if (filepath !== undefined) {\n    oid = await resolveFilepath({\n      fs,\n      cache,\n      gitdir,\n      oid,\n      filepath\n    });\n  }\n  const {\n    tree,\n    oid: treeOid\n  } = await resolveTree({\n    fs,\n    cache,\n    gitdir,\n    oid\n  });\n  const result = {\n    oid: treeOid,\n    tree: tree.entries()\n  };\n  return result;\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {TreeObject} args.tree\n *\n * @returns {Promise<string>}\n */\nasync function _writeTree({\n  fs,\n  gitdir,\n  tree\n}) {\n  // Convert object to buffer\n  const object = GitTree.from(tree).toObject();\n  const oid = await _writeObject({\n    fs,\n    gitdir,\n    type: 'tree',\n    object,\n    format: 'content'\n  });\n  return oid;\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {SignCallback} [args.onSign]\n * @param {string} args.gitdir\n * @param {string} args.ref\n * @param {string} args.oid\n * @param {string|Uint8Array} args.note\n * @param {boolean} [args.force]\n * @param {Object} args.author\n * @param {string} args.author.name\n * @param {string} args.author.email\n * @param {number} args.author.timestamp\n * @param {number} args.author.timezoneOffset\n * @param {Object} args.committer\n * @param {string} args.committer.name\n * @param {string} args.committer.email\n * @param {number} args.committer.timestamp\n * @param {number} args.committer.timezoneOffset\n * @param {string} [args.signingKey]\n *\n * @returns {Promise<string>}\n */\n\nasync function _addNote({\n  fs,\n  cache,\n  onSign,\n  gitdir,\n  ref,\n  oid,\n  note,\n  force,\n  author,\n  committer,\n  signingKey\n}) {\n  // Get the current note commit\n  let parent;\n  try {\n    parent = await GitRefManager.resolve({\n      gitdir,\n      fs,\n      ref\n    });\n  } catch (err) {\n    if (!(err instanceof NotFoundError)) {\n      throw err;\n    }\n  }\n\n  // I'm using the \"empty tree\" magic number here for brevity\n  const result = await _readTree({\n    fs,\n    cache,\n    gitdir,\n    oid: parent || '4b825dc642cb6eb9a060e54bf8d69288fbee4904'\n  });\n  let tree = result.tree;\n\n  // Handle the case where a note already exists\n  if (force) {\n    tree = tree.filter(entry => entry.path !== oid);\n  } else {\n    for (const entry of tree) {\n      if (entry.path === oid) {\n        throw new AlreadyExistsError('note', oid);\n      }\n    }\n  }\n\n  // Create the note blob\n  if (typeof note === 'string') {\n    note = Buffer.from(note, 'utf8');\n  }\n  const noteOid = await _writeObject({\n    fs,\n    gitdir,\n    type: 'blob',\n    object: note,\n    format: 'content'\n  });\n\n  // Create the new note tree\n  tree.push({\n    mode: '100644',\n    path: oid,\n    oid: noteOid,\n    type: 'blob'\n  });\n  const treeOid = await _writeTree({\n    fs,\n    gitdir,\n    tree\n  });\n\n  // Create the new note commit\n  const commitOid = await _commit({\n    fs,\n    cache,\n    onSign,\n    gitdir,\n    ref,\n    tree: treeOid,\n    parent: parent && [parent],\n    message: `Note added by 'isomorphic-git addNote'\\n`,\n    author,\n    committer,\n    signingKey\n  });\n  return commitOid;\n}\n\n// @ts-check\n\n/**\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.path\n *\n * @returns {Promise<any>} Resolves with the config value\n *\n * @example\n * // Read config value\n * let value = await git.getConfig({\n *   dir: '$input((/))',\n *   path: '$input((user.name))'\n * })\n * console.log(value)\n *\n */\nasync function _getConfig({\n  fs,\n  gitdir,\n  path\n}) {\n  const config = await GitConfigManager.get({\n    fs,\n    gitdir\n  });\n  return config.get(path);\n}\n\n/**\n *\n * @returns {Promise<void | {name: string, email: string, date: Date, timestamp: number, timezoneOffset: number }>}\n */\nasync function normalizeAuthorObject({\n  fs,\n  gitdir,\n  author = {}\n}) {\n  let {\n    name,\n    email,\n    timestamp,\n    timezoneOffset\n  } = author;\n  name = name || (await _getConfig({\n    fs,\n    gitdir,\n    path: 'user.name'\n  }));\n  email = email || (await _getConfig({\n    fs,\n    gitdir,\n    path: 'user.email'\n  })) || '';\n  if (name === undefined) {\n    return undefined;\n  }\n  timestamp = timestamp != null ? timestamp : Math.floor(Date.now() / 1000);\n  timezoneOffset = timezoneOffset != null ? timezoneOffset : new Date(timestamp * 1000).getTimezoneOffset();\n  return {\n    name,\n    email,\n    timestamp,\n    timezoneOffset\n  };\n}\n\n/**\n *\n * @returns {Promise<void | {name: string, email: string, timestamp: number, timezoneOffset: number }>}\n */\nasync function normalizeCommitterObject({\n  fs,\n  gitdir,\n  author,\n  committer\n}) {\n  committer = Object.assign({}, committer || author);\n  // Match committer's date to author's one, if omitted\n  if (author) {\n    committer.timestamp = committer.timestamp || author.timestamp;\n    committer.timezoneOffset = committer.timezoneOffset || author.timezoneOffset;\n  }\n  committer = await normalizeAuthorObject({\n    fs,\n    gitdir,\n    author: committer\n  });\n  return committer;\n}\n\n// @ts-check\n\n/**\n * Add or update an object note\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {SignCallback} [args.onSign] - a PGP signing implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - The notes ref to look under\n * @param {string} args.oid - The SHA-1 object id of the object to add the note to.\n * @param {string|Uint8Array} args.note - The note to add\n * @param {boolean} [args.force] - Over-write note if it already exists.\n * @param {Object} [args.author] - The details about the author.\n * @param {string} [args.author.name] - Default is `user.name` config.\n * @param {string} [args.author.email] - Default is `user.email` config.\n * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {Object} [args.committer = author] - The details about the note committer, in the same format as the author parameter. If not specified, the author details are used.\n * @param {string} [args.committer.name] - Default is `user.name` config.\n * @param {string} [args.committer.email] - Default is `user.email` config.\n * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {string} [args.signingKey] - Sign the note commit using this private PGP key.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the commit object for the added note.\n */\n\nasync function addNote({\n  fs: _fs,\n  onSign,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref = 'refs/notes/commits',\n  oid,\n  note,\n  force,\n  author: _author,\n  committer: _committer,\n  signingKey,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n    assertParameter('note', note);\n    if (signingKey) {\n      assertParameter('onSign', onSign);\n    }\n    const fs = new FileSystem(_fs);\n    const author = await normalizeAuthorObject({\n      fs,\n      gitdir,\n      author: _author\n    });\n    if (!author) throw new MissingNameError('author');\n    const committer = await normalizeCommitterObject({\n      fs,\n      gitdir,\n      author,\n      committer: _committer\n    });\n    if (!committer) throw new MissingNameError('committer');\n    return await _addNote({\n      fs: new FileSystem(fs),\n      cache,\n      onSign,\n      gitdir,\n      ref,\n      oid,\n      note,\n      force,\n      author,\n      committer,\n      signingKey\n    });\n  } catch (err) {\n    err.caller = 'git.addNote';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.remote\n * @param {string} args.url\n * @param {boolean} args.force\n *\n * @returns {Promise<void>}\n *\n */\nasync function _addRemote({\n  fs,\n  gitdir,\n  remote,\n  url,\n  force\n}) {\n  if (remote !== cleanGitRef.clean(remote)) {\n    throw new InvalidRefNameError(remote, cleanGitRef.clean(remote));\n  }\n  const config = await GitConfigManager.get({\n    fs,\n    gitdir\n  });\n  if (!force) {\n    // Check that setting it wouldn't overwrite.\n    const remoteNames = await config.getSubsections('remote');\n    if (remoteNames.includes(remote)) {\n      // Throw an error if it would overwrite an existing remote,\n      // but not if it's simply setting the same value again.\n      if (url !== (await config.get(`remote.${remote}.url`))) {\n        throw new AlreadyExistsError('remote', remote);\n      }\n    }\n  }\n  await config.set(`remote.${remote}.url`, url);\n  await config.set(`remote.${remote}.fetch`, `+refs/heads/*:refs/remotes/${remote}/*`);\n  await GitConfigManager.save({\n    fs,\n    gitdir,\n    config\n  });\n}\n\n// @ts-check\n\n/**\n * Add or update a remote\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.remote - The name of the remote\n * @param {string} args.url - The URL of the remote\n * @param {boolean} [args.force = false] - Instead of throwing an error if a remote named `remote` already exists, overwrite the existing remote.\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.addRemote({\n *   fs,\n *   dir: '/tutorial',\n *   remote: 'upstream',\n *   url: 'https://github.com/isomorphic-git/isomorphic-git'\n * })\n * console.log('done')\n *\n */\nasync function addRemote({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  remote,\n  url,\n  force = false\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('remote', remote);\n    assertParameter('url', url);\n    return await _addRemote({\n      fs: new FileSystem(fs),\n      gitdir,\n      remote,\n      url,\n      force\n    });\n  } catch (err) {\n    err.caller = 'git.addRemote';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Create an annotated tag.\n *\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {SignCallback} [args.onSign]\n * @param {string} args.gitdir\n * @param {string} args.ref\n * @param {string} [args.message = ref]\n * @param {string} [args.object = 'HEAD']\n * @param {object} [args.tagger]\n * @param {string} args.tagger.name\n * @param {string} args.tagger.email\n * @param {number} args.tagger.timestamp\n * @param {number} args.tagger.timezoneOffset\n * @param {string} [args.gpgsig]\n * @param {string} [args.signingKey]\n * @param {boolean} [args.force = false]\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.annotatedTag({\n *   dir: '$input((/))',\n *   ref: '$input((test-tag))',\n *   message: '$input((This commit is awesome))',\n *   tagger: {\n *     name: '$input((Mr. Test))',\n *     email: '$input((mrtest@example.com))'\n *   }\n * })\n * console.log('done')\n *\n */\nasync function _annotatedTag({\n  fs,\n  cache,\n  onSign,\n  gitdir,\n  ref,\n  tagger,\n  message = ref,\n  gpgsig,\n  object,\n  signingKey,\n  force = false\n}) {\n  ref = ref.startsWith('refs/tags/') ? ref : `refs/tags/${ref}`;\n  if (!force && (await GitRefManager.exists({\n    fs,\n    gitdir,\n    ref\n  }))) {\n    throw new AlreadyExistsError('tag', ref);\n  }\n\n  // Resolve passed value\n  const oid = await GitRefManager.resolve({\n    fs,\n    gitdir,\n    ref: object || 'HEAD'\n  });\n  const {\n    type\n  } = await _readObject({\n    fs,\n    cache,\n    gitdir,\n    oid\n  });\n  let tagObject = GitAnnotatedTag.from({\n    object: oid,\n    type,\n    tag: ref.replace('refs/tags/', ''),\n    tagger,\n    message,\n    gpgsig\n  });\n  if (signingKey) {\n    tagObject = await GitAnnotatedTag.sign(tagObject, onSign, signingKey);\n  }\n  const value = await _writeObject({\n    fs,\n    gitdir,\n    type: 'tag',\n    object: tagObject.toObject()\n  });\n  await GitRefManager.writeRef({\n    fs,\n    gitdir,\n    ref,\n    value\n  });\n}\n\n// @ts-check\n\n/**\n * Create an annotated tag.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {SignCallback} [args.onSign] - a PGP signing implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - What to name the tag\n * @param {string} [args.message = ref] - The tag message to use.\n * @param {string} [args.object = 'HEAD'] - The SHA-1 object id the tag points to. (Will resolve to a SHA-1 object id if value is a ref.) By default, the commit object which is referred by the current `HEAD` is used.\n * @param {object} [args.tagger] - The details about the tagger.\n * @param {string} [args.tagger.name] - Default is `user.name` config.\n * @param {string} [args.tagger.email] - Default is `user.email` config.\n * @param {number} [args.tagger.timestamp=Math.floor(Date.now()/1000)] - Set the tagger timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.tagger.timezoneOffset] - Set the tagger timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {string} [args.gpgsig] - The gpgsig attatched to the tag object. (Mutually exclusive with the `signingKey` option.)\n * @param {string} [args.signingKey] - Sign the tag object using this private PGP key. (Mutually exclusive with the `gpgsig` option.)\n * @param {boolean} [args.force = false] - Instead of throwing an error if a tag named `ref` already exists, overwrite the existing tag. Note that this option does not modify the original tag object itself.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.annotatedTag({\n *   fs,\n *   dir: '/tutorial',\n *   ref: 'test-tag',\n *   message: 'This commit is awesome',\n *   tagger: {\n *     name: 'Mr. Test',\n *     email: 'mrtest@example.com'\n *   }\n * })\n * console.log('done')\n *\n */\nasync function annotatedTag({\n  fs: _fs,\n  onSign,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  tagger: _tagger,\n  message = ref,\n  gpgsig,\n  object,\n  signingKey,\n  force = false,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    if (signingKey) {\n      assertParameter('onSign', onSign);\n    }\n    const fs = new FileSystem(_fs);\n\n    // Fill in missing arguments with default values\n    const tagger = await normalizeAuthorObject({\n      fs,\n      gitdir,\n      author: _tagger\n    });\n    if (!tagger) throw new MissingNameError('tagger');\n    return await _annotatedTag({\n      fs,\n      cache,\n      onSign,\n      gitdir,\n      ref,\n      tagger,\n      message,\n      gpgsig,\n      object,\n      signingKey,\n      force\n    });\n  } catch (err) {\n    err.caller = 'git.annotatedTag';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Create a branch\n *\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.ref\n * @param {string} [args.object = 'HEAD']\n * @param {boolean} [args.checkout = false]\n * @param {boolean} [args.force = false]\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.branch({ dir: '$input((/))', ref: '$input((develop))' })\n * console.log('done')\n *\n */\nasync function _branch({\n  fs,\n  gitdir,\n  ref,\n  object,\n  checkout = false,\n  force = false\n}) {\n  if (ref !== cleanGitRef.clean(ref)) {\n    throw new InvalidRefNameError(ref, cleanGitRef.clean(ref));\n  }\n  const fullref = `refs/heads/${ref}`;\n  if (!force) {\n    const exist = await GitRefManager.exists({\n      fs,\n      gitdir,\n      ref: fullref\n    });\n    if (exist) {\n      throw new AlreadyExistsError('branch', ref, false);\n    }\n  }\n\n  // Get current HEAD tree oid\n  let oid;\n  try {\n    oid = await GitRefManager.resolve({\n      fs,\n      gitdir,\n      ref: object || 'HEAD'\n    });\n  } catch (e) {\n    // Probably an empty repo\n  }\n\n  // Create a new ref that points at the current commit\n  if (oid) {\n    await GitRefManager.writeRef({\n      fs,\n      gitdir,\n      ref: fullref,\n      value: oid\n    });\n  }\n  if (checkout) {\n    // Update HEAD\n    await GitRefManager.writeSymbolicRef({\n      fs,\n      gitdir,\n      ref: 'HEAD',\n      value: fullref\n    });\n  }\n}\n\n// @ts-check\n\n/**\n * Create a branch\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - What to name the branch\n * @param {string} [args.object = 'HEAD'] - What oid to use as the start point. Accepts a symbolic ref.\n * @param {boolean} [args.checkout = false] - Update `HEAD` to point at the newly created branch\n * @param {boolean} [args.force = false] - Instead of throwing an error if a branched named `ref` already exists, overwrite the existing branch.\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.branch({ fs, dir: '/tutorial', ref: 'develop' })\n * console.log('done')\n *\n */\nasync function branch({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  object,\n  checkout = false,\n  force = false\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    return await _branch({\n      fs: new FileSystem(fs),\n      gitdir,\n      ref,\n      object,\n      checkout,\n      force\n    });\n  } catch (err) {\n    err.caller = 'git.branch';\n    throw err;\n  }\n}\nconst worthWalking = (filepath, root) => {\n  if (filepath === '.' || root == null || root.length === 0 || root === '.') {\n    return true;\n  }\n  if (root.length >= filepath.length) {\n    return root.startsWith(filepath);\n  } else {\n    return filepath.startsWith(root);\n  }\n};\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {ProgressCallback} [args.onProgress]\n * @param {string} args.dir\n * @param {string} args.gitdir\n * @param {string} args.ref\n * @param {string[]} [args.filepaths]\n * @param {string} args.remote\n * @param {boolean} args.noCheckout\n * @param {boolean} [args.noUpdateHead]\n * @param {boolean} [args.dryRun]\n * @param {boolean} [args.force]\n * @param {boolean} [args.track]\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n */\nasync function _checkout({\n  fs,\n  cache,\n  onProgress,\n  dir,\n  gitdir,\n  remote,\n  ref,\n  filepaths,\n  noCheckout,\n  noUpdateHead,\n  dryRun,\n  force,\n  track = true\n}) {\n  // Get tree oid\n  let oid;\n  try {\n    oid = await GitRefManager.resolve({\n      fs,\n      gitdir,\n      ref\n    });\n    // TODO: Figure out what to do if both 'ref' and 'remote' are specified, ref already exists,\n    // and is configured to track a different remote.\n  } catch (err) {\n    if (ref === 'HEAD') throw err;\n    // If `ref` doesn't exist, create a new remote tracking branch\n    // Figure out the commit to checkout\n    const remoteRef = `${remote}/${ref}`;\n    oid = await GitRefManager.resolve({\n      fs,\n      gitdir,\n      ref: remoteRef\n    });\n    if (track) {\n      // Set up remote tracking branch\n      const config = await GitConfigManager.get({\n        fs,\n        gitdir\n      });\n      await config.set(`branch.${ref}.remote`, remote);\n      await config.set(`branch.${ref}.merge`, `refs/heads/${ref}`);\n      await GitConfigManager.save({\n        fs,\n        gitdir,\n        config\n      });\n    }\n    // Create a new branch that points at that same commit\n    await GitRefManager.writeRef({\n      fs,\n      gitdir,\n      ref: `refs/heads/${ref}`,\n      value: oid\n    });\n  }\n\n  // Update working dir\n  if (!noCheckout) {\n    let ops;\n    // First pass - just analyze files (not directories) and figure out what needs to be done\n    try {\n      ops = await analyze({\n        fs,\n        cache,\n        onProgress,\n        dir,\n        gitdir,\n        ref,\n        force,\n        filepaths\n      });\n    } catch (err) {\n      // Throw a more helpful error message for this common mistake.\n      if (err instanceof NotFoundError && err.data.what === oid) {\n        throw new CommitNotFetchedError(ref, oid);\n      } else {\n        throw err;\n      }\n    }\n\n    // Report conflicts\n    const conflicts = ops.filter(([method]) => method === 'conflict').map(([method, fullpath]) => fullpath);\n    if (conflicts.length > 0) {\n      throw new CheckoutConflictError(conflicts);\n    }\n\n    // Collect errors\n    const errors = ops.filter(([method]) => method === 'error').map(([method, fullpath]) => fullpath);\n    if (errors.length > 0) {\n      throw new InternalError(errors.join(', '));\n    }\n    if (dryRun) {\n      // Since the format of 'ops' is in flux, I really would rather folk besides myself not start relying on it\n      // return ops\n      return;\n    }\n\n    // Second pass - execute planned changes\n    // The cheapest semi-parallel solution without computing a full dependency graph will be\n    // to just do ops in 4 dumb phases: delete files, delete dirs, create dirs, write files\n\n    let count = 0;\n    const total = ops.length;\n    await GitIndexManager.acquire({\n      fs,\n      gitdir,\n      cache\n    }, async function (index) {\n      await Promise.all(ops.filter(([method]) => method === 'delete' || method === 'delete-index').map(async function ([method, fullpath]) {\n        const filepath = `${dir}/${fullpath}`;\n        if (method === 'delete') {\n          await fs.rm(filepath);\n        }\n        index.delete({\n          filepath: fullpath\n        });\n        if (onProgress) {\n          await onProgress({\n            phase: 'Updating workdir',\n            loaded: ++count,\n            total\n          });\n        }\n      }));\n    });\n\n    // Note: this is cannot be done naively in parallel\n    await GitIndexManager.acquire({\n      fs,\n      gitdir,\n      cache\n    }, async function (index) {\n      for (const [method, fullpath] of ops) {\n        if (method === 'rmdir' || method === 'rmdir-index') {\n          const filepath = `${dir}/${fullpath}`;\n          try {\n            if (method === 'rmdir-index') {\n              index.delete({\n                filepath: fullpath\n              });\n            }\n            await fs.rmdir(filepath);\n            if (onProgress) {\n              await onProgress({\n                phase: 'Updating workdir',\n                loaded: ++count,\n                total\n              });\n            }\n          } catch (e) {\n            if (e.code === 'ENOTEMPTY') {\n              console.log(`Did not delete ${fullpath} because directory is not empty`);\n            } else {\n              throw e;\n            }\n          }\n        }\n      }\n    });\n    await Promise.all(ops.filter(([method]) => method === 'mkdir' || method === 'mkdir-index').map(async function ([_, fullpath]) {\n      const filepath = `${dir}/${fullpath}`;\n      await fs.mkdir(filepath);\n      if (onProgress) {\n        await onProgress({\n          phase: 'Updating workdir',\n          loaded: ++count,\n          total\n        });\n      }\n    }));\n    await GitIndexManager.acquire({\n      fs,\n      gitdir,\n      cache\n    }, async function (index) {\n      await Promise.all(ops.filter(([method]) => method === 'create' || method === 'create-index' || method === 'update' || method === 'mkdir-index').map(async function ([method, fullpath, oid, mode, chmod]) {\n        const filepath = `${dir}/${fullpath}`;\n        try {\n          if (method !== 'create-index' && method !== 'mkdir-index') {\n            const {\n              object\n            } = await _readObject({\n              fs,\n              cache,\n              gitdir,\n              oid\n            });\n            if (chmod) {\n              // Note: the mode option of fs.write only works when creating files,\n              // not updating them. Since the `fs` plugin doesn't expose `chmod` this\n              // is our only option.\n              await fs.rm(filepath);\n            }\n            if (mode === 0o100644) {\n              // regular file\n              await fs.write(filepath, object);\n            } else if (mode === 0o100755) {\n              // executable file\n              await fs.write(filepath, object, {\n                mode: 0o777\n              });\n            } else if (mode === 0o120000) {\n              // symlink\n              await fs.writelink(filepath, object);\n            } else {\n              throw new InternalError(`Invalid mode 0o${mode.toString(8)} detected in blob ${oid}`);\n            }\n          }\n          const stats = await fs.lstat(filepath);\n          // We can't trust the executable bit returned by lstat on Windows,\n          // so we need to preserve this value from the TREE.\n          // TODO: Figure out how git handles this internally.\n          if (mode === 0o100755) {\n            stats.mode = 0o755;\n          }\n          // Submodules are present in the git index but use a unique mode different from trees\n          if (method === 'mkdir-index') {\n            stats.mode = 0o160000;\n          }\n          index.insert({\n            filepath: fullpath,\n            stats,\n            oid\n          });\n          if (onProgress) {\n            await onProgress({\n              phase: 'Updating workdir',\n              loaded: ++count,\n              total\n            });\n          }\n        } catch (e) {\n          console.log(e);\n        }\n      }));\n    });\n  }\n\n  // Update HEAD\n  if (!noUpdateHead) {\n    const fullRef = await GitRefManager.expand({\n      fs,\n      gitdir,\n      ref\n    });\n    if (fullRef.startsWith('refs/heads')) {\n      await GitRefManager.writeSymbolicRef({\n        fs,\n        gitdir,\n        ref: 'HEAD',\n        value: fullRef\n      });\n    } else {\n      // detached head\n      await GitRefManager.writeRef({\n        fs,\n        gitdir,\n        ref: 'HEAD',\n        value: oid\n      });\n    }\n  }\n}\nasync function analyze({\n  fs,\n  cache,\n  onProgress,\n  dir,\n  gitdir,\n  ref,\n  force,\n  filepaths\n}) {\n  let count = 0;\n  return _walk({\n    fs,\n    cache,\n    dir,\n    gitdir,\n    trees: [TREE({\n      ref\n    }), WORKDIR(), STAGE()],\n    map: async function (fullpath, [commit, workdir, stage]) {\n      if (fullpath === '.') return;\n      // match against base paths\n      if (filepaths && !filepaths.some(base => worthWalking(fullpath, base))) {\n        return null;\n      }\n      // Emit progress event\n      if (onProgress) {\n        await onProgress({\n          phase: 'Analyzing workdir',\n          loaded: ++count\n        });\n      }\n\n      // This is a kind of silly pattern but it worked so well for me in the past\n      // and it makes intuitively demonstrating exhaustiveness so *easy*.\n      // This checks for the presense and/or absence of each of the 3 entries,\n      // converts that to a 3-bit binary representation, and then handles\n      // every possible combination (2^3 or 8 cases) with a lookup table.\n      const key = [!!stage, !!commit, !!workdir].map(Number).join('');\n      switch (key) {\n        // Impossible case.\n        case '000':\n          return;\n        // Ignore workdir files that are not tracked and not part of the new commit.\n        case '001':\n          // OK, make an exception for explicitly named files.\n          if (force && filepaths && filepaths.includes(fullpath)) {\n            return ['delete', fullpath];\n          }\n          return;\n        // New entries\n        case '010':\n          {\n            switch (await commit.type()) {\n              case 'tree':\n                {\n                  return ['mkdir', fullpath];\n                }\n              case 'blob':\n                {\n                  return ['create', fullpath, await commit.oid(), await commit.mode()];\n                }\n              case 'commit':\n                {\n                  return ['mkdir-index', fullpath, await commit.oid(), await commit.mode()];\n                }\n              default:\n                {\n                  return ['error', `new entry Unhandled type ${await commit.type()}`];\n                }\n            }\n          }\n        // New entries but there is already something in the workdir there.\n        case '011':\n          {\n            switch (`${await commit.type()}-${await workdir.type()}`) {\n              case 'tree-tree':\n                {\n                  return; // noop\n                }\n              case 'tree-blob':\n              case 'blob-tree':\n                {\n                  return ['conflict', fullpath];\n                }\n              case 'blob-blob':\n                {\n                  // Is the incoming file different?\n                  if ((await commit.oid()) !== (await workdir.oid())) {\n                    if (force) {\n                      return ['update', fullpath, await commit.oid(), await commit.mode(), (await commit.mode()) !== (await workdir.mode())];\n                    } else {\n                      return ['conflict', fullpath];\n                    }\n                  } else {\n                    // Is the incoming file a different mode?\n                    if ((await commit.mode()) !== (await workdir.mode())) {\n                      if (force) {\n                        return ['update', fullpath, await commit.oid(), await commit.mode(), true];\n                      } else {\n                        return ['conflict', fullpath];\n                      }\n                    } else {\n                      return ['create-index', fullpath, await commit.oid(), await commit.mode()];\n                    }\n                  }\n                }\n              case 'commit-tree':\n                {\n                  // TODO: submodule\n                  // We'll ignore submodule directories for now.\n                  // Users prefer we not throw an error for lack of submodule support.\n                  // gitlinks\n                  return;\n                }\n              case 'commit-blob':\n                {\n                  // TODO: submodule\n                  // But... we'll complain if there is a *file* where we would\n                  // put a submodule if we had submodule support.\n                  return ['conflict', fullpath];\n                }\n              default:\n                {\n                  return ['error', `new entry Unhandled type ${commit.type}`];\n                }\n            }\n          }\n        // Something in stage but not in the commit OR the workdir.\n        // Note: I verified this behavior against canonical git.\n        case '100':\n          {\n            return ['delete-index', fullpath];\n          }\n        // Deleted entries\n        // TODO: How to handle if stage type and workdir type mismatch?\n        case '101':\n          {\n            switch (await stage.type()) {\n              case 'tree':\n                {\n                  return ['rmdir', fullpath];\n                }\n              case 'blob':\n                {\n                  // Git checks that the workdir.oid === stage.oid before deleting file\n                  if ((await stage.oid()) !== (await workdir.oid())) {\n                    if (force) {\n                      return ['delete', fullpath];\n                    } else {\n                      return ['conflict', fullpath];\n                    }\n                  } else {\n                    return ['delete', fullpath];\n                  }\n                }\n              case 'commit':\n                {\n                  return ['rmdir-index', fullpath];\n                }\n              default:\n                {\n                  return ['error', `delete entry Unhandled type ${await stage.type()}`];\n                }\n            }\n          }\n        /* eslint-disable no-fallthrough */\n        // File missing from workdir\n        case '110':\n        // Possibly modified entries\n        case '111':\n          {\n            /* eslint-enable no-fallthrough */\n            switch (`${await stage.type()}-${await commit.type()}`) {\n              case 'tree-tree':\n                {\n                  return;\n                }\n              case 'blob-blob':\n                {\n                  // If the file hasn't changed, there is no need to do anything.\n                  // Existing file modifications in the workdir can be be left as is.\n                  if ((await stage.oid()) === (await commit.oid()) && (await stage.mode()) === (await commit.mode()) && !force) {\n                    return;\n                  }\n\n                  // Check for local changes that would be lost\n                  if (workdir) {\n                    // Note: canonical git only compares with the stage. But we're smart enough\n                    // to compare to the stage AND the incoming commit.\n                    if ((await workdir.oid()) !== (await stage.oid()) && (await workdir.oid()) !== (await commit.oid())) {\n                      if (force) {\n                        return ['update', fullpath, await commit.oid(), await commit.mode(), (await commit.mode()) !== (await workdir.mode())];\n                      } else {\n                        return ['conflict', fullpath];\n                      }\n                    }\n                  } else if (force) {\n                    return ['update', fullpath, await commit.oid(), await commit.mode(), (await commit.mode()) !== (await stage.mode())];\n                  }\n                  // Has file mode changed?\n                  if ((await commit.mode()) !== (await stage.mode())) {\n                    return ['update', fullpath, await commit.oid(), await commit.mode(), true];\n                  }\n                  // TODO: HANDLE SYMLINKS\n                  // Has the file content changed?\n                  if ((await commit.oid()) !== (await stage.oid())) {\n                    return ['update', fullpath, await commit.oid(), await commit.mode(), false];\n                  } else {\n                    return;\n                  }\n                }\n              case 'tree-blob':\n                {\n                  return ['update-dir-to-blob', fullpath, await commit.oid()];\n                }\n              case 'blob-tree':\n                {\n                  return ['update-blob-to-tree', fullpath];\n                }\n              case 'commit-commit':\n                {\n                  return ['mkdir-index', fullpath, await commit.oid(), await commit.mode()];\n                }\n              default:\n                {\n                  return ['error', `update entry Unhandled type ${await stage.type()}-${await commit.type()}`];\n                }\n            }\n          }\n      }\n    },\n    // Modify the default flat mapping\n    reduce: async function (parent, children) {\n      children = flat(children);\n      if (!parent) {\n        return children;\n      } else if (parent && parent[0] === 'rmdir') {\n        children.push(parent);\n        return children;\n      } else {\n        children.unshift(parent);\n        return children;\n      }\n    }\n  });\n}\n\n// @ts-check\n\n/**\n * Checkout a branch\n *\n * If the branch already exists it will check out that branch. Otherwise, it will create a new remote tracking branch set to track the remote branch of that name.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {ProgressCallback} [args.onProgress] - optional progress event callback\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref = 'HEAD'] - Source to checkout files from\n * @param {string[]} [args.filepaths] - Limit the checkout to the given files and directories\n * @param {string} [args.remote = 'origin'] - Which remote repository to use\n * @param {boolean} [args.noCheckout = false] - If true, will update HEAD but won't update the working directory\n * @param {boolean} [args.noUpdateHead] - If true, will update the working directory but won't update HEAD. Defaults to `false` when `ref` is provided, and `true` if `ref` is not provided.\n * @param {boolean} [args.dryRun = false] - If true, simulates a checkout so you can test whether it would succeed.\n * @param {boolean} [args.force = false] - If true, conflicts will be ignored and files will be overwritten regardless of local changes.\n * @param {boolean} [args.track = true] - If false, will not set the remote branch tracking information. Defaults to true.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * // switch to the main branch\n * await git.checkout({\n *   fs,\n *   dir: '/tutorial',\n *   ref: 'main'\n * })\n * console.log('done')\n *\n * @example\n * // restore the 'docs' and 'src/docs' folders to the way they were, overwriting any changes\n * await git.checkout({\n *   fs,\n *   dir: '/tutorial',\n *   force: true,\n *   filepaths: ['docs', 'src/docs']\n * })\n * console.log('done')\n *\n * @example\n * // restore the 'docs' and 'src/docs' folders to the way they are in the 'develop' branch, overwriting any changes\n * await git.checkout({\n *   fs,\n *   dir: '/tutorial',\n *   ref: 'develop',\n *   noUpdateHead: true,\n *   force: true,\n *   filepaths: ['docs', 'src/docs']\n * })\n * console.log('done')\n */\nasync function checkout({\n  fs,\n  onProgress,\n  dir,\n  gitdir = join(dir, '.git'),\n  remote = 'origin',\n  ref: _ref,\n  filepaths,\n  noCheckout = false,\n  noUpdateHead = _ref === undefined,\n  dryRun = false,\n  force = false,\n  track = true,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('dir', dir);\n    assertParameter('gitdir', gitdir);\n    const ref = _ref || 'HEAD';\n    return await _checkout({\n      fs: new FileSystem(fs),\n      cache,\n      onProgress,\n      dir,\n      gitdir,\n      remote,\n      ref,\n      filepaths,\n      noCheckout,\n      noUpdateHead,\n      dryRun,\n      force,\n      track\n    });\n  } catch (err) {\n    err.caller = 'git.checkout';\n    throw err;\n  }\n}\n\n// @see https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions\nconst abbreviateRx = new RegExp('^refs/(heads/|tags/|remotes/)?(.*)');\nfunction abbreviateRef(ref) {\n  const match = abbreviateRx.exec(ref);\n  if (match) {\n    if (match[1] === 'remotes/' && ref.endsWith('/HEAD')) {\n      return match[2].slice(0, -5);\n    } else {\n      return match[2];\n    }\n  }\n  return ref;\n}\n\n// @ts-check\n\n/**\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {boolean} [args.fullname = false] - Return the full path (e.g. \"refs/heads/main\") instead of the abbreviated form.\n * @param {boolean} [args.test = false] - If the current branch doesn't actually exist (such as right after git init) then return `undefined`.\n *\n * @returns {Promise<string|void>} The name of the current branch or undefined if the HEAD is detached.\n *\n */\nasync function _currentBranch({\n  fs,\n  gitdir,\n  fullname = false,\n  test = false\n}) {\n  const ref = await GitRefManager.resolve({\n    fs,\n    gitdir,\n    ref: 'HEAD',\n    depth: 2\n  });\n  if (test) {\n    try {\n      await GitRefManager.resolve({\n        fs,\n        gitdir,\n        ref\n      });\n    } catch (_) {\n      return;\n    }\n  }\n  // Return `undefined` for detached HEAD\n  if (!ref.startsWith('refs/')) return;\n  return fullname ? ref : abbreviateRef(ref);\n}\nfunction translateSSHtoHTTP(url) {\n  // handle \"shorter scp-like syntax\"\n  url = url.replace(/^git@([^:]+):/, 'https://$1/');\n  // handle proper SSH URLs\n  url = url.replace(/^ssh:\\/\\//, 'https://');\n  return url;\n}\nfunction calculateBasicAuthHeader({\n  username = '',\n  password = ''\n}) {\n  return `Basic ${Buffer.from(`${username}:${password}`).toString('base64')}`;\n}\n\n// Currently 'for await' upsets my linters.\nasync function forAwait(iterable, cb) {\n  const iter = getIterator(iterable);\n  while (true) {\n    const {\n      value,\n      done\n    } = await iter.next();\n    if (value) await cb(value);\n    if (done) break;\n  }\n  if (iter.return) iter.return();\n}\nasync function collect(iterable) {\n  let size = 0;\n  const buffers = [];\n  // This will be easier once `for await ... of` loops are available.\n  await forAwait(iterable, value => {\n    buffers.push(value);\n    size += value.byteLength;\n  });\n  const result = new Uint8Array(size);\n  let nextIndex = 0;\n  for (const buffer of buffers) {\n    result.set(buffer, nextIndex);\n    nextIndex += buffer.byteLength;\n  }\n  return result;\n}\nfunction extractAuthFromUrl(url) {\n  // For whatever reason, the `fetch` API does not convert credentials embedded in the URL\n  // into Basic Authentication headers automatically. Instead it throws an error!\n  // So we must manually parse the URL, rip out the user:password portion if it is present\n  // and compute the Authorization header.\n  // Note: I tried using new URL(url) but that throws a security exception in Edge. :rolleyes:\n  let userpass = url.match(/^https?:\\/\\/([^/]+)@/);\n  // No credentials, return the url unmodified and an empty auth object\n  if (userpass == null) return {\n    url,\n    auth: {}\n  };\n  userpass = userpass[1];\n  const [username, password] = userpass.split(':');\n  // Remove credentials from URL\n  url = url.replace(`${userpass}@`, '');\n  // Has credentials, return the fetch-safe URL and the parsed credentials\n  return {\n    url,\n    auth: {\n      username,\n      password\n    }\n  };\n}\nfunction padHex(b, n) {\n  const s = n.toString(16);\n  return '0'.repeat(b - s.length) + s;\n}\n\n/**\npkt-line Format\n---------------\n\nMuch (but not all) of the payload is described around pkt-lines.\n\nA pkt-line is a variable length binary string.  The first four bytes\nof the line, the pkt-len, indicates the total length of the line,\nin hexadecimal.  The pkt-len includes the 4 bytes used to contain\nthe length's hexadecimal representation.\n\nA pkt-line MAY contain binary data, so implementors MUST ensure\npkt-line parsing/formatting routines are 8-bit clean.\n\nA non-binary line SHOULD BE terminated by an LF, which if present\nMUST be included in the total length. Receivers MUST treat pkt-lines\nwith non-binary data the same whether or not they contain the trailing\nLF (stripping the LF if present, and not complaining when it is\nmissing).\n\nThe maximum length of a pkt-line's data component is 65516 bytes.\nImplementations MUST NOT send pkt-line whose length exceeds 65520\n(65516 bytes of payload + 4 bytes of length data).\n\nImplementations SHOULD NOT send an empty pkt-line (\"0004\").\n\nA pkt-line with a length field of 0 (\"0000\"), called a flush-pkt,\nis a special case and MUST be handled differently than an empty\npkt-line (\"0004\").\n\n----\n  pkt-line     =  data-pkt / flush-pkt\n\n  data-pkt     =  pkt-len pkt-payload\n  pkt-len      =  4*(HEXDIG)\n  pkt-payload  =  (pkt-len - 4)*(OCTET)\n\n  flush-pkt    = \"0000\"\n----\n\nExamples (as C-style strings):\n\n----\n  pkt-line          actual value\n  ---------------------------------\n  \"0006a\\n\"         \"a\\n\"\n  \"0005a\"           \"a\"\n  \"000bfoobar\\n\"    \"foobar\\n\"\n  \"0004\"            \"\"\n----\n*/\n\n// I'm really using this more as a namespace.\n// There's not a lot of \"state\" in a pkt-line\n\nclass GitPktLine {\n  static flush() {\n    return Buffer.from('0000', 'utf8');\n  }\n  static delim() {\n    return Buffer.from('0001', 'utf8');\n  }\n  static encode(line) {\n    if (typeof line === 'string') {\n      line = Buffer.from(line);\n    }\n    const length = line.length + 4;\n    const hexlength = padHex(4, length);\n    return Buffer.concat([Buffer.from(hexlength, 'utf8'), line]);\n  }\n  static streamReader(stream) {\n    const reader = new StreamReader(stream);\n    return async function read() {\n      try {\n        let length = await reader.read(4);\n        if (length == null) return true;\n        length = parseInt(length.toString('utf8'), 16);\n        if (length === 0) return null;\n        if (length === 1) return null; // delim packets\n        const buffer = await reader.read(length - 4);\n        if (buffer == null) return true;\n        return buffer;\n      } catch (err) {\n        console.log('error', err);\n        return true;\n      }\n    };\n  }\n}\n\n// @ts-check\n\n/**\n * @param {function} read\n */\nasync function parseCapabilitiesV2(read) {\n  /** @type {Object<string, string | true>} */\n  const capabilities2 = {};\n  let line;\n  while (true) {\n    line = await read();\n    if (line === true) break;\n    if (line === null) continue;\n    line = line.toString('utf8').replace(/\\n$/, '');\n    const i = line.indexOf('=');\n    if (i > -1) {\n      const key = line.slice(0, i);\n      const value = line.slice(i + 1);\n      capabilities2[key] = value;\n    } else {\n      capabilities2[line] = true;\n    }\n  }\n  return {\n    protocolVersion: 2,\n    capabilities2\n  };\n}\nasync function parseRefsAdResponse(stream, {\n  service\n}) {\n  const capabilities = new Set();\n  const refs = new Map();\n  const symrefs = new Map();\n\n  // There is probably a better way to do this, but for now\n  // let's just throw the result parser inline here.\n  const read = GitPktLine.streamReader(stream);\n  let lineOne = await read();\n  // skip past any flushes\n  while (lineOne === null) lineOne = await read();\n  if (lineOne === true) throw new EmptyServerResponseError();\n\n  // Handle protocol v2 responses (Bitbucket Server doesn't include a `# service=` line)\n  if (lineOne.includes('version 2')) {\n    return parseCapabilitiesV2(read);\n  }\n\n  // Clients MUST ignore an LF at the end of the line.\n  if (lineOne.toString('utf8').replace(/\\n$/, '') !== `# service=${service}`) {\n    throw new ParseError(`# service=${service}\\\\n`, lineOne.toString('utf8'));\n  }\n  let lineTwo = await read();\n  // skip past any flushes\n  while (lineTwo === null) lineTwo = await read();\n  // In the edge case of a brand new repo, zero refs (and zero capabilities)\n  // are returned.\n  if (lineTwo === true) return {\n    capabilities,\n    refs,\n    symrefs\n  };\n  lineTwo = lineTwo.toString('utf8');\n\n  // Handle protocol v2 responses\n  if (lineTwo.includes('version 2')) {\n    return parseCapabilitiesV2(read);\n  }\n  const [firstRef, capabilitiesLine] = splitAndAssert(lineTwo, '\\x00', '\\\\x00');\n  capabilitiesLine.split(' ').map(x => capabilities.add(x));\n  const [ref, name] = splitAndAssert(firstRef, ' ', ' ');\n  refs.set(name, ref);\n  while (true) {\n    const line = await read();\n    if (line === true) break;\n    if (line !== null) {\n      const [ref, name] = splitAndAssert(line.toString('utf8'), ' ', ' ');\n      refs.set(name, ref);\n    }\n  }\n  // Symrefs are thrown into the \"capabilities\" unfortunately.\n  for (const cap of capabilities) {\n    if (cap.startsWith('symref=')) {\n      const m = cap.match(/symref=([^:]+):(.*)/);\n      if (m.length === 3) {\n        symrefs.set(m[1], m[2]);\n      }\n    }\n  }\n  return {\n    protocolVersion: 1,\n    capabilities,\n    refs,\n    symrefs\n  };\n}\nfunction splitAndAssert(line, sep, expected) {\n  const split = line.trim().split(sep);\n  if (split.length !== 2) {\n    throw new ParseError(`Two strings separated by '${expected}'`, line.toString('utf8'));\n  }\n  return split;\n}\n\n// Try to accomodate known CORS proxy implementations:\n// - https://jcubic.pl/proxy.php?  <-- uses query string\n// - https://cors.isomorphic-git.org  <-- uses path\nconst corsProxify = (corsProxy, url) => corsProxy.endsWith('?') ? `${corsProxy}${url}` : `${corsProxy}/${url.replace(/^https?:\\/\\//, '')}`;\nconst updateHeaders = (headers, auth) => {\n  // Update the basic auth header\n  if (auth.username || auth.password) {\n    headers.Authorization = calculateBasicAuthHeader(auth);\n  }\n  // but any manually provided headers take precedence\n  if (auth.headers) {\n    Object.assign(headers, auth.headers);\n  }\n};\n\n/**\n * @param {GitHttpResponse} res\n *\n * @returns {{ preview: string, response: string, data: Buffer }}\n */\nconst stringifyBody = async res => {\n  try {\n    // Some services provide a meaningful error message in the body of 403s like \"token lacks the scopes necessary to perform this action\"\n    const data = Buffer.from(await collect(res.body));\n    const response = data.toString('utf8');\n    const preview = response.length < 256 ? response : response.slice(0, 256) + '...';\n    return {\n      preview,\n      response,\n      data\n    };\n  } catch (e) {\n    return {};\n  }\n};\nclass GitRemoteHTTP {\n  static async capabilities() {\n    return ['discover', 'connect'];\n  }\n\n  /**\n   * @param {Object} args\n   * @param {HttpClient} args.http\n   * @param {ProgressCallback} [args.onProgress]\n   * @param {AuthCallback} [args.onAuth]\n   * @param {AuthFailureCallback} [args.onAuthFailure]\n   * @param {AuthSuccessCallback} [args.onAuthSuccess]\n   * @param {string} [args.corsProxy]\n   * @param {string} args.service\n   * @param {string} args.url\n   * @param {Object<string, string>} args.headers\n   * @param {1 | 2} args.protocolVersion - Git Protocol Version\n   */\n  static async discover({\n    http,\n    onProgress,\n    onAuth,\n    onAuthSuccess,\n    onAuthFailure,\n    corsProxy,\n    service,\n    url: _origUrl,\n    headers,\n    protocolVersion\n  }) {\n    let {\n      url,\n      auth\n    } = extractAuthFromUrl(_origUrl);\n    const proxifiedURL = corsProxy ? corsProxify(corsProxy, url) : url;\n    if (auth.username || auth.password) {\n      headers.Authorization = calculateBasicAuthHeader(auth);\n    }\n    if (protocolVersion === 2) {\n      headers['Git-Protocol'] = 'version=2';\n    }\n    let res;\n    let tryAgain;\n    let providedAuthBefore = false;\n    do {\n      res = await http.request({\n        onProgress,\n        method: 'GET',\n        url: `${proxifiedURL}/info/refs?service=${service}`,\n        headers\n      });\n\n      // the default loop behavior\n      tryAgain = false;\n\n      // 401 is the \"correct\" response for access denied. 203 is Non-Authoritative Information and comes from Azure DevOps, which\n      // apparently doesn't realize this is a git request and is returning the HTML for the \"Azure DevOps Services | Sign In\" page.\n      if (res.statusCode === 401 || res.statusCode === 203) {\n        // On subsequent 401s, call `onAuthFailure` instead of `onAuth`.\n        // This is so that naive `onAuth` callbacks that return a fixed value don't create an infinite loop of retrying.\n        const getAuth = providedAuthBefore ? onAuthFailure : onAuth;\n        if (getAuth) {\n          // Acquire credentials and try again\n          // TODO: read `useHttpPath` value from git config and pass along?\n          auth = await getAuth(url, {\n            ...auth,\n            headers: {\n              ...headers\n            }\n          });\n          if (auth && auth.cancel) {\n            throw new UserCanceledError();\n          } else if (auth) {\n            updateHeaders(headers, auth);\n            providedAuthBefore = true;\n            tryAgain = true;\n          }\n        }\n      } else if (res.statusCode === 200 && providedAuthBefore && onAuthSuccess) {\n        await onAuthSuccess(url, auth);\n      }\n    } while (tryAgain);\n    if (res.statusCode !== 200) {\n      const {\n        response\n      } = await stringifyBody(res);\n      throw new HttpError(res.statusCode, res.statusMessage, response);\n    }\n    // Git \"smart\" HTTP servers should respond with the correct Content-Type header.\n    if (res.headers['content-type'] === `application/x-${service}-advertisement`) {\n      const remoteHTTP = await parseRefsAdResponse(res.body, {\n        service\n      });\n      remoteHTTP.auth = auth;\n      return remoteHTTP;\n    } else {\n      // If they don't send the correct content-type header, that's a good indicator it is either a \"dumb\" HTTP\n      // server, or the user specified an incorrect remote URL and the response is actually an HTML page.\n      // In this case, we save the response as plain text so we can generate a better error message if needed.\n      const {\n        preview,\n        response,\n        data\n      } = await stringifyBody(res);\n      // For backwards compatibility, try to parse it anyway.\n      // TODO: maybe just throw instead of trying?\n      try {\n        const remoteHTTP = await parseRefsAdResponse([data], {\n          service\n        });\n        remoteHTTP.auth = auth;\n        return remoteHTTP;\n      } catch (e) {\n        throw new SmartHttpError(preview, response);\n      }\n    }\n  }\n\n  /**\n   * @param {Object} args\n   * @param {HttpClient} args.http\n   * @param {ProgressCallback} [args.onProgress]\n   * @param {string} [args.corsProxy]\n   * @param {string} args.service\n   * @param {string} args.url\n   * @param {Object<string, string>} [args.headers]\n   * @param {any} args.body\n   * @param {any} args.auth\n   */\n  static async connect({\n    http,\n    onProgress,\n    corsProxy,\n    service,\n    url,\n    auth,\n    body,\n    headers\n  }) {\n    // We already have the \"correct\" auth value at this point, but\n    // we need to strip out the username/password from the URL yet again.\n    const urlAuth = extractAuthFromUrl(url);\n    if (urlAuth) url = urlAuth.url;\n    if (corsProxy) url = corsProxify(corsProxy, url);\n    headers['content-type'] = `application/x-${service}-request`;\n    headers.accept = `application/x-${service}-result`;\n    updateHeaders(headers, auth);\n    const res = await http.request({\n      onProgress,\n      method: 'POST',\n      url: `${url}/${service}`,\n      body,\n      headers\n    });\n    if (res.statusCode !== 200) {\n      const {\n        response\n      } = stringifyBody(res);\n      throw new HttpError(res.statusCode, res.statusMessage, response);\n    }\n    return res;\n  }\n}\nfunction parseRemoteUrl({\n  url\n}) {\n  // the stupid \"shorter scp-like syntax\"\n  if (url.startsWith('git@')) {\n    return {\n      transport: 'ssh',\n      address: url\n    };\n  }\n  const matches = url.match(/(\\w+)(:\\/\\/|::)(.*)/);\n  if (matches === null) return;\n  /*\n   * When git encounters a URL of the form <transport>://<address>, where <transport> is\n   * a protocol that it cannot handle natively, it automatically invokes git remote-<transport>\n   * with the full URL as the second argument.\n   *\n   * @see https://git-scm.com/docs/git-remote-helpers\n   */\n  if (matches[2] === '://') {\n    return {\n      transport: matches[1],\n      address: matches[0]\n    };\n  }\n  /*\n   * A URL of the form <transport>::<address> explicitly instructs git to invoke\n   * git remote-<transport> with <address> as the second argument.\n   *\n   * @see https://git-scm.com/docs/git-remote-helpers\n   */\n  if (matches[2] === '::') {\n    return {\n      transport: matches[1],\n      address: matches[3]\n    };\n  }\n}\nclass GitRemoteManager {\n  static getRemoteHelperFor({\n    url\n  }) {\n    // TODO: clean up the remoteHelper API and move into PluginCore\n    const remoteHelpers = new Map();\n    remoteHelpers.set('http', GitRemoteHTTP);\n    remoteHelpers.set('https', GitRemoteHTTP);\n    const parts = parseRemoteUrl({\n      url\n    });\n    if (!parts) {\n      throw new UrlParseError(url);\n    }\n    if (remoteHelpers.has(parts.transport)) {\n      return remoteHelpers.get(parts.transport);\n    }\n    throw new UnknownTransportError(url, parts.transport, parts.transport === 'ssh' ? translateSSHtoHTTP(url) : undefined);\n  }\n}\nlet lock$1 = null;\nclass GitShallowManager {\n  static async read({\n    fs,\n    gitdir\n  }) {\n    if (lock$1 === null) lock$1 = new AsyncLock();\n    const filepath = join(gitdir, 'shallow');\n    const oids = new Set();\n    await lock$1.acquire(filepath, async function () {\n      const text = await fs.read(filepath, {\n        encoding: 'utf8'\n      });\n      if (text === null) return oids; // no file\n      if (text.trim() === '') return oids; // empty file\n      text.trim().split('\\n').map(oid => oids.add(oid));\n    });\n    return oids;\n  }\n  static async write({\n    fs,\n    gitdir,\n    oids\n  }) {\n    if (lock$1 === null) lock$1 = new AsyncLock();\n    const filepath = join(gitdir, 'shallow');\n    if (oids.size > 0) {\n      const text = [...oids].join('\\n') + '\\n';\n      await lock$1.acquire(filepath, async function () {\n        await fs.write(filepath, text, {\n          encoding: 'utf8'\n        });\n      });\n    } else {\n      // No shallows\n      await lock$1.acquire(filepath, async function () {\n        await fs.rm(filepath);\n      });\n    }\n  }\n}\nasync function hasObjectLoose({\n  fs,\n  gitdir,\n  oid\n}) {\n  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;\n  return fs.exists(`${gitdir}/${source}`);\n}\nasync function hasObjectPacked({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  getExternalRefDelta\n}) {\n  // Check to see if it's in a packfile.\n  // Iterate through all the .idx files\n  let list = await fs.readdir(join(gitdir, 'objects/pack'));\n  list = list.filter(x => x.endsWith('.idx'));\n  for (const filename of list) {\n    const indexFile = `${gitdir}/objects/pack/${filename}`;\n    const p = await readPackIndex({\n      fs,\n      cache,\n      filename: indexFile,\n      getExternalRefDelta\n    });\n    if (p.error) throw new InternalError(p.error);\n    // If the packfile DOES have the oid we're looking for...\n    if (p.offsets.has(oid)) {\n      return true;\n    }\n  }\n  // Failed to find it\n  return false;\n}\nasync function hasObject({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  format = 'content'\n}) {\n  // Curry the current read method so that the packfile un-deltification\n  // process can acquire external ref-deltas.\n  const getExternalRefDelta = oid => _readObject({\n    fs,\n    cache,\n    gitdir,\n    oid\n  });\n\n  // Look for it in the loose object directory.\n  let result = await hasObjectLoose({\n    fs,\n    gitdir,\n    oid\n  });\n  // Check to see if it's in a packfile.\n  if (!result) {\n    result = await hasObjectPacked({\n      fs,\n      cache,\n      gitdir,\n      oid,\n      getExternalRefDelta\n    });\n  }\n  // Finally\n  return result;\n}\n\n// TODO: make a function that just returns obCount. then emptyPackfile = () => sizePack(pack) === 0\nfunction emptyPackfile(pack) {\n  const pheader = '5041434b';\n  const version = '00000002';\n  const obCount = '00000000';\n  const header = pheader + version + obCount;\n  return pack.slice(0, 12).toString('hex') === header;\n}\nfunction filterCapabilities(server, client) {\n  const serverNames = server.map(cap => cap.split('=', 1)[0]);\n  return client.filter(cap => {\n    const name = cap.split('=', 1)[0];\n    return serverNames.includes(name);\n  });\n}\nconst pkg = {\n  name: 'isomorphic-git',\n  version: '1.25.1',\n  agent: 'git/isomorphic-git@1.25.1'\n};\nclass FIFO {\n  constructor() {\n    this._queue = [];\n  }\n  write(chunk) {\n    if (this._ended) {\n      throw Error('You cannot write to a FIFO that has already been ended!');\n    }\n    if (this._waiting) {\n      const resolve = this._waiting;\n      this._waiting = null;\n      resolve({\n        value: chunk\n      });\n    } else {\n      this._queue.push(chunk);\n    }\n  }\n  end() {\n    this._ended = true;\n    if (this._waiting) {\n      const resolve = this._waiting;\n      this._waiting = null;\n      resolve({\n        done: true\n      });\n    }\n  }\n  destroy(err) {\n    this._ended = true;\n    this.error = err;\n  }\n  async next() {\n    if (this._queue.length > 0) {\n      return {\n        value: this._queue.shift()\n      };\n    }\n    if (this._ended) {\n      return {\n        done: true\n      };\n    }\n    if (this._waiting) {\n      throw Error('You cannot call read until the previous call to read has returned!');\n    }\n    return new Promise(resolve => {\n      this._waiting = resolve;\n    });\n  }\n}\n\n// Note: progress messages are designed to be written directly to the terminal,\n// so they are often sent with just a carriage return to overwrite the last line of output.\n// But there are also messages delimited with newlines.\n// I also include CRLF just in case.\nfunction findSplit(str) {\n  const r = str.indexOf('\\r');\n  const n = str.indexOf('\\n');\n  if (r === -1 && n === -1) return -1;\n  if (r === -1) return n + 1; // \\n\n  if (n === -1) return r + 1; // \\r\n  if (n === r + 1) return n + 1; // \\r\\n\n  return Math.min(r, n) + 1; // \\r or \\n\n}\nfunction splitLines(input) {\n  const output = new FIFO();\n  let tmp = '';\n  (async () => {\n    await forAwait(input, chunk => {\n      chunk = chunk.toString('utf8');\n      tmp += chunk;\n      while (true) {\n        const i = findSplit(tmp);\n        if (i === -1) break;\n        output.write(tmp.slice(0, i));\n        tmp = tmp.slice(i);\n      }\n    });\n    if (tmp.length > 0) {\n      output.write(tmp);\n    }\n    output.end();\n  })();\n  return output;\n}\n\n/*\nIf 'side-band' or 'side-band-64k' capabilities have been specified by\nthe client, the server will send the packfile data multiplexed.\n\nEach packet starting with the packet-line length of the amount of data\nthat follows, followed by a single byte specifying the sideband the\nfollowing data is coming in on.\n\nIn 'side-band' mode, it will send up to 999 data bytes plus 1 control\ncode, for a total of up to 1000 bytes in a pkt-line.  In 'side-band-64k'\nmode it will send up to 65519 data bytes plus 1 control code, for a\ntotal of up to 65520 bytes in a pkt-line.\n\nThe sideband byte will be a '1', '2' or a '3'. Sideband '1' will contain\npackfile data, sideband '2' will be used for progress information that the\nclient will generally print to stderr and sideband '3' is used for error\ninformation.\n\nIf no 'side-band' capability was specified, the server will stream the\nentire packfile without multiplexing.\n*/\n\nclass GitSideBand {\n  static demux(input) {\n    const read = GitPktLine.streamReader(input);\n    // And now for the ridiculous side-band or side-band-64k protocol\n    const packetlines = new FIFO();\n    const packfile = new FIFO();\n    const progress = new FIFO();\n    // TODO: Use a proper through stream?\n    const nextBit = async function () {\n      const line = await read();\n      // Skip over flush packets\n      if (line === null) return nextBit();\n      // A made up convention to signal there's no more to read.\n      if (line === true) {\n        packetlines.end();\n        progress.end();\n        packfile.end();\n        return;\n      }\n      // Examine first byte to determine which output \"stream\" to use\n      switch (line[0]) {\n        case 1:\n          {\n            // pack data\n            packfile.write(line.slice(1));\n            break;\n          }\n        case 2:\n          {\n            // progress message\n            progress.write(line.slice(1));\n            break;\n          }\n        case 3:\n          {\n            // fatal error message just before stream aborts\n            const error = line.slice(1);\n            progress.write(error);\n            packfile.destroy(new Error(error.toString('utf8')));\n            return;\n          }\n        default:\n          {\n            // Not part of the side-band-64k protocol\n            packetlines.write(line.slice(0));\n          }\n      }\n      // Careful not to blow up the stack.\n      // I think Promises in a tail-call position should be OK.\n      nextBit();\n    };\n    nextBit();\n    return {\n      packetlines,\n      packfile,\n      progress\n    };\n  }\n  // static mux ({\n  //   protocol, // 'side-band' or 'side-band-64k'\n  //   packetlines,\n  //   packfile,\n  //   progress,\n  //   error\n  // }) {\n  //   const MAX_PACKET_LENGTH = protocol === 'side-band-64k' ? 999 : 65519\n  //   let output = new PassThrough()\n  //   packetlines.on('data', data => {\n  //     if (data === null) {\n  //       output.write(GitPktLine.flush())\n  //     } else {\n  //       output.write(GitPktLine.encode(data))\n  //     }\n  //   })\n  //   let packfileWasEmpty = true\n  //   let packfileEnded = false\n  //   let progressEnded = false\n  //   let errorEnded = false\n  //   let goodbye = Buffer.concat([\n  //     GitPktLine.encode(Buffer.from('010A', 'hex')),\n  //     GitPktLine.flush()\n  //   ])\n  //   packfile\n  //     .on('data', data => {\n  //       packfileWasEmpty = false\n  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)\n  //       for (const buffer of buffers) {\n  //         output.write(\n  //           GitPktLine.encode(Buffer.concat([Buffer.from('01', 'hex'), buffer]))\n  //         )\n  //       }\n  //     })\n  //     .on('end', () => {\n  //       packfileEnded = true\n  //       if (!packfileWasEmpty) output.write(goodbye)\n  //       if (progressEnded && errorEnded) output.end()\n  //     })\n  //   progress\n  //     .on('data', data => {\n  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)\n  //       for (const buffer of buffers) {\n  //         output.write(\n  //           GitPktLine.encode(Buffer.concat([Buffer.from('02', 'hex'), buffer]))\n  //         )\n  //       }\n  //     })\n  //     .on('end', () => {\n  //       progressEnded = true\n  //       if (packfileEnded && errorEnded) output.end()\n  //     })\n  //   error\n  //     .on('data', data => {\n  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)\n  //       for (const buffer of buffers) {\n  //         output.write(\n  //           GitPktLine.encode(Buffer.concat([Buffer.from('03', 'hex'), buffer]))\n  //         )\n  //       }\n  //     })\n  //     .on('end', () => {\n  //       errorEnded = true\n  //       if (progressEnded && packfileEnded) output.end()\n  //     })\n  //   return output\n  // }\n}\nasync function parseUploadPackResponse(stream) {\n  const {\n    packetlines,\n    packfile,\n    progress\n  } = GitSideBand.demux(stream);\n  const shallows = [];\n  const unshallows = [];\n  const acks = [];\n  let nak = false;\n  let done = false;\n  return new Promise((resolve, reject) => {\n    // Parse the response\n    forAwait(packetlines, data => {\n      const line = data.toString('utf8').trim();\n      if (line.startsWith('shallow')) {\n        const oid = line.slice(-41).trim();\n        if (oid.length !== 40) {\n          reject(new InvalidOidError(oid));\n        }\n        shallows.push(oid);\n      } else if (line.startsWith('unshallow')) {\n        const oid = line.slice(-41).trim();\n        if (oid.length !== 40) {\n          reject(new InvalidOidError(oid));\n        }\n        unshallows.push(oid);\n      } else if (line.startsWith('ACK')) {\n        const [, oid, status] = line.split(' ');\n        acks.push({\n          oid,\n          status\n        });\n        if (!status) done = true;\n      } else if (line.startsWith('NAK')) {\n        nak = true;\n        done = true;\n      } else {\n        done = true;\n        nak = true;\n      }\n      if (done) {\n        resolve({\n          shallows,\n          unshallows,\n          acks,\n          nak,\n          packfile,\n          progress\n        });\n      }\n    });\n  });\n}\nfunction writeUploadPackRequest({\n  capabilities = [],\n  wants = [],\n  haves = [],\n  shallows = [],\n  depth = null,\n  since = null,\n  exclude = []\n}) {\n  const packstream = [];\n  wants = [...new Set(wants)]; // remove duplicates\n  let firstLineCapabilities = ` ${capabilities.join(' ')}`;\n  for (const oid of wants) {\n    packstream.push(GitPktLine.encode(`want ${oid}${firstLineCapabilities}\\n`));\n    firstLineCapabilities = '';\n  }\n  for (const oid of shallows) {\n    packstream.push(GitPktLine.encode(`shallow ${oid}\\n`));\n  }\n  if (depth !== null) {\n    packstream.push(GitPktLine.encode(`deepen ${depth}\\n`));\n  }\n  if (since !== null) {\n    packstream.push(GitPktLine.encode(`deepen-since ${Math.floor(since.valueOf() / 1000)}\\n`));\n  }\n  for (const oid of exclude) {\n    packstream.push(GitPktLine.encode(`deepen-not ${oid}\\n`));\n  }\n  packstream.push(GitPktLine.flush());\n  for (const oid of haves) {\n    packstream.push(GitPktLine.encode(`have ${oid}\\n`));\n  }\n  packstream.push(GitPktLine.encode(`done\\n`));\n  return packstream;\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {object} FetchResult - The object returned has the following schema:\n * @property {string | null} defaultBranch - The branch that is cloned if no branch is specified\n * @property {string | null} fetchHead - The SHA-1 object id of the fetched head commit\n * @property {string | null} fetchHeadDescription - a textual description of the branch that was fetched\n * @property {Object<string, string>} [headers] - The HTTP response headers returned by the git server\n * @property {string[]} [pruned] - A list of branches that were pruned, if you provided the `prune` parameter\n *\n */\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {HttpClient} args.http\n * @param {ProgressCallback} [args.onProgress]\n * @param {MessageCallback} [args.onMessage]\n * @param {AuthCallback} [args.onAuth]\n * @param {AuthFailureCallback} [args.onAuthFailure]\n * @param {AuthSuccessCallback} [args.onAuthSuccess]\n * @param {string} args.gitdir\n * @param {string|void} [args.url]\n * @param {string} [args.corsProxy]\n * @param {string} [args.ref]\n * @param {string} [args.remoteRef]\n * @param {string} [args.remote]\n * @param {boolean} [args.singleBranch = false]\n * @param {boolean} [args.tags = false]\n * @param {number} [args.depth]\n * @param {Date} [args.since]\n * @param {string[]} [args.exclude = []]\n * @param {boolean} [args.relative = false]\n * @param {Object<string, string>} [args.headers]\n * @param {boolean} [args.prune]\n * @param {boolean} [args.pruneTags]\n *\n * @returns {Promise<FetchResult>}\n * @see FetchResult\n */\nasync function _fetch({\n  fs,\n  cache,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  gitdir,\n  ref: _ref,\n  remoteRef: _remoteRef,\n  remote: _remote,\n  url: _url,\n  corsProxy,\n  depth = null,\n  since = null,\n  exclude = [],\n  relative = false,\n  tags = false,\n  singleBranch = false,\n  headers = {},\n  prune = false,\n  pruneTags = false\n}) {\n  const ref = _ref || (await _currentBranch({\n    fs,\n    gitdir,\n    test: true\n  }));\n  const config = await GitConfigManager.get({\n    fs,\n    gitdir\n  });\n  // Figure out what remote to use.\n  const remote = _remote || ref && (await config.get(`branch.${ref}.remote`)) || 'origin';\n  // Lookup the URL for the given remote.\n  const url = _url || (await config.get(`remote.${remote}.url`));\n  if (typeof url === 'undefined') {\n    throw new MissingParameterError('remote OR url');\n  }\n  // Figure out what remote ref to use.\n  const remoteRef = _remoteRef || ref && (await config.get(`branch.${ref}.merge`)) || _ref || 'HEAD';\n  if (corsProxy === undefined) {\n    corsProxy = await config.get('http.corsProxy');\n  }\n  const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({\n    url\n  });\n  const remoteHTTP = await GitRemoteHTTP.discover({\n    http,\n    onAuth,\n    onAuthSuccess,\n    onAuthFailure,\n    corsProxy,\n    service: 'git-upload-pack',\n    url,\n    headers,\n    protocolVersion: 1\n  });\n  const auth = remoteHTTP.auth; // hack to get new credentials from CredentialManager API\n  const remoteRefs = remoteHTTP.refs;\n  // For the special case of an empty repository with no refs, return null.\n  if (remoteRefs.size === 0) {\n    return {\n      defaultBranch: null,\n      fetchHead: null,\n      fetchHeadDescription: null\n    };\n  }\n  // Check that the remote supports the requested features\n  if (depth !== null && !remoteHTTP.capabilities.has('shallow')) {\n    throw new RemoteCapabilityError('shallow', 'depth');\n  }\n  if (since !== null && !remoteHTTP.capabilities.has('deepen-since')) {\n    throw new RemoteCapabilityError('deepen-since', 'since');\n  }\n  if (exclude.length > 0 && !remoteHTTP.capabilities.has('deepen-not')) {\n    throw new RemoteCapabilityError('deepen-not', 'exclude');\n  }\n  if (relative === true && !remoteHTTP.capabilities.has('deepen-relative')) {\n    throw new RemoteCapabilityError('deepen-relative', 'relative');\n  }\n  // Figure out the SHA for the requested ref\n  const {\n    oid,\n    fullref\n  } = GitRefManager.resolveAgainstMap({\n    ref: remoteRef,\n    map: remoteRefs\n  });\n  // Filter out refs we want to ignore: only keep ref we're cloning, HEAD, branches, and tags (if we're keeping them)\n  for (const remoteRef of remoteRefs.keys()) {\n    if (remoteRef === fullref || remoteRef === 'HEAD' || remoteRef.startsWith('refs/heads/') || tags && remoteRef.startsWith('refs/tags/')) {\n      continue;\n    }\n    remoteRefs.delete(remoteRef);\n  }\n  // Assemble the application/x-git-upload-pack-request\n  const capabilities = filterCapabilities([...remoteHTTP.capabilities], ['multi_ack_detailed', 'no-done', 'side-band-64k',\n  // Note: I removed 'thin-pack' option since our code doesn't \"fatten\" packfiles,\n  // which is necessary for compatibility with git. It was the cause of mysterious\n  // 'fatal: pack has [x] unresolved deltas' errors that plagued us for some time.\n  // isomorphic-git is perfectly happy with thin packfiles in .git/objects/pack but\n  // canonical git it turns out is NOT.\n  'ofs-delta', `agent=${pkg.agent}`]);\n  if (relative) capabilities.push('deepen-relative');\n  // Start figuring out which oids from the remote we want to request\n  const wants = singleBranch ? [oid] : remoteRefs.values();\n  // Come up with a reasonable list of oids to tell the remote we already have\n  // (preferably oids that are close ancestors of the branch heads we're fetching)\n  const haveRefs = singleBranch ? [ref] : await GitRefManager.listRefs({\n    fs,\n    gitdir,\n    filepath: `refs`\n  });\n  let haves = [];\n  for (let ref of haveRefs) {\n    try {\n      ref = await GitRefManager.expand({\n        fs,\n        gitdir,\n        ref\n      });\n      const oid = await GitRefManager.resolve({\n        fs,\n        gitdir,\n        ref\n      });\n      if (await hasObject({\n        fs,\n        cache,\n        gitdir,\n        oid\n      })) {\n        haves.push(oid);\n      }\n    } catch (err) {}\n  }\n  haves = [...new Set(haves)];\n  const oids = await GitShallowManager.read({\n    fs,\n    gitdir\n  });\n  const shallows = remoteHTTP.capabilities.has('shallow') ? [...oids] : [];\n  const packstream = writeUploadPackRequest({\n    capabilities,\n    wants,\n    haves,\n    shallows,\n    depth,\n    since,\n    exclude\n  });\n  // CodeCommit will hang up if we don't send a Content-Length header\n  // so we can't stream the body.\n  const packbuffer = Buffer.from(await collect(packstream));\n  const raw = await GitRemoteHTTP.connect({\n    http,\n    onProgress,\n    corsProxy,\n    service: 'git-upload-pack',\n    url,\n    auth,\n    body: [packbuffer],\n    headers\n  });\n  const response = await parseUploadPackResponse(raw.body);\n  if (raw.headers) {\n    response.headers = raw.headers;\n  }\n  // Apply all the 'shallow' and 'unshallow' commands\n  for (const oid of response.shallows) {\n    if (!oids.has(oid)) {\n      // this is in a try/catch mostly because my old test fixtures are missing objects\n      try {\n        // server says it's shallow, but do we have the parents?\n        const {\n          object\n        } = await _readObject({\n          fs,\n          cache,\n          gitdir,\n          oid\n        });\n        const commit = new GitCommit(object);\n        const hasParents = await Promise.all(commit.headers().parent.map(oid => hasObject({\n          fs,\n          cache,\n          gitdir,\n          oid\n        })));\n        const haveAllParents = hasParents.length === 0 || hasParents.every(has => has);\n        if (!haveAllParents) {\n          oids.add(oid);\n        }\n      } catch (err) {\n        oids.add(oid);\n      }\n    }\n  }\n  for (const oid of response.unshallows) {\n    oids.delete(oid);\n  }\n  await GitShallowManager.write({\n    fs,\n    gitdir,\n    oids\n  });\n  // Update local remote refs\n  if (singleBranch) {\n    const refs = new Map([[fullref, oid]]);\n    // But wait, maybe it was a symref, like 'HEAD'!\n    // We need to save all the refs in the symref chain (sigh).\n    const symrefs = new Map();\n    let bail = 10;\n    let key = fullref;\n    while (bail--) {\n      const value = remoteHTTP.symrefs.get(key);\n      if (value === undefined) break;\n      symrefs.set(key, value);\n      key = value;\n    }\n    // final value must not be a symref but a real ref\n    const realRef = remoteRefs.get(key);\n    // There may be no ref at all if we've fetched a specific commit hash\n    if (realRef) {\n      refs.set(key, realRef);\n    }\n    const {\n      pruned\n    } = await GitRefManager.updateRemoteRefs({\n      fs,\n      gitdir,\n      remote,\n      refs,\n      symrefs,\n      tags,\n      prune\n    });\n    if (prune) {\n      response.pruned = pruned;\n    }\n  } else {\n    const {\n      pruned\n    } = await GitRefManager.updateRemoteRefs({\n      fs,\n      gitdir,\n      remote,\n      refs: remoteRefs,\n      symrefs: remoteHTTP.symrefs,\n      tags,\n      prune,\n      pruneTags\n    });\n    if (prune) {\n      response.pruned = pruned;\n    }\n  }\n  // We need this value later for the `clone` command.\n  response.HEAD = remoteHTTP.symrefs.get('HEAD');\n  // AWS CodeCommit doesn't list HEAD as a symref, but we can reverse engineer it\n  // Find the SHA of the branch called HEAD\n  if (response.HEAD === undefined) {\n    const {\n      oid\n    } = GitRefManager.resolveAgainstMap({\n      ref: 'HEAD',\n      map: remoteRefs\n    });\n    // Use the name of the first branch that's not called HEAD that has\n    // the same SHA as the branch called HEAD.\n    for (const [key, value] of remoteRefs.entries()) {\n      if (key !== 'HEAD' && value === oid) {\n        response.HEAD = key;\n        break;\n      }\n    }\n  }\n  const noun = fullref.startsWith('refs/tags') ? 'tag' : 'branch';\n  response.FETCH_HEAD = {\n    oid,\n    description: `${noun} '${abbreviateRef(fullref)}' of ${url}`\n  };\n  if (onProgress || onMessage) {\n    const lines = splitLines(response.progress);\n    forAwait(lines, async line => {\n      if (onMessage) await onMessage(line);\n      if (onProgress) {\n        const matches = line.match(/([^:]*).*\\((\\d+?)\\/(\\d+?)\\)/);\n        if (matches) {\n          await onProgress({\n            phase: matches[1].trim(),\n            loaded: parseInt(matches[2], 10),\n            total: parseInt(matches[3], 10)\n          });\n        }\n      }\n    });\n  }\n  const packfile = Buffer.from(await collect(response.packfile));\n  const packfileSha = packfile.slice(-20).toString('hex');\n  const res = {\n    defaultBranch: response.HEAD,\n    fetchHead: response.FETCH_HEAD.oid,\n    fetchHeadDescription: response.FETCH_HEAD.description\n  };\n  if (response.headers) {\n    res.headers = response.headers;\n  }\n  if (prune) {\n    res.pruned = response.pruned;\n  }\n  // This is a quick fix for the empty .git/objects/pack/pack-.pack file error,\n  // which due to the way `git-list-pack` works causes the program to hang when it tries to read it.\n  // TODO: Longer term, we should actually:\n  // a) NOT concatenate the entire packfile into memory (line 78),\n  // b) compute the SHA of the stream except for the last 20 bytes, using the same library used in push.js, and\n  // c) compare the computed SHA with the last 20 bytes of the stream before saving to disk, and throwing a \"packfile got corrupted during download\" error if the SHA doesn't match.\n  if (packfileSha !== '' && !emptyPackfile(packfile)) {\n    res.packfile = `objects/pack/pack-${packfileSha}.pack`;\n    const fullpath = join(gitdir, res.packfile);\n    await fs.write(fullpath, packfile);\n    const getExternalRefDelta = oid => _readObject({\n      fs,\n      cache,\n      gitdir,\n      oid\n    });\n    const idx = await GitPackIndex.fromPack({\n      pack: packfile,\n      getExternalRefDelta,\n      onProgress\n    });\n    await fs.write(fullpath.replace(/\\.pack$/, '.idx'), await idx.toBuffer());\n  }\n  return res;\n}\n\n// @ts-check\n\n/**\n * Initialize a new repository\n *\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} [args.dir]\n * @param {string} [args.gitdir]\n * @param {boolean} [args.bare = false]\n * @param {string} [args.defaultBranch = 'master']\n * @returns {Promise<void>}\n */\nasync function _init({\n  fs,\n  bare = false,\n  dir,\n  gitdir = bare ? dir : join(dir, '.git'),\n  defaultBranch = 'master'\n}) {\n  // Don't overwrite an existing config\n  if (await fs.exists(gitdir + '/config')) return;\n  let folders = ['hooks', 'info', 'objects/info', 'objects/pack', 'refs/heads', 'refs/tags'];\n  folders = folders.map(dir => gitdir + '/' + dir);\n  for (const folder of folders) {\n    await fs.mkdir(folder);\n  }\n  await fs.write(gitdir + '/config', '[core]\\n' + '\\trepositoryformatversion = 0\\n' + '\\tfilemode = false\\n' + `\\tbare = ${bare}\\n` + (bare ? '' : '\\tlogallrefupdates = true\\n') + '\\tsymlinks = false\\n' + '\\tignorecase = true\\n');\n  await fs.write(gitdir + '/HEAD', `ref: refs/heads/${defaultBranch}\\n`);\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {HttpClient} args.http\n * @param {ProgressCallback} [args.onProgress]\n * @param {MessageCallback} [args.onMessage]\n * @param {AuthCallback} [args.onAuth]\n * @param {AuthFailureCallback} [args.onAuthFailure]\n * @param {AuthSuccessCallback} [args.onAuthSuccess]\n * @param {string} [args.dir]\n * @param {string} args.gitdir\n * @param {string} args.url\n * @param {string} args.corsProxy\n * @param {string} args.ref\n * @param {boolean} args.singleBranch\n * @param {boolean} args.noCheckout\n * @param {boolean} args.noTags\n * @param {string} args.remote\n * @param {number} args.depth\n * @param {Date} args.since\n * @param {string[]} args.exclude\n * @param {boolean} args.relative\n * @param {Object<string, string>} args.headers\n *\n * @returns {Promise<void>} Resolves successfully when clone completes\n *\n */\nasync function _clone({\n  fs,\n  cache,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  dir,\n  gitdir,\n  url,\n  corsProxy,\n  ref,\n  remote,\n  depth,\n  since,\n  exclude,\n  relative,\n  singleBranch,\n  noCheckout,\n  noTags,\n  headers\n}) {\n  try {\n    await _init({\n      fs,\n      gitdir\n    });\n    await _addRemote({\n      fs,\n      gitdir,\n      remote,\n      url,\n      force: false\n    });\n    if (corsProxy) {\n      const config = await GitConfigManager.get({\n        fs,\n        gitdir\n      });\n      await config.set(`http.corsProxy`, corsProxy);\n      await GitConfigManager.save({\n        fs,\n        gitdir,\n        config\n      });\n    }\n    const {\n      defaultBranch,\n      fetchHead\n    } = await _fetch({\n      fs,\n      cache,\n      http,\n      onProgress,\n      onMessage,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      gitdir,\n      ref,\n      remote,\n      corsProxy,\n      depth,\n      since,\n      exclude,\n      relative,\n      singleBranch,\n      headers,\n      tags: !noTags\n    });\n    if (fetchHead === null) return;\n    ref = ref || defaultBranch;\n    ref = ref.replace('refs/heads/', '');\n    // Checkout that branch\n    await _checkout({\n      fs,\n      cache,\n      onProgress,\n      dir,\n      gitdir,\n      ref,\n      remote,\n      noCheckout\n    });\n  } catch (err) {\n    // Remove partial local repository, see #1283\n    // Ignore any error as we are already failing.\n    // The catch is necessary so the original error is not masked.\n    await fs.rmdir(gitdir, {\n      recursive: true,\n      maxRetries: 10\n    }).catch(() => undefined);\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Clone a repository\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {HttpClient} args.http - an HTTP client\n * @param {ProgressCallback} [args.onProgress] - optional progress event callback\n * @param {MessageCallback} [args.onMessage] - optional message event callback\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.url - The URL of the remote repository\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Value is stored in the git config file for that repo.\n * @param {string} [args.ref] - Which branch to checkout. By default this is the designated \"main branch\" of the repository.\n * @param {boolean} [args.singleBranch = false] - Instead of the default behavior of fetching all the branches, only fetch a single branch.\n * @param {boolean} [args.noCheckout = false] - If true, clone will only fetch the repo, not check out a branch. Skipping checkout can save a lot of time normally spent writing files to disk.\n * @param {boolean} [args.noTags = false] - By default clone will fetch all tags. `noTags` disables that behavior.\n * @param {string} [args.remote = 'origin'] - What to name the remote that is created.\n * @param {number} [args.depth] - Integer. Determines how much of the git repository's history to retrieve\n * @param {Date} [args.since] - Only fetch commits created after the given date. Mutually exclusive with `depth`.\n * @param {string[]} [args.exclude = []] - A list of branches or tags. Instructs the remote server not to send us any commits reachable from these refs.\n * @param {boolean} [args.relative = false] - Changes the meaning of `depth` to be measured from the current shallow depth rather than from the branch tip.\n * @param {Object<string, string>} [args.headers = {}] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully when clone completes\n *\n * @example\n * await git.clone({\n *   fs,\n *   http,\n *   dir: '/tutorial',\n *   corsProxy: 'https://cors.isomorphic-git.org',\n *   url: 'https://github.com/isomorphic-git/isomorphic-git',\n *   singleBranch: true,\n *   depth: 1\n * })\n * console.log('done')\n *\n */\nasync function clone({\n  fs,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  dir,\n  gitdir = join(dir, '.git'),\n  url,\n  corsProxy = undefined,\n  ref = undefined,\n  remote = 'origin',\n  depth = undefined,\n  since = undefined,\n  exclude = [],\n  relative = false,\n  singleBranch = false,\n  noCheckout = false,\n  noTags = false,\n  headers = {},\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('http', http);\n    assertParameter('gitdir', gitdir);\n    if (!noCheckout) {\n      assertParameter('dir', dir);\n    }\n    assertParameter('url', url);\n    return await _clone({\n      fs: new FileSystem(fs),\n      cache,\n      http,\n      onProgress,\n      onMessage,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      dir,\n      gitdir,\n      url,\n      corsProxy,\n      ref,\n      remote,\n      depth,\n      since,\n      exclude,\n      relative,\n      singleBranch,\n      noCheckout,\n      noTags,\n      headers\n    });\n  } catch (err) {\n    err.caller = 'git.clone';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Create a new commit\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {SignCallback} [args.onSign] - a PGP signing implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.message - The commit message to use.\n * @param {Object} [args.author] - The details about the author.\n * @param {string} [args.author.name] - Default is `user.name` config.\n * @param {string} [args.author.email] - Default is `user.email` config.\n * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {Object} [args.committer = author] - The details about the commit committer, in the same format as the author parameter. If not specified, the author details are used.\n * @param {string} [args.committer.name] - Default is `user.name` config.\n * @param {string} [args.committer.email] - Default is `user.email` config.\n * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {string} [args.signingKey] - Sign the tag object using this private PGP key.\n * @param {boolean} [args.dryRun = false] - If true, simulates making a commit so you can test whether it would succeed. Implies `noUpdateBranch`.\n * @param {boolean} [args.noUpdateBranch = false] - If true, does not update the branch pointer after creating the commit.\n * @param {string} [args.ref] - The fully expanded name of the branch to commit to. Default is the current branch pointed to by HEAD. (TODO: fix it so it can expand branch names without throwing if the branch doesn't exist yet.)\n * @param {string[]} [args.parent] - The SHA-1 object ids of the commits to use as parents. If not specified, the commit pointed to by `ref` is used.\n * @param {string} [args.tree] - The SHA-1 object id of the tree to use. If not specified, a new tree object is created from the current git index.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly created commit.\n *\n * @example\n * let sha = await git.commit({\n *   fs,\n *   dir: '/tutorial',\n *   author: {\n *     name: 'Mr. Test',\n *     email: 'mrtest@example.com',\n *   },\n *   message: 'Added the a.txt file'\n * })\n * console.log(sha)\n *\n */\nasync function commit({\n  fs: _fs,\n  onSign,\n  dir,\n  gitdir = join(dir, '.git'),\n  message,\n  author: _author,\n  committer: _committer,\n  signingKey,\n  dryRun = false,\n  noUpdateBranch = false,\n  ref,\n  parent,\n  tree,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('message', message);\n    if (signingKey) {\n      assertParameter('onSign', onSign);\n    }\n    const fs = new FileSystem(_fs);\n    const author = await normalizeAuthorObject({\n      fs,\n      gitdir,\n      author: _author\n    });\n    if (!author) throw new MissingNameError('author');\n    const committer = await normalizeCommitterObject({\n      fs,\n      gitdir,\n      author,\n      committer: _committer\n    });\n    if (!committer) throw new MissingNameError('committer');\n    return await _commit({\n      fs,\n      cache,\n      onSign,\n      gitdir,\n      message,\n      author,\n      committer,\n      signingKey,\n      dryRun,\n      noUpdateBranch,\n      ref,\n      parent,\n      tree\n    });\n  } catch (err) {\n    err.caller = 'git.commit';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Get the name of the branch currently pointed to by .git/HEAD\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {boolean} [args.fullname = false] - Return the full path (e.g. \"refs/heads/main\") instead of the abbreviated form.\n * @param {boolean} [args.test = false] - If the current branch doesn't actually exist (such as right after git init) then return `undefined`.\n *\n * @returns {Promise<string|void>} The name of the current branch or undefined if the HEAD is detached.\n *\n * @example\n * // Get the current branch name\n * let branch = await git.currentBranch({\n *   fs,\n *   dir: '/tutorial',\n *   fullname: false\n * })\n * console.log(branch)\n *\n */\nasync function currentBranch({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  fullname = false,\n  test = false\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    return await _currentBranch({\n      fs: new FileSystem(fs),\n      gitdir,\n      fullname,\n      test\n    });\n  } catch (err) {\n    err.caller = 'git.currentBranch';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.ref\n *\n * @returns {Promise<void>}\n */\nasync function _deleteBranch({\n  fs,\n  gitdir,\n  ref\n}) {\n  ref = ref.startsWith('refs/heads/') ? ref : `refs/heads/${ref}`;\n  const exist = await GitRefManager.exists({\n    fs,\n    gitdir,\n    ref\n  });\n  if (!exist) {\n    throw new NotFoundError(ref);\n  }\n  const fullRef = await GitRefManager.expand({\n    fs,\n    gitdir,\n    ref\n  });\n  const currentRef = await _currentBranch({\n    fs,\n    gitdir,\n    fullname: true\n  });\n  if (fullRef === currentRef) {\n    // detach HEAD\n    const value = await GitRefManager.resolve({\n      fs,\n      gitdir,\n      ref: fullRef\n    });\n    await GitRefManager.writeRef({\n      fs,\n      gitdir,\n      ref: 'HEAD',\n      value\n    });\n  }\n\n  // Delete a specified branch\n  await GitRefManager.deleteRef({\n    fs,\n    gitdir,\n    ref: fullRef\n  });\n}\n\n// @ts-check\n\n/**\n * Delete a local branch\n *\n * > Note: This only deletes loose branches - it should be fixed in the future to delete packed branches as well.\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - The branch to delete\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.deleteBranch({ fs, dir: '/tutorial', ref: 'local-branch' })\n * console.log('done')\n *\n */\nasync function deleteBranch({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('ref', ref);\n    return await _deleteBranch({\n      fs: new FileSystem(fs),\n      gitdir,\n      ref\n    });\n  } catch (err) {\n    err.caller = 'git.deleteBranch';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Delete a local ref\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - The ref to delete\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.deleteRef({ fs, dir: '/tutorial', ref: 'refs/tags/test-tag' })\n * console.log('done')\n *\n */\nasync function deleteRef({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('ref', ref);\n    await GitRefManager.deleteRef({\n      fs: new FileSystem(fs),\n      gitdir,\n      ref\n    });\n  } catch (err) {\n    err.caller = 'git.deleteRef';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.remote\n *\n * @returns {Promise<void>}\n */\nasync function _deleteRemote({\n  fs,\n  gitdir,\n  remote\n}) {\n  const config = await GitConfigManager.get({\n    fs,\n    gitdir\n  });\n  await config.deleteSection('remote', remote);\n  await GitConfigManager.save({\n    fs,\n    gitdir,\n    config\n  });\n}\n\n// @ts-check\n\n/**\n * Removes the local config entry for a given remote\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.remote - The name of the remote to delete\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.deleteRemote({ fs, dir: '/tutorial', remote: 'upstream' })\n * console.log('done')\n *\n */\nasync function deleteRemote({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  remote\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('remote', remote);\n    return await _deleteRemote({\n      fs: new FileSystem(fs),\n      gitdir,\n      remote\n    });\n  } catch (err) {\n    err.caller = 'git.deleteRemote';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Delete a local tag ref\n *\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.ref - The tag to delete\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.deleteTag({ dir: '$input((/))', ref: '$input((test-tag))' })\n * console.log('done')\n *\n */\nasync function _deleteTag({\n  fs,\n  gitdir,\n  ref\n}) {\n  ref = ref.startsWith('refs/tags/') ? ref : `refs/tags/${ref}`;\n  await GitRefManager.deleteRef({\n    fs,\n    gitdir,\n    ref\n  });\n}\n\n// @ts-check\n\n/**\n * Delete a local tag ref\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - The tag to delete\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.deleteTag({ fs, dir: '/tutorial', ref: 'test-tag' })\n * console.log('done')\n *\n */\nasync function deleteTag({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('ref', ref);\n    return await _deleteTag({\n      fs: new FileSystem(fs),\n      gitdir,\n      ref\n    });\n  } catch (err) {\n    err.caller = 'git.deleteTag';\n    throw err;\n  }\n}\nasync function expandOidLoose({\n  fs,\n  gitdir,\n  oid: short\n}) {\n  const prefix = short.slice(0, 2);\n  const objectsSuffixes = await fs.readdir(`${gitdir}/objects/${prefix}`);\n  return objectsSuffixes.map(suffix => `${prefix}${suffix}`).filter(_oid => _oid.startsWith(short));\n}\nasync function expandOidPacked({\n  fs,\n  cache,\n  gitdir,\n  oid: short,\n  getExternalRefDelta\n}) {\n  // Iterate through all the .pack files\n  const results = [];\n  let list = await fs.readdir(join(gitdir, 'objects/pack'));\n  list = list.filter(x => x.endsWith('.idx'));\n  for (const filename of list) {\n    const indexFile = `${gitdir}/objects/pack/${filename}`;\n    const p = await readPackIndex({\n      fs,\n      cache,\n      filename: indexFile,\n      getExternalRefDelta\n    });\n    if (p.error) throw new InternalError(p.error);\n    // Search through the list of oids in the packfile\n    for (const oid of p.offsets.keys()) {\n      if (oid.startsWith(short)) results.push(oid);\n    }\n  }\n  return results;\n}\nasync function _expandOid({\n  fs,\n  cache,\n  gitdir,\n  oid: short\n}) {\n  // Curry the current read method so that the packfile un-deltification\n  // process can acquire external ref-deltas.\n  const getExternalRefDelta = oid => _readObject({\n    fs,\n    cache,\n    gitdir,\n    oid\n  });\n  const results = await expandOidLoose({\n    fs,\n    gitdir,\n    oid: short\n  });\n  const packedOids = await expandOidPacked({\n    fs,\n    cache,\n    gitdir,\n    oid: short,\n    getExternalRefDelta\n  });\n  // Objects can exist in a pack file as well as loose, make sure we only get a list of unique oids.\n  for (const packedOid of packedOids) {\n    if (results.indexOf(packedOid) === -1) {\n      results.push(packedOid);\n    }\n  }\n  if (results.length === 1) {\n    return results[0];\n  }\n  if (results.length > 1) {\n    throw new AmbiguousError('oids', short, results);\n  }\n  throw new NotFoundError(`an object matching \"${short}\"`);\n}\n\n// @ts-check\n\n/**\n * Expand and resolve a short oid into a full oid\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.oid - The shortened oid prefix to expand (like \"0414d2a\")\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<string>} Resolves successfully with the full oid (like \"0414d2a286d7bbc7a4a326a61c1f9f888a8ab87f\")\n *\n * @example\n * let oid = await git.expandOid({ fs, dir: '/tutorial', oid: '0414d2a'})\n * console.log(oid)\n *\n */\nasync function expandOid({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oid,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n    return await _expandOid({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      oid\n    });\n  } catch (err) {\n    err.caller = 'git.expandOid';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Expand an abbreviated ref to its full name\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - The ref to expand (like \"v1.0.0\")\n *\n * @returns {Promise<string>} Resolves successfully with a full ref name (\"refs/tags/v1.0.0\")\n *\n * @example\n * let fullRef = await git.expandRef({ fs, dir: '/tutorial', ref: 'main'})\n * console.log(fullRef)\n *\n */\nasync function expandRef({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    return await GitRefManager.expand({\n      fs: new FileSystem(fs),\n      gitdir,\n      ref\n    });\n  } catch (err) {\n    err.caller = 'git.expandRef';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string[]} args.oids\n *\n */\nasync function _findMergeBase({\n  fs,\n  cache,\n  gitdir,\n  oids\n}) {\n  // Note: right now, the tests are geared so that the output should match that of\n  // `git merge-base --all --octopus`\n  // because without the --octopus flag, git's output seems to depend on the ORDER of the oids,\n  // and computing virtual merge bases is just too much for me to fathom right now.\n\n  // If we start N independent walkers, one at each of the given `oids`, and walk backwards\n  // through ancestors, eventually we'll discover a commit where each one of these N walkers\n  // has passed through. So we just need to keep track of which walkers have visited each commit\n  // until we find a commit that N distinct walkers has visited.\n  const visits = {};\n  const passes = oids.length;\n  let heads = oids.map((oid, index) => ({\n    index,\n    oid\n  }));\n  while (heads.length) {\n    // Count how many times we've passed each commit\n    const result = new Set();\n    for (const {\n      oid,\n      index\n    } of heads) {\n      if (!visits[oid]) visits[oid] = new Set();\n      visits[oid].add(index);\n      if (visits[oid].size === passes) {\n        result.add(oid);\n      }\n    }\n    if (result.size > 0) {\n      return [...result];\n    }\n    // We haven't found a common ancestor yet\n    const newheads = new Map();\n    for (const {\n      oid,\n      index\n    } of heads) {\n      try {\n        const {\n          object\n        } = await _readObject({\n          fs,\n          cache,\n          gitdir,\n          oid\n        });\n        const commit = GitCommit.from(object);\n        const {\n          parent\n        } = commit.parseHeaders();\n        for (const oid of parent) {\n          if (!visits[oid] || !visits[oid].has(index)) {\n            newheads.set(oid + ':' + index, {\n              oid,\n              index\n            });\n          }\n        }\n      } catch (err) {\n        // do nothing\n      }\n    }\n    heads = Array.from(newheads.values());\n  }\n  return [];\n}\nconst LINEBREAKS = /^.*(\\r?\\n|$)/gm;\nfunction mergeFile({\n  branches,\n  contents\n}) {\n  const ourName = branches[1];\n  const theirName = branches[2];\n  const baseContent = contents[0];\n  const ourContent = contents[1];\n  const theirContent = contents[2];\n  const ours = ourContent.match(LINEBREAKS);\n  const base = baseContent.match(LINEBREAKS);\n  const theirs = theirContent.match(LINEBREAKS);\n\n  // Here we let the diff3 library do the heavy lifting.\n  const result = diff3Merge(ours, base, theirs);\n  const markerSize = 7;\n\n  // Here we note whether there are conflicts and format the results\n  let mergedText = '';\n  let cleanMerge = true;\n  for (const item of result) {\n    if (item.ok) {\n      mergedText += item.ok.join('');\n    }\n    if (item.conflict) {\n      cleanMerge = false;\n      mergedText += `${'<'.repeat(markerSize)} ${ourName}\\n`;\n      mergedText += item.conflict.a.join('');\n      mergedText += `${'='.repeat(markerSize)}\\n`;\n      mergedText += item.conflict.b.join('');\n      mergedText += `${'>'.repeat(markerSize)} ${theirName}\\n`;\n    }\n  }\n  return {\n    cleanMerge,\n    mergedText\n  };\n}\n\n// @ts-check\n\n/**\n * Create a merged tree\n *\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ourOid - The SHA-1 object id of our tree\n * @param {string} args.baseOid - The SHA-1 object id of the base tree\n * @param {string} args.theirOid - The SHA-1 object id of their tree\n * @param {string} [args.ourName='ours'] - The name to use in conflicted files for our hunks\n * @param {string} [args.baseName='base'] - The name to use in conflicted files (in diff3 format) for the base hunks\n * @param {string} [args.theirName='theirs'] - The name to use in conflicted files for their hunks\n * @param {boolean} [args.dryRun=false]\n * @param {boolean} [args.abortOnConflict=false]\n * @param {MergeDriverCallback} [args.mergeDriver]\n *\n * @returns {Promise<string>} - The SHA-1 object id of the merged tree\n *\n */\nasync function mergeTree({\n  fs,\n  cache,\n  dir,\n  gitdir = join(dir, '.git'),\n  index,\n  ourOid,\n  baseOid,\n  theirOid,\n  ourName = 'ours',\n  baseName = 'base',\n  theirName = 'theirs',\n  dryRun = false,\n  abortOnConflict = true,\n  mergeDriver\n}) {\n  const ourTree = TREE({\n    ref: ourOid\n  });\n  const baseTree = TREE({\n    ref: baseOid\n  });\n  const theirTree = TREE({\n    ref: theirOid\n  });\n  const unmergedFiles = [];\n  const bothModified = [];\n  const deleteByUs = [];\n  const deleteByTheirs = [];\n  const results = await _walk({\n    fs,\n    cache,\n    dir,\n    gitdir,\n    trees: [ourTree, baseTree, theirTree],\n    map: async function (filepath, [ours, base, theirs]) {\n      const path = basename(filepath);\n      // What we did, what they did\n      const ourChange = await modified(ours, base);\n      const theirChange = await modified(theirs, base);\n      switch (`${ourChange}-${theirChange}`) {\n        case 'false-false':\n          {\n            return {\n              mode: await base.mode(),\n              path,\n              oid: await base.oid(),\n              type: await base.type()\n            };\n          }\n        case 'false-true':\n          {\n            return theirs ? {\n              mode: await theirs.mode(),\n              path,\n              oid: await theirs.oid(),\n              type: await theirs.type()\n            } : undefined;\n          }\n        case 'true-false':\n          {\n            return ours ? {\n              mode: await ours.mode(),\n              path,\n              oid: await ours.oid(),\n              type: await ours.type()\n            } : undefined;\n          }\n        case 'true-true':\n          {\n            // Modifications\n            if (ours && base && theirs && (await ours.type()) === 'blob' && (await base.type()) === 'blob' && (await theirs.type()) === 'blob') {\n              return mergeBlobs({\n                fs,\n                gitdir,\n                path,\n                ours,\n                base,\n                theirs,\n                ourName,\n                baseName,\n                theirName,\n                mergeDriver\n              }).then(async r => {\n                if (!r.cleanMerge) {\n                  unmergedFiles.push(filepath);\n                  bothModified.push(filepath);\n                  if (!abortOnConflict) {\n                    const baseOid = await base.oid();\n                    const ourOid = await ours.oid();\n                    const theirOid = await theirs.oid();\n                    index.delete({\n                      filepath\n                    });\n                    index.insert({\n                      filepath,\n                      oid: baseOid,\n                      stage: 1\n                    });\n                    index.insert({\n                      filepath,\n                      oid: ourOid,\n                      stage: 2\n                    });\n                    index.insert({\n                      filepath,\n                      oid: theirOid,\n                      stage: 3\n                    });\n                  }\n                } else if (!abortOnConflict) {\n                  index.insert({\n                    filepath,\n                    oid: r.mergeResult.oid,\n                    stage: 0\n                  });\n                }\n                return r.mergeResult;\n              });\n            }\n\n            // deleted by us\n            if (base && !ours && theirs && (await base.type()) === 'blob' && (await theirs.type()) === 'blob') {\n              unmergedFiles.push(filepath);\n              deleteByUs.push(filepath);\n              if (!abortOnConflict) {\n                const baseOid = await base.oid();\n                const theirOid = await theirs.oid();\n                index.delete({\n                  filepath\n                });\n                index.insert({\n                  filepath,\n                  oid: baseOid,\n                  stage: 1\n                });\n                index.insert({\n                  filepath,\n                  oid: theirOid,\n                  stage: 3\n                });\n              }\n              return {\n                mode: await theirs.mode(),\n                oid: await theirs.oid(),\n                type: 'blob',\n                path\n              };\n            }\n\n            // deleted by theirs\n            if (base && ours && !theirs && (await base.type()) === 'blob' && (await ours.type()) === 'blob') {\n              unmergedFiles.push(filepath);\n              deleteByTheirs.push(filepath);\n              if (!abortOnConflict) {\n                const baseOid = await base.oid();\n                const ourOid = await ours.oid();\n                index.delete({\n                  filepath\n                });\n                index.insert({\n                  filepath,\n                  oid: baseOid,\n                  stage: 1\n                });\n                index.insert({\n                  filepath,\n                  oid: ourOid,\n                  stage: 2\n                });\n              }\n              return {\n                mode: await ours.mode(),\n                oid: await ours.oid(),\n                type: 'blob',\n                path\n              };\n            }\n\n            // deleted by both\n            if (base && !ours && !theirs && (await base.type()) === 'blob') {\n              return undefined;\n            }\n\n            // all other types of conflicts fail\n            // TODO: Merge conflicts involving additions\n            throw new MergeNotSupportedError();\n          }\n      }\n    },\n    /**\n     * @param {TreeEntry} [parent]\n     * @param {Array<TreeEntry>} children\n     */\n    reduce: unmergedFiles.length !== 0 && (!dir || abortOnConflict) ? undefined : async (parent, children) => {\n      const entries = children.filter(Boolean); // remove undefineds\n\n      // if the parent was deleted, the children have to go\n      if (!parent) return;\n\n      // automatically delete directories if they have been emptied\n      if (parent && parent.type === 'tree' && entries.length === 0) return;\n      if (entries.length > 0) {\n        const tree = new GitTree(entries);\n        const object = tree.toObject();\n        const oid = await _writeObject({\n          fs,\n          gitdir,\n          type: 'tree',\n          object,\n          dryRun\n        });\n        parent.oid = oid;\n      }\n      return parent;\n    }\n  });\n  if (unmergedFiles.length !== 0) {\n    if (dir && !abortOnConflict) {\n      await _walk({\n        fs,\n        cache,\n        dir,\n        gitdir,\n        trees: [TREE({\n          ref: results.oid\n        })],\n        map: async function (filepath, [entry]) {\n          const path = `${dir}/${filepath}`;\n          if ((await entry.type()) === 'blob') {\n            const mode = await entry.mode();\n            const content = new TextDecoder().decode(await entry.content());\n            await fs.write(path, content, {\n              mode\n            });\n          }\n          return true;\n        }\n      });\n    }\n    return new MergeConflictError(unmergedFiles, bothModified, deleteByUs, deleteByTheirs);\n  }\n  return results.oid;\n}\n\n/**\n *\n * @param {Object} args\n * @param {import('../models/FileSystem').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.path\n * @param {WalkerEntry} args.ours\n * @param {WalkerEntry} args.base\n * @param {WalkerEntry} args.theirs\n * @param {string} [args.ourName]\n * @param {string} [args.baseName]\n * @param {string} [args.theirName]\n * @param {boolean} [args.dryRun = false]\n * @param {MergeDriverCallback} [args.mergeDriver]\n *\n */\nasync function mergeBlobs({\n  fs,\n  gitdir,\n  path,\n  ours,\n  base,\n  theirs,\n  ourName,\n  theirName,\n  baseName,\n  dryRun,\n  mergeDriver = mergeFile\n}) {\n  const type = 'blob';\n  // Compute the new mode.\n  // Since there are ONLY two valid blob modes ('100755' and '100644') it boils down to this\n  const mode = (await base.mode()) === (await ours.mode()) ? await theirs.mode() : await ours.mode();\n  // The trivial case: nothing to merge except maybe mode\n  if ((await ours.oid()) === (await theirs.oid())) {\n    return {\n      cleanMerge: true,\n      mergeResult: {\n        mode,\n        path,\n        oid: await ours.oid(),\n        type\n      }\n    };\n  }\n  // if only one side made oid changes, return that side's oid\n  if ((await ours.oid()) === (await base.oid())) {\n    return {\n      cleanMerge: true,\n      mergeResult: {\n        mode,\n        path,\n        oid: await theirs.oid(),\n        type\n      }\n    };\n  }\n  if ((await theirs.oid()) === (await base.oid())) {\n    return {\n      cleanMerge: true,\n      mergeResult: {\n        mode,\n        path,\n        oid: await ours.oid(),\n        type\n      }\n    };\n  }\n  // if both sides made changes do a merge\n  const ourContent = Buffer.from(await ours.content()).toString('utf8');\n  const baseContent = Buffer.from(await base.content()).toString('utf8');\n  const theirContent = Buffer.from(await theirs.content()).toString('utf8');\n  const {\n    mergedText,\n    cleanMerge\n  } = await mergeDriver({\n    branches: [baseName, ourName, theirName],\n    contents: [baseContent, ourContent, theirContent],\n    path\n  });\n  const oid = await _writeObject({\n    fs,\n    gitdir,\n    type: 'blob',\n    object: Buffer.from(mergedText, 'utf8'),\n    dryRun\n  });\n  return {\n    cleanMerge,\n    mergeResult: {\n      mode,\n      path,\n      oid,\n      type\n    }\n  };\n}\n\n// @ts-check\n\n// import diff3 from 'node-diff3'\n/**\n *\n * @typedef {Object} MergeResult - Returns an object with a schema like this:\n * @property {string} [oid] - The SHA-1 object id that is now at the head of the branch. Absent only if `dryRun` was specified and `mergeCommit` is true.\n * @property {boolean} [alreadyMerged] - True if the branch was already merged so no changes were made\n * @property {boolean} [fastForward] - True if it was a fast-forward merge\n * @property {boolean} [mergeCommit] - True if merge resulted in a merge commit\n * @property {string} [tree] - The SHA-1 object id of the tree resulting from a merge commit\n *\n */\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {string} args.gitdir\n * @param {string} [args.ours]\n * @param {string} args.theirs\n * @param {boolean} args.fastForward\n * @param {boolean} args.fastForwardOnly\n * @param {boolean} args.dryRun\n * @param {boolean} args.noUpdateBranch\n * @param {boolean} args.abortOnConflict\n * @param {string} [args.message]\n * @param {Object} args.author\n * @param {string} args.author.name\n * @param {string} args.author.email\n * @param {number} args.author.timestamp\n * @param {number} args.author.timezoneOffset\n * @param {Object} args.committer\n * @param {string} args.committer.name\n * @param {string} args.committer.email\n * @param {number} args.committer.timestamp\n * @param {number} args.committer.timezoneOffset\n * @param {string} [args.signingKey]\n * @param {SignCallback} [args.onSign] - a PGP signing implementation\n * @param {MergeDriverCallback} [args.mergeDriver]\n *\n * @returns {Promise<MergeResult>} Resolves to a description of the merge operation\n *\n */\nasync function _merge({\n  fs,\n  cache,\n  dir,\n  gitdir,\n  ours,\n  theirs,\n  fastForward = true,\n  fastForwardOnly = false,\n  dryRun = false,\n  noUpdateBranch = false,\n  abortOnConflict = true,\n  message,\n  author,\n  committer,\n  signingKey,\n  onSign,\n  mergeDriver\n}) {\n  if (ours === undefined) {\n    ours = await _currentBranch({\n      fs,\n      gitdir,\n      fullname: true\n    });\n  }\n  ours = await GitRefManager.expand({\n    fs,\n    gitdir,\n    ref: ours\n  });\n  theirs = await GitRefManager.expand({\n    fs,\n    gitdir,\n    ref: theirs\n  });\n  const ourOid = await GitRefManager.resolve({\n    fs,\n    gitdir,\n    ref: ours\n  });\n  const theirOid = await GitRefManager.resolve({\n    fs,\n    gitdir,\n    ref: theirs\n  });\n  // find most recent common ancestor of ref a and ref b\n  const baseOids = await _findMergeBase({\n    fs,\n    cache,\n    gitdir,\n    oids: [ourOid, theirOid]\n  });\n  if (baseOids.length !== 1) {\n    // TODO: Recursive Merge strategy\n    throw new MergeNotSupportedError();\n  }\n  const baseOid = baseOids[0];\n  // handle fast-forward case\n  if (baseOid === theirOid) {\n    return {\n      oid: ourOid,\n      alreadyMerged: true\n    };\n  }\n  if (fastForward && baseOid === ourOid) {\n    if (!dryRun && !noUpdateBranch) {\n      await GitRefManager.writeRef({\n        fs,\n        gitdir,\n        ref: ours,\n        value: theirOid\n      });\n    }\n    return {\n      oid: theirOid,\n      fastForward: true\n    };\n  } else {\n    // not a simple fast-forward\n    if (fastForwardOnly) {\n      throw new FastForwardError();\n    }\n    // try a fancier merge\n    const tree = await GitIndexManager.acquire({\n      fs,\n      gitdir,\n      cache,\n      allowUnmerged: false\n    }, async index => {\n      return mergeTree({\n        fs,\n        cache,\n        dir,\n        gitdir,\n        index,\n        ourOid,\n        theirOid,\n        baseOid,\n        ourName: abbreviateRef(ours),\n        baseName: 'base',\n        theirName: abbreviateRef(theirs),\n        dryRun,\n        abortOnConflict,\n        mergeDriver\n      });\n    });\n\n    // Defer throwing error until the index lock is relinquished and index is\n    // written to filsesystem\n    if (tree instanceof MergeConflictError) throw tree;\n    if (!message) {\n      message = `Merge branch '${abbreviateRef(theirs)}' into ${abbreviateRef(ours)}`;\n    }\n    const oid = await _commit({\n      fs,\n      cache,\n      gitdir,\n      message,\n      ref: ours,\n      tree,\n      parent: [ourOid, theirOid],\n      author,\n      committer,\n      signingKey,\n      onSign,\n      dryRun,\n      noUpdateBranch\n    });\n    return {\n      oid,\n      tree,\n      mergeCommit: true\n    };\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {HttpClient} args.http\n * @param {ProgressCallback} [args.onProgress]\n * @param {MessageCallback} [args.onMessage]\n * @param {AuthCallback} [args.onAuth]\n * @param {AuthFailureCallback} [args.onAuthFailure]\n * @param {AuthSuccessCallback} [args.onAuthSuccess]\n * @param {string} args.dir\n * @param {string} args.gitdir\n * @param {string} args.ref\n * @param {string} [args.url]\n * @param {string} [args.remote]\n * @param {string} [args.remoteRef]\n * @param {boolean} [args.prune]\n * @param {boolean} [args.pruneTags]\n * @param {string} [args.corsProxy]\n * @param {boolean} args.singleBranch\n * @param {boolean} args.fastForward\n * @param {boolean} args.fastForwardOnly\n * @param {Object<string, string>} [args.headers]\n * @param {Object} args.author\n * @param {string} args.author.name\n * @param {string} args.author.email\n * @param {number} args.author.timestamp\n * @param {number} args.author.timezoneOffset\n * @param {Object} args.committer\n * @param {string} args.committer.name\n * @param {string} args.committer.email\n * @param {number} args.committer.timestamp\n * @param {number} args.committer.timezoneOffset\n * @param {string} [args.signingKey]\n *\n * @returns {Promise<void>} Resolves successfully when pull operation completes\n *\n */\nasync function _pull({\n  fs,\n  cache,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  dir,\n  gitdir,\n  ref,\n  url,\n  remote,\n  remoteRef,\n  prune,\n  pruneTags,\n  fastForward,\n  fastForwardOnly,\n  corsProxy,\n  singleBranch,\n  headers,\n  author,\n  committer,\n  signingKey\n}) {\n  try {\n    // If ref is undefined, use 'HEAD'\n    if (!ref) {\n      const head = await _currentBranch({\n        fs,\n        gitdir\n      });\n      // TODO: use a better error.\n      if (!head) {\n        throw new MissingParameterError('ref');\n      }\n      ref = head;\n    }\n    const {\n      fetchHead,\n      fetchHeadDescription\n    } = await _fetch({\n      fs,\n      cache,\n      http,\n      onProgress,\n      onMessage,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      gitdir,\n      corsProxy,\n      ref,\n      url,\n      remote,\n      remoteRef,\n      singleBranch,\n      headers,\n      prune,\n      pruneTags\n    });\n    // Merge the remote tracking branch into the local one.\n    await _merge({\n      fs,\n      cache,\n      gitdir,\n      ours: ref,\n      theirs: fetchHead,\n      fastForward,\n      fastForwardOnly,\n      message: `Merge ${fetchHeadDescription}`,\n      author,\n      committer,\n      signingKey,\n      dryRun: false,\n      noUpdateBranch: false\n    });\n    await _checkout({\n      fs,\n      cache,\n      onProgress,\n      dir,\n      gitdir,\n      ref,\n      remote,\n      noCheckout: false\n    });\n  } catch (err) {\n    err.caller = 'git.pull';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Like `pull`, but hard-coded with `fastForward: true` so there is no need for an `author` parameter.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {HttpClient} args.http - an HTTP client\n * @param {ProgressCallback} [args.onProgress] - optional progress event callback\n * @param {MessageCallback} [args.onMessage] - optional message event callback\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - Which branch to merge into. By default this is the currently checked out branch.\n * @param {string} [args.url] - (Added in 1.1.0) The URL of the remote repository. The default is the value set in the git config for that remote.\n * @param {string} [args.remote] - (Added in 1.1.0) If URL is not specified, determines which remote to use.\n * @param {string} [args.remoteRef] - (Added in 1.1.0) The name of the branch on the remote to fetch. By default this is the configured remote tracking branch.\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.\n * @param {boolean} [args.singleBranch = false] - Instead of the default behavior of fetching all the branches, only fetch a single branch.\n * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully when pull operation completes\n *\n * @example\n * await git.fastForward({\n *   fs,\n *   http,\n *   dir: '/tutorial',\n *   ref: 'main',\n *   singleBranch: true\n * })\n * console.log('done')\n *\n */\nasync function fastForward({\n  fs,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  url,\n  remote,\n  remoteRef,\n  corsProxy,\n  singleBranch,\n  headers = {},\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('http', http);\n    assertParameter('gitdir', gitdir);\n    const thisWillNotBeUsed = {\n      name: '',\n      email: '',\n      timestamp: Date.now(),\n      timezoneOffset: 0\n    };\n    return await _pull({\n      fs: new FileSystem(fs),\n      cache,\n      http,\n      onProgress,\n      onMessage,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      dir,\n      gitdir,\n      ref,\n      url,\n      remote,\n      remoteRef,\n      fastForwardOnly: true,\n      corsProxy,\n      singleBranch,\n      headers,\n      author: thisWillNotBeUsed,\n      committer: thisWillNotBeUsed\n    });\n  } catch (err) {\n    err.caller = 'git.fastForward';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {object} FetchResult - The object returned has the following schema:\n * @property {string | null} defaultBranch - The branch that is cloned if no branch is specified\n * @property {string | null} fetchHead - The SHA-1 object id of the fetched head commit\n * @property {string | null} fetchHeadDescription - a textual description of the branch that was fetched\n * @property {Object<string, string>} [headers] - The HTTP response headers returned by the git server\n * @property {string[]} [pruned] - A list of branches that were pruned, if you provided the `prune` parameter\n *\n */\n\n/**\n * Fetch commits from a remote repository\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {HttpClient} args.http - an HTTP client\n * @param {ProgressCallback} [args.onProgress] - optional progress event callback\n * @param {MessageCallback} [args.onMessage] - optional message event callback\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.url] - The URL of the remote repository. The default is the value set in the git config for that remote.\n * @param {string} [args.remote] - If URL is not specified, determines which remote to use.\n * @param {boolean} [args.singleBranch = false] - Instead of the default behavior of fetching all the branches, only fetch a single branch.\n * @param {string} [args.ref] - Which branch to fetch if `singleBranch` is true. By default this is the current branch or the remote's default branch.\n * @param {string} [args.remoteRef] - The name of the branch on the remote to fetch if `singleBranch` is true. By default this is the configured remote tracking branch.\n * @param {boolean} [args.tags = false] - Also fetch tags\n * @param {number} [args.depth] - Integer. Determines how much of the git repository's history to retrieve\n * @param {boolean} [args.relative = false] - Changes the meaning of `depth` to be measured from the current shallow depth rather than from the branch tip.\n * @param {Date} [args.since] - Only fetch commits created after the given date. Mutually exclusive with `depth`.\n * @param {string[]} [args.exclude = []] - A list of branches or tags. Instructs the remote server not to send us any commits reachable from these refs.\n * @param {boolean} [args.prune = false] - Delete local remote-tracking branches that are not present on the remote\n * @param {boolean} [args.pruneTags = false] - Prune local tags that dont exist on the remote, and force-update those tags that differ\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.\n * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<FetchResult>} Resolves successfully when fetch completes\n * @see FetchResult\n *\n * @example\n * let result = await git.fetch({\n *   fs,\n *   http,\n *   dir: '/tutorial',\n *   corsProxy: 'https://cors.isomorphic-git.org',\n *   url: 'https://github.com/isomorphic-git/isomorphic-git',\n *   ref: 'main',\n *   depth: 1,\n *   singleBranch: true,\n *   tags: false\n * })\n * console.log(result)\n *\n */\nasync function fetch({\n  fs,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  remote,\n  remoteRef,\n  url,\n  corsProxy,\n  depth = null,\n  since = null,\n  exclude = [],\n  relative = false,\n  tags = false,\n  singleBranch = false,\n  headers = {},\n  prune = false,\n  pruneTags = false,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('http', http);\n    assertParameter('gitdir', gitdir);\n    return await _fetch({\n      fs: new FileSystem(fs),\n      cache,\n      http,\n      onProgress,\n      onMessage,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      gitdir,\n      ref,\n      remote,\n      remoteRef,\n      url,\n      corsProxy,\n      depth,\n      since,\n      exclude,\n      relative,\n      tags,\n      singleBranch,\n      headers,\n      prune,\n      pruneTags\n    });\n  } catch (err) {\n    err.caller = 'git.fetch';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Find the merge base for a set of commits\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string[]} args.oids - Which commits\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n */\nasync function findMergeBase({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oids,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oids', oids);\n    return await _findMergeBase({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      oids\n    });\n  } catch (err) {\n    err.caller = 'git.findMergeBase';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Find the root git directory\n *\n * Starting at `filepath`, walks upward until it finds a directory that contains a subdirectory called '.git'.\n *\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.filepath\n *\n * @returns {Promise<string>} Resolves successfully with a root git directory path\n */\nasync function _findRoot({\n  fs,\n  filepath\n}) {\n  if (await fs.exists(join(filepath, '.git'))) {\n    return filepath;\n  } else {\n    const parent = dirname(filepath);\n    if (parent === filepath) {\n      throw new NotFoundError(`git root for ${filepath}`);\n    }\n    return _findRoot({\n      fs,\n      filepath: parent\n    });\n  }\n}\n\n// @ts-check\n\n/**\n * Find the root git directory\n *\n * Starting at `filepath`, walks upward until it finds a directory that contains a subdirectory called '.git'.\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} args.filepath - The file directory to start searching in.\n *\n * @returns {Promise<string>} Resolves successfully with a root git directory path\n * @throws {NotFoundError}\n *\n * @example\n * let gitroot = await git.findRoot({\n *   fs,\n *   filepath: '/tutorial/src/utils'\n * })\n * console.log(gitroot)\n *\n */\nasync function findRoot({\n  fs,\n  filepath\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('filepath', filepath);\n    return await _findRoot({\n      fs: new FileSystem(fs),\n      filepath\n    });\n  } catch (err) {\n    err.caller = 'git.findRoot';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Read an entry from the git config files.\n *\n * *Caveats:*\n * - Currently only the local `$GIT_DIR/config` file can be read or written. However support for the global `~/.gitconfig` and system `$(prefix)/etc/gitconfig` will be added in the future.\n * - The current parser does not support the more exotic features of the git-config file format such as `[include]` and `[includeIf]`.\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.path - The key of the git config entry\n *\n * @returns {Promise<any>} Resolves with the config value\n *\n * @example\n * // Read config value\n * let value = await git.getConfig({\n *   fs,\n *   dir: '/tutorial',\n *   path: 'remote.origin.url'\n * })\n * console.log(value)\n *\n */\nasync function getConfig({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  path\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('path', path);\n    return await _getConfig({\n      fs: new FileSystem(fs),\n      gitdir,\n      path\n    });\n  } catch (err) {\n    err.caller = 'git.getConfig';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.path\n *\n * @returns {Promise<Array<any>>} Resolves with an array of the config value\n *\n */\nasync function _getConfigAll({\n  fs,\n  gitdir,\n  path\n}) {\n  const config = await GitConfigManager.get({\n    fs,\n    gitdir\n  });\n  return config.getall(path);\n}\n\n// @ts-check\n\n/**\n * Read a multi-valued entry from the git config files.\n *\n * *Caveats:*\n * - Currently only the local `$GIT_DIR/config` file can be read or written. However support for the global `~/.gitconfig` and system `$(prefix)/etc/gitconfig` will be added in the future.\n * - The current parser does not support the more exotic features of the git-config file format such as `[include]` and `[includeIf]`.\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.path - The key of the git config entry\n *\n * @returns {Promise<Array<any>>} Resolves with the config value\n *\n */\nasync function getConfigAll({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  path\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('path', path);\n    return await _getConfigAll({\n      fs: new FileSystem(fs),\n      gitdir,\n      path\n    });\n  } catch (err) {\n    err.caller = 'git.getConfigAll';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} GetRemoteInfoResult - The object returned has the following schema:\n * @property {string[]} capabilities - The list of capabilities returned by the server (part of the Git protocol)\n * @property {Object} [refs]\n * @property {string} [HEAD] - The default branch of the remote\n * @property {Object<string, string>} [refs.heads] - The branches on the remote\n * @property {Object<string, string>} [refs.pull] - The special branches representing pull requests (non-standard)\n * @property {Object<string, string>} [refs.tags] - The tags on the remote\n *\n */\n\n/**\n * List a remote servers branches, tags, and capabilities.\n *\n * This is a rare command that doesn't require an `fs`, `dir`, or even `gitdir` argument.\n * It just communicates to a remote git server, using the first step of the `git-upload-pack` handshake, but stopping short of fetching the packfile.\n *\n * @param {object} args\n * @param {HttpClient} args.http - an HTTP client\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} args.url - The URL of the remote repository. Will be gotten from gitconfig if absent.\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.\n * @param {boolean} [args.forPush = false] - By default, the command queries the 'fetch' capabilities. If true, it will ask for the 'push' capabilities.\n * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n *\n * @returns {Promise<GetRemoteInfoResult>} Resolves successfully with an object listing the branches, tags, and capabilities of the remote.\n * @see GetRemoteInfoResult\n *\n * @example\n * let info = await git.getRemoteInfo({\n *   http,\n *   url:\n *     \"https://cors.isomorphic-git.org/github.com/isomorphic-git/isomorphic-git.git\"\n * });\n * console.log(info);\n *\n */\nasync function getRemoteInfo({\n  http,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  corsProxy,\n  url,\n  headers = {},\n  forPush = false\n}) {\n  try {\n    assertParameter('http', http);\n    assertParameter('url', url);\n    const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({\n      url\n    });\n    const remote = await GitRemoteHTTP.discover({\n      http,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      corsProxy,\n      service: forPush ? 'git-receive-pack' : 'git-upload-pack',\n      url,\n      headers,\n      protocolVersion: 1\n    });\n\n    // Note: remote.capabilities, remote.refs, and remote.symrefs are Set and Map objects,\n    // but one of the objectives of the public API is to always return JSON-compatible objects\n    // so we must JSONify them.\n    const result = {\n      capabilities: [...remote.capabilities]\n    };\n    // Convert the flat list into an object tree, because I figure 99% of the time\n    // that will be easier to use.\n    for (const [ref, oid] of remote.refs) {\n      const parts = ref.split('/');\n      const last = parts.pop();\n      let o = result;\n      for (const part of parts) {\n        o[part] = o[part] || {};\n        o = o[part];\n      }\n      o[last] = oid;\n    }\n    // Merge symrefs on top of refs to more closely match actual git repo layouts\n    for (const [symref, ref] of remote.symrefs) {\n      const parts = symref.split('/');\n      const last = parts.pop();\n      let o = result;\n      for (const part of parts) {\n        o[part] = o[part] || {};\n        o = o[part];\n      }\n      o[last] = ref;\n    }\n    return result;\n  } catch (err) {\n    err.caller = 'git.getRemoteInfo';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * @param {any} remote\n * @param {string} prefix\n * @param {boolean} symrefs\n * @param {boolean} peelTags\n * @returns {ServerRef[]}\n */\nfunction formatInfoRefs(remote, prefix, symrefs, peelTags) {\n  const refs = [];\n  for (const [key, value] of remote.refs) {\n    if (prefix && !key.startsWith(prefix)) continue;\n    if (key.endsWith('^{}')) {\n      if (peelTags) {\n        const _key = key.replace('^{}', '');\n        // Peeled tags are almost always listed immediately after the original tag\n        const last = refs[refs.length - 1];\n        const r = last.ref === _key ? last : refs.find(x => x.ref === _key);\n        if (r === undefined) {\n          throw new Error('I did not expect this to happen');\n        }\n        r.peeled = value;\n      }\n      continue;\n    }\n    /** @type ServerRef */\n    const ref = {\n      ref: key,\n      oid: value\n    };\n    if (symrefs) {\n      if (remote.symrefs.has(key)) {\n        ref.target = remote.symrefs.get(key);\n      }\n    }\n    refs.push(ref);\n  }\n  return refs;\n}\n\n// @ts-check\n\n/**\n * @typedef {Object} GetRemoteInfo2Result - This object has the following schema:\n * @property {1 | 2} protocolVersion - Git protocol version the server supports\n * @property {Object<string, string | true>} capabilities - An object of capabilities represented as keys and values\n * @property {ServerRef[]} [refs] - Server refs (they get returned by protocol version 1 whether you want them or not)\n */\n\n/**\n * List a remote server's capabilities.\n *\n * This is a rare command that doesn't require an `fs`, `dir`, or even `gitdir` argument.\n * It just communicates to a remote git server, determining what protocol version, commands, and features it supports.\n *\n * > The successor to [`getRemoteInfo`](./getRemoteInfo.md), this command supports Git Wire Protocol Version 2.\n * > Therefore its return type is more complicated as either:\n * >\n * > - v1 capabilities (and refs) or\n * > - v2 capabilities (and no refs)\n * >\n * > are returned.\n * > If you just care about refs, use [`listServerRefs`](./listServerRefs.md)\n *\n * @param {object} args\n * @param {HttpClient} args.http - an HTTP client\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} args.url - The URL of the remote repository. Will be gotten from gitconfig if absent.\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.\n * @param {boolean} [args.forPush = false] - By default, the command queries the 'fetch' capabilities. If true, it will ask for the 'push' capabilities.\n * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n * @param {1 | 2} [args.protocolVersion = 2] - Which version of the Git Protocol to use.\n *\n * @returns {Promise<GetRemoteInfo2Result>} Resolves successfully with an object listing the capabilities of the remote.\n * @see GetRemoteInfo2Result\n * @see ServerRef\n *\n * @example\n * let info = await git.getRemoteInfo2({\n *   http,\n *   corsProxy: \"https://cors.isomorphic-git.org\",\n *   url: \"https://github.com/isomorphic-git/isomorphic-git.git\"\n * });\n * console.log(info);\n *\n */\nasync function getRemoteInfo2({\n  http,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  corsProxy,\n  url,\n  headers = {},\n  forPush = false,\n  protocolVersion = 2\n}) {\n  try {\n    assertParameter('http', http);\n    assertParameter('url', url);\n    const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({\n      url\n    });\n    const remote = await GitRemoteHTTP.discover({\n      http,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      corsProxy,\n      service: forPush ? 'git-receive-pack' : 'git-upload-pack',\n      url,\n      headers,\n      protocolVersion\n    });\n    if (remote.protocolVersion === 2) {\n      /** @type GetRemoteInfo2Result */\n      return {\n        protocolVersion: remote.protocolVersion,\n        capabilities: remote.capabilities2\n      };\n    }\n\n    // Note: remote.capabilities, remote.refs, and remote.symrefs are Set and Map objects,\n    // but one of the objectives of the public API is to always return JSON-compatible objects\n    // so we must JSONify them.\n    /** @type Object<string, true> */\n    const capabilities = {};\n    for (const cap of remote.capabilities) {\n      const [key, value] = cap.split('=');\n      if (value) {\n        capabilities[key] = value;\n      } else {\n        capabilities[key] = true;\n      }\n    }\n    /** @type GetRemoteInfo2Result */\n    return {\n      protocolVersion: 1,\n      capabilities,\n      refs: formatInfoRefs(remote, undefined, true, true)\n    };\n  } catch (err) {\n    err.caller = 'git.getRemoteInfo2';\n    throw err;\n  }\n}\nasync function hashObject({\n  type,\n  object,\n  format = 'content',\n  oid = undefined\n}) {\n  if (format !== 'deflated') {\n    if (format !== 'wrapped') {\n      object = GitObject.wrap({\n        type,\n        object\n      });\n    }\n    oid = await shasum(object);\n  }\n  return {\n    oid,\n    object\n  };\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {object} HashBlobResult - The object returned has the following schema:\n * @property {string} oid - The SHA-1 object id\n * @property {'blob'} type - The type of the object\n * @property {Uint8Array} object - The wrapped git object (the thing that is hashed)\n * @property {'wrapped'} format - The format of the object\n *\n */\n\n/**\n * Compute what the SHA-1 object id of a file would be\n *\n * @param {object} args\n * @param {Uint8Array|string} args.object - The object to write. If `object` is a String then it will be converted to a Uint8Array using UTF-8 encoding.\n *\n * @returns {Promise<HashBlobResult>} Resolves successfully with the SHA-1 object id and the wrapped object Uint8Array.\n * @see HashBlobResult\n *\n * @example\n * let { oid, type, object, format } = await git.hashBlob({\n *   object: 'Hello world!',\n * })\n *\n * console.log('oid', oid)\n * console.log('type', type)\n * console.log('object', object)\n * console.log('format', format)\n *\n */\nasync function hashBlob({\n  object\n}) {\n  try {\n    assertParameter('object', object);\n\n    // Convert object to buffer\n    if (typeof object === 'string') {\n      object = Buffer.from(object, 'utf8');\n    } else {\n      object = Buffer.from(object);\n    }\n    const type = 'blob';\n    const {\n      oid,\n      object: _object\n    } = await hashObject({\n      type: 'blob',\n      format: 'content',\n      object\n    });\n    return {\n      oid,\n      type,\n      object: new Uint8Array(_object),\n      format: 'wrapped'\n    };\n  } catch (err) {\n    err.caller = 'git.hashBlob';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {ProgressCallback} [args.onProgress]\n * @param {string} args.dir\n * @param {string} args.gitdir\n * @param {string} args.filepath\n *\n * @returns {Promise<{oids: string[]}>}\n */\nasync function _indexPack({\n  fs,\n  cache,\n  onProgress,\n  dir,\n  gitdir,\n  filepath\n}) {\n  try {\n    filepath = join(dir, filepath);\n    const pack = await fs.read(filepath);\n    const getExternalRefDelta = oid => _readObject({\n      fs,\n      cache,\n      gitdir,\n      oid\n    });\n    const idx = await GitPackIndex.fromPack({\n      pack,\n      getExternalRefDelta,\n      onProgress\n    });\n    await fs.write(filepath.replace(/\\.pack$/, '.idx'), await idx.toBuffer());\n    return {\n      oids: [...idx.hashes]\n    };\n  } catch (err) {\n    err.caller = 'git.indexPack';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Create the .idx file for a given .pack file\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {ProgressCallback} [args.onProgress] - optional progress event callback\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.filepath - The path to the .pack file to index\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<{oids: string[]}>} Resolves with a list of the SHA-1 object ids contained in the packfile\n *\n * @example\n * let packfiles = await fs.promises.readdir('/tutorial/.git/objects/pack')\n * packfiles = packfiles.filter(name => name.endsWith('.pack'))\n * console.log('packfiles', packfiles)\n *\n * const { oids } = await git.indexPack({\n *   fs,\n *   dir: '/tutorial',\n *   filepath: `.git/objects/pack/${packfiles[0]}`,\n *   async onProgress (evt) {\n *     console.log(`${evt.phase}: ${evt.loaded} / ${evt.total}`)\n *   }\n * })\n * console.log(oids)\n *\n */\nasync function indexPack({\n  fs,\n  onProgress,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('dir', dir);\n    assertParameter('gitdir', dir);\n    assertParameter('filepath', filepath);\n    return await _indexPack({\n      fs: new FileSystem(fs),\n      cache,\n      onProgress,\n      dir,\n      gitdir,\n      filepath\n    });\n  } catch (err) {\n    err.caller = 'git.indexPack';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Initialize a new repository\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {boolean} [args.bare = false] - Initialize a bare repository\n * @param {string} [args.defaultBranch = 'master'] - The name of the default branch (might be changed to a required argument in 2.0.0)\n * @returns {Promise<void>}  Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.init({ fs, dir: '/tutorial' })\n * console.log('done')\n *\n */\nasync function init({\n  fs,\n  bare = false,\n  dir,\n  gitdir = bare ? dir : join(dir, '.git'),\n  defaultBranch = 'master'\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    if (!bare) {\n      assertParameter('dir', dir);\n    }\n    return await _init({\n      fs: new FileSystem(fs),\n      bare,\n      dir,\n      gitdir,\n      defaultBranch\n    });\n  } catch (err) {\n    err.caller = 'git.init';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} args.oid\n * @param {string} args.ancestor\n * @param {number} args.depth - Maximum depth to search before giving up. -1 means no maximum depth.\n *\n * @returns {Promise<boolean>}\n */\nasync function _isDescendent({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  ancestor,\n  depth\n}) {\n  const shallows = await GitShallowManager.read({\n    fs,\n    gitdir\n  });\n  if (!oid) {\n    throw new MissingParameterError('oid');\n  }\n  if (!ancestor) {\n    throw new MissingParameterError('ancestor');\n  }\n  // If you don't like this behavior, add your own check.\n  // Edge cases are hard to define a perfect solution.\n  if (oid === ancestor) return false;\n  // We do not use recursion here, because that would lead to depth-first traversal,\n  // and we want to maintain a breadth-first traversal to avoid hitting shallow clone depth cutoffs.\n  const queue = [oid];\n  const visited = new Set();\n  let searchdepth = 0;\n  while (queue.length) {\n    if (searchdepth++ === depth) {\n      throw new MaxDepthError(depth);\n    }\n    const oid = queue.shift();\n    const {\n      type,\n      object\n    } = await _readObject({\n      fs,\n      cache,\n      gitdir,\n      oid\n    });\n    if (type !== 'commit') {\n      throw new ObjectTypeError(oid, type, 'commit');\n    }\n    const commit = GitCommit.from(object).parse();\n    // Are any of the parents the sought-after ancestor?\n    for (const parent of commit.parent) {\n      if (parent === ancestor) return true;\n    }\n    // If not, add them to heads (unless we know this is a shallow commit)\n    if (!shallows.has(oid)) {\n      for (const parent of commit.parent) {\n        if (!visited.has(parent)) {\n          queue.push(parent);\n          visited.add(parent);\n        }\n      }\n    }\n    // Eventually, we'll travel entire tree to the roots where all the parents are empty arrays,\n    // or hit the shallow depth and throw an error. Excluding the possibility of grafts, or\n    // different branches cloned to different depths, you would hit this error at the same time\n    // for all parents, so trying to continue is futile.\n  }\n  return false;\n}\n\n// @ts-check\n\n/**\n * Check whether a git commit is descended from another\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.oid - The descendent commit\n * @param {string} args.ancestor - The (proposed) ancestor commit\n * @param {number} [args.depth = -1] - Maximum depth to search before giving up. -1 means no maximum depth.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<boolean>} Resolves to true if `oid` is a descendent of `ancestor`\n *\n * @example\n * let oid = await git.resolveRef({ fs, dir: '/tutorial', ref: 'main' })\n * let ancestor = await git.resolveRef({ fs, dir: '/tutorial', ref: 'v0.20.0' })\n * console.log(oid, ancestor)\n * await git.isDescendent({ fs, dir: '/tutorial', oid, ancestor, depth: -1 })\n *\n */\nasync function isDescendent({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oid,\n  ancestor,\n  depth = -1,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n    assertParameter('ancestor', ancestor);\n    return await _isDescendent({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      oid,\n      ancestor,\n      depth\n    });\n  } catch (err) {\n    err.caller = 'git.isDescendent';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Test whether a filepath should be ignored (because of .gitignore or .git/exclude)\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.filepath - The filepath to test\n *\n * @returns {Promise<boolean>} Resolves to true if the file should be ignored\n *\n * @example\n * await git.isIgnored({ fs, dir: '/tutorial', filepath: 'docs/add.md' })\n *\n */\nasync function isIgnored({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('dir', dir);\n    assertParameter('gitdir', gitdir);\n    assertParameter('filepath', filepath);\n    return GitIgnoreManager.isIgnored({\n      fs: new FileSystem(fs),\n      dir,\n      gitdir,\n      filepath\n    });\n  } catch (err) {\n    err.caller = 'git.isIgnored';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * List branches\n *\n * By default it lists local branches. If a 'remote' is specified, it lists the remote's branches. When listing remote branches, the HEAD branch is not filtered out, so it may be included in the list of results.\n *\n * Note that specifying a remote does not actually contact the server and update the list of branches.\n * If you want an up-to-date list, first do a `fetch` to that remote.\n * (Which branch you fetch doesn't matter - the list of branches available on the remote is updated during the fetch handshake.)\n *\n * Also note, that a branch is a reference to a commit. If you initialize a new repository it has no commits, so the\n * `listBranches` function will return an empty list, until you create the first commit.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.remote] - Instead of the branches in `refs/heads`, list the branches in `refs/remotes/${remote}`.\n *\n * @returns {Promise<Array<string>>} Resolves successfully with an array of branch names\n *\n * @example\n * let branches = await git.listBranches({ fs, dir: '/tutorial' })\n * console.log(branches)\n * let remoteBranches = await git.listBranches({ fs, dir: '/tutorial', remote: 'origin' })\n * console.log(remoteBranches)\n *\n */\nasync function listBranches({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  remote\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    return GitRefManager.listBranches({\n      fs: new FileSystem(fs),\n      gitdir,\n      remote\n    });\n  } catch (err) {\n    err.caller = 'git.listBranches';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {string} args.gitdir\n * @param {string} [args.ref]\n *\n * @returns {Promise<Array<string>>}\n */\nasync function _listFiles({\n  fs,\n  gitdir,\n  ref,\n  cache\n}) {\n  if (ref) {\n    const oid = await GitRefManager.resolve({\n      gitdir,\n      fs,\n      ref\n    });\n    const filenames = [];\n    await accumulateFilesFromOid({\n      fs,\n      cache,\n      gitdir,\n      oid,\n      filenames,\n      prefix: ''\n    });\n    return filenames;\n  } else {\n    return GitIndexManager.acquire({\n      fs,\n      gitdir,\n      cache\n    }, async function (index) {\n      return index.entries.map(x => x.path);\n    });\n  }\n}\nasync function accumulateFilesFromOid({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  filenames,\n  prefix\n}) {\n  const {\n    tree\n  } = await _readTree({\n    fs,\n    cache,\n    gitdir,\n    oid\n  });\n  // TODO: Use `walk` to do this. Should be faster.\n  for (const entry of tree) {\n    if (entry.type === 'tree') {\n      await accumulateFilesFromOid({\n        fs,\n        cache,\n        gitdir,\n        oid: entry.oid,\n        filenames,\n        prefix: join(prefix, entry.path)\n      });\n    } else {\n      filenames.push(join(prefix, entry.path));\n    }\n  }\n}\n\n// @ts-check\n\n/**\n * List all the files in the git index or a commit\n *\n * > Note: This function is efficient for listing the files in the staging area, but listing all the files in a commit requires recursively walking through the git object store.\n * > If you do not require a complete list of every file, better performance can be achieved by using [walk](./walk) and ignoring subdirectories you don't care about.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - Return a list of all the files in the commit at `ref` instead of the files currently in the git index (aka staging area)\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<Array<string>>} Resolves successfully with an array of filepaths\n *\n * @example\n * // All the files in the previous commit\n * let files = await git.listFiles({ fs, dir: '/tutorial', ref: 'HEAD' })\n * console.log(files)\n * // All the files in the current staging area\n * files = await git.listFiles({ fs, dir: '/tutorial' })\n * console.log(files)\n *\n */\nasync function listFiles({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    return await _listFiles({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      ref\n    });\n  } catch (err) {\n    err.caller = 'git.listFiles';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * List all the object notes\n *\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} args.ref\n *\n * @returns {Promise<Array<{target: string, note: string}>>}\n */\n\nasync function _listNotes({\n  fs,\n  cache,\n  gitdir,\n  ref\n}) {\n  // Get the current note commit\n  let parent;\n  try {\n    parent = await GitRefManager.resolve({\n      gitdir,\n      fs,\n      ref\n    });\n  } catch (err) {\n    if (err instanceof NotFoundError) {\n      return [];\n    }\n  }\n\n  // Create the current note tree\n  const result = await _readTree({\n    fs,\n    cache,\n    gitdir,\n    oid: parent\n  });\n\n  // Format the tree entries\n  const notes = result.tree.map(entry => ({\n    target: entry.path,\n    note: entry.oid\n  }));\n  return notes;\n}\n\n// @ts-check\n\n/**\n * List all the object notes\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - The notes ref to look under\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<Array<{target: string, note: string}>>} Resolves successfully with an array of entries containing SHA-1 object ids of the note and the object the note targets\n */\n\nasync function listNotes({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref = 'refs/notes/commits',\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    return await _listNotes({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      ref\n    });\n  } catch (err) {\n    err.caller = 'git.listNotes';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n *\n * @returns {Promise<Array<{remote: string, url: string}>>}\n */\nasync function _listRemotes({\n  fs,\n  gitdir\n}) {\n  const config = await GitConfigManager.get({\n    fs,\n    gitdir\n  });\n  const remoteNames = await config.getSubsections('remote');\n  const remotes = Promise.all(remoteNames.map(async remote => {\n    const url = await config.get(`remote.${remote}.url`);\n    return {\n      remote,\n      url\n    };\n  }));\n  return remotes;\n}\n\n// @ts-check\n\n/**\n * List remotes\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n *\n * @returns {Promise<Array<{remote: string, url: string}>>} Resolves successfully with an array of `{remote, url}` objects\n *\n * @example\n * let remotes = await git.listRemotes({ fs, dir: '/tutorial' })\n * console.log(remotes)\n *\n */\nasync function listRemotes({\n  fs,\n  dir,\n  gitdir = join(dir, '.git')\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    return await _listRemotes({\n      fs: new FileSystem(fs),\n      gitdir\n    });\n  } catch (err) {\n    err.caller = 'git.listRemotes';\n    throw err;\n  }\n}\n\n/**\n * @typedef {Object} ServerRef - This object has the following schema:\n * @property {string} ref - The name of the ref\n * @property {string} oid - The SHA-1 object id the ref points to\n * @property {string} [target] - The target ref pointed to by a symbolic ref\n * @property {string} [peeled] - If the oid is the SHA-1 object id of an annotated tag, this is the SHA-1 object id that the annotated tag points to\n */\n\nasync function parseListRefsResponse(stream) {\n  const read = GitPktLine.streamReader(stream);\n\n  // TODO: when we re-write everything to minimize memory usage,\n  // we could make this a generator\n  const refs = [];\n  let line;\n  while (true) {\n    line = await read();\n    if (line === true) break;\n    if (line === null) continue;\n    line = line.toString('utf8').replace(/\\n$/, '');\n    const [oid, ref, ...attrs] = line.split(' ');\n    const r = {\n      ref,\n      oid\n    };\n    for (const attr of attrs) {\n      const [name, value] = attr.split(':');\n      if (name === 'symref-target') {\n        r.target = value;\n      } else if (name === 'peeled') {\n        r.peeled = value;\n      }\n    }\n    refs.push(r);\n  }\n  return refs;\n}\n\n/**\n * @param {object} args\n * @param {string} [args.prefix] - Only list refs that start with this prefix\n * @param {boolean} [args.symrefs = false] - Include symbolic ref targets\n * @param {boolean} [args.peelTags = false] - Include peeled tags values\n * @returns {Uint8Array[]}\n */\nasync function writeListRefsRequest({\n  prefix,\n  symrefs,\n  peelTags\n}) {\n  const packstream = [];\n  // command\n  packstream.push(GitPktLine.encode('command=ls-refs\\n'));\n  // capability-list\n  packstream.push(GitPktLine.encode(`agent=${pkg.agent}\\n`));\n  // [command-args]\n  if (peelTags || symrefs || prefix) {\n    packstream.push(GitPktLine.delim());\n  }\n  if (peelTags) packstream.push(GitPktLine.encode('peel'));\n  if (symrefs) packstream.push(GitPktLine.encode('symrefs'));\n  if (prefix) packstream.push(GitPktLine.encode(`ref-prefix ${prefix}`));\n  packstream.push(GitPktLine.flush());\n  return packstream;\n}\n\n// @ts-check\n\n/**\n * Fetch a list of refs (branches, tags, etc) from a server.\n *\n * This is a rare command that doesn't require an `fs`, `dir`, or even `gitdir` argument.\n * It just requires an `http` argument.\n *\n * ### About `protocolVersion`\n *\n * There's a rather fun trade-off between Git Protocol Version 1 and Git Protocol Version 2.\n * Version 2 actually requires 2 HTTP requests instead of 1, making it similar to fetch or push in that regard.\n * However, version 2 supports server-side filtering by prefix, whereas that filtering is done client-side in version 1.\n * Which protocol is most efficient therefore depends on the number of refs on the remote, the latency of the server, and speed of the network connection.\n * For an small repos (or fast Internet connections), the requirement to make two trips to the server makes protocol 2 slower.\n * But for large repos (or slow Internet connections), the decreased payload size of the second request makes up for the additional request.\n *\n * Hard numbers vary by situation, but here's some numbers from my machine:\n *\n * Using isomorphic-git in a browser, with a CORS proxy, listing only the branches (refs/heads) of https://github.com/isomorphic-git/isomorphic-git\n * - Protocol Version 1 took ~300ms and transfered 84 KB.\n * - Protocol Version 2 took ~500ms and transfered 4.1 KB.\n *\n * Using isomorphic-git in a browser, with a CORS proxy, listing only the branches (refs/heads) of https://gitlab.com/gitlab-org/gitlab\n * - Protocol Version 1 took ~4900ms and transfered 9.41 MB.\n * - Protocol Version 2 took ~1280ms and transfered 433 KB.\n *\n * Finally, there is a fun quirk regarding the `symrefs` parameter.\n * Protocol Version 1 will generally only return the `HEAD` symref and not others.\n * Historically, this meant that servers don't use symbolic refs except for `HEAD`, which is used to point at the \"default branch\".\n * However Protocol Version 2 can return *all* the symbolic refs on the server.\n * So if you are running your own git server, you could take advantage of that I guess.\n *\n * #### TL;DR\n * If you are _not_ taking advantage of `prefix` I would recommend `protocolVersion: 1`.\n * Otherwise, I recommend to use the default which is `protocolVersion: 2`.\n *\n * @param {object} args\n * @param {HttpClient} args.http - an HTTP client\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} args.url - The URL of the remote repository. Will be gotten from gitconfig if absent.\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.\n * @param {boolean} [args.forPush = false] - By default, the command queries the 'fetch' capabilities. If true, it will ask for the 'push' capabilities.\n * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n * @param {1 | 2} [args.protocolVersion = 2] - Which version of the Git Protocol to use.\n * @param {string} [args.prefix] - Only list refs that start with this prefix\n * @param {boolean} [args.symrefs = false] - Include symbolic ref targets\n * @param {boolean} [args.peelTags = false] - Include annotated tag peeled targets\n *\n * @returns {Promise<ServerRef[]>} Resolves successfully with an array of ServerRef objects\n * @see ServerRef\n *\n * @example\n * // List all the branches on a repo\n * let refs = await git.listServerRefs({\n *   http,\n *   corsProxy: \"https://cors.isomorphic-git.org\",\n *   url: \"https://github.com/isomorphic-git/isomorphic-git.git\",\n *   prefix: \"refs/heads/\",\n * });\n * console.log(refs);\n *\n * @example\n * // Get the default branch on a repo\n * let refs = await git.listServerRefs({\n *   http,\n *   corsProxy: \"https://cors.isomorphic-git.org\",\n *   url: \"https://github.com/isomorphic-git/isomorphic-git.git\",\n *   prefix: \"HEAD\",\n *   symrefs: true,\n * });\n * console.log(refs);\n *\n * @example\n * // List all the tags on a repo\n * let refs = await git.listServerRefs({\n *   http,\n *   corsProxy: \"https://cors.isomorphic-git.org\",\n *   url: \"https://github.com/isomorphic-git/isomorphic-git.git\",\n *   prefix: \"refs/tags/\",\n *   peelTags: true,\n * });\n * console.log(refs);\n *\n * @example\n * // List all the pull requests on a repo\n * let refs = await git.listServerRefs({\n *   http,\n *   corsProxy: \"https://cors.isomorphic-git.org\",\n *   url: \"https://github.com/isomorphic-git/isomorphic-git.git\",\n *   prefix: \"refs/pull/\",\n * });\n * console.log(refs);\n *\n */\nasync function listServerRefs({\n  http,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  corsProxy,\n  url,\n  headers = {},\n  forPush = false,\n  protocolVersion = 2,\n  prefix,\n  symrefs,\n  peelTags\n}) {\n  try {\n    assertParameter('http', http);\n    assertParameter('url', url);\n    const remote = await GitRemoteHTTP.discover({\n      http,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      corsProxy,\n      service: forPush ? 'git-receive-pack' : 'git-upload-pack',\n      url,\n      headers,\n      protocolVersion\n    });\n    if (remote.protocolVersion === 1) {\n      return formatInfoRefs(remote, prefix, symrefs, peelTags);\n    }\n\n    // Protocol Version 2\n    const body = await writeListRefsRequest({\n      prefix,\n      symrefs,\n      peelTags\n    });\n    const res = await GitRemoteHTTP.connect({\n      http,\n      auth: remote.auth,\n      headers,\n      corsProxy,\n      service: forPush ? 'git-receive-pack' : 'git-upload-pack',\n      url,\n      body\n    });\n    return parseListRefsResponse(res.body);\n  } catch (err) {\n    err.caller = 'git.listServerRefs';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * List tags\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n *\n * @returns {Promise<Array<string>>} Resolves successfully with an array of tag names\n *\n * @example\n * let tags = await git.listTags({ fs, dir: '/tutorial' })\n * console.log(tags)\n *\n */\nasync function listTags({\n  fs,\n  dir,\n  gitdir = join(dir, '.git')\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    return GitRefManager.listTags({\n      fs: new FileSystem(fs),\n      gitdir\n    });\n  } catch (err) {\n    err.caller = 'git.listTags';\n    throw err;\n  }\n}\nasync function resolveCommit({\n  fs,\n  cache,\n  gitdir,\n  oid\n}) {\n  const {\n    type,\n    object\n  } = await _readObject({\n    fs,\n    cache,\n    gitdir,\n    oid\n  });\n  // Resolve annotated tag objects to whatever\n  if (type === 'tag') {\n    oid = GitAnnotatedTag.from(object).parse().object;\n    return resolveCommit({\n      fs,\n      cache,\n      gitdir,\n      oid\n    });\n  }\n  if (type !== 'commit') {\n    throw new ObjectTypeError(oid, type, 'commit');\n  }\n  return {\n    commit: GitCommit.from(object),\n    oid\n  };\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} args.oid\n *\n * @returns {Promise<ReadCommitResult>} Resolves successfully with a git commit object\n * @see ReadCommitResult\n * @see CommitObject\n *\n */\nasync function _readCommit({\n  fs,\n  cache,\n  gitdir,\n  oid\n}) {\n  const {\n    commit,\n    oid: commitOid\n  } = await resolveCommit({\n    fs,\n    cache,\n    gitdir,\n    oid\n  });\n  const result = {\n    oid: commitOid,\n    commit: commit.parse(),\n    payload: commit.withoutSignature()\n  };\n  // @ts-ignore\n  return result;\n}\nfunction compareAge(a, b) {\n  return a.committer.timestamp - b.committer.timestamp;\n}\n\n// @ts-check\n\n// the empty file content object id\nconst EMPTY_OID = 'e69de29bb2d1d6434b8b29ae775ad8c2e48c5391';\nasync function resolveFileIdInTree({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  fileId\n}) {\n  if (fileId === EMPTY_OID) return;\n  const _oid = oid;\n  let filepath;\n  const result = await resolveTree({\n    fs,\n    cache,\n    gitdir,\n    oid\n  });\n  const tree = result.tree;\n  if (fileId === result.oid) {\n    filepath = result.path;\n  } else {\n    filepath = await _resolveFileId({\n      fs,\n      cache,\n      gitdir,\n      tree,\n      fileId,\n      oid: _oid\n    });\n    if (Array.isArray(filepath)) {\n      if (filepath.length === 0) filepath = undefined;else if (filepath.length === 1) filepath = filepath[0];\n    }\n  }\n  return filepath;\n}\nasync function _resolveFileId({\n  fs,\n  cache,\n  gitdir,\n  tree,\n  fileId,\n  oid,\n  filepaths = [],\n  parentPath = ''\n}) {\n  const walks = tree.entries().map(function (entry) {\n    let result;\n    if (entry.oid === fileId) {\n      result = join(parentPath, entry.path);\n      filepaths.push(result);\n    } else if (entry.type === 'tree') {\n      result = _readObject({\n        fs,\n        cache,\n        gitdir,\n        oid: entry.oid\n      }).then(function ({\n        object\n      }) {\n        return _resolveFileId({\n          fs,\n          cache,\n          gitdir,\n          tree: GitTree.from(object),\n          fileId,\n          oid,\n          filepaths,\n          parentPath: join(parentPath, entry.path)\n        });\n      });\n    }\n    return result;\n  });\n  await Promise.all(walks);\n  return filepaths;\n}\n\n// @ts-check\n\n/**\n * Get commit descriptions from the git history\n *\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string=} args.filepath optional get the commit for the filepath only\n * @param {string} args.ref\n * @param {number|void} args.depth\n * @param {boolean=} [args.force=false] do not throw error if filepath is not exist (works only for a single file). defaults to false\n * @param {boolean=} [args.follow=false] Continue listing the history of a file beyond renames (works only for a single file). defaults to false\n * @param {boolean=} args.follow Continue listing the history of a file beyond renames (works only for a single file). defaults to false\n *\n * @returns {Promise<Array<ReadCommitResult>>} Resolves to an array of ReadCommitResult objects\n * @see ReadCommitResult\n * @see CommitObject\n *\n * @example\n * let commits = await git.log({ dir: '$input((/))', depth: $input((5)), ref: '$input((master))' })\n * console.log(commits)\n *\n */\nasync function _log({\n  fs,\n  cache,\n  gitdir,\n  filepath,\n  ref,\n  depth,\n  since,\n  force,\n  follow\n}) {\n  const sinceTimestamp = typeof since === 'undefined' ? undefined : Math.floor(since.valueOf() / 1000);\n  // TODO: In the future, we may want to have an API where we return a\n  // async iterator that emits commits.\n  const commits = [];\n  const shallowCommits = await GitShallowManager.read({\n    fs,\n    gitdir\n  });\n  const oid = await GitRefManager.resolve({\n    fs,\n    gitdir,\n    ref\n  });\n  const tips = [await _readCommit({\n    fs,\n    cache,\n    gitdir,\n    oid\n  })];\n  let lastFileOid;\n  let lastCommit;\n  let isOk;\n  function endCommit(commit) {\n    if (isOk && filepath) commits.push(commit);\n  }\n  while (tips.length > 0) {\n    const commit = tips.pop();\n\n    // Stop the log if we've hit the age limit\n    if (sinceTimestamp !== undefined && commit.commit.committer.timestamp <= sinceTimestamp) {\n      break;\n    }\n    if (filepath) {\n      let vFileOid;\n      try {\n        vFileOid = await resolveFilepath({\n          fs,\n          cache,\n          gitdir,\n          oid: commit.commit.tree,\n          filepath\n        });\n        if (lastCommit && lastFileOid !== vFileOid) {\n          commits.push(lastCommit);\n        }\n        lastFileOid = vFileOid;\n        lastCommit = commit;\n        isOk = true;\n      } catch (e) {\n        if (e instanceof NotFoundError) {\n          let found = follow && lastFileOid;\n          if (found) {\n            found = await resolveFileIdInTree({\n              fs,\n              cache,\n              gitdir,\n              oid: commit.commit.tree,\n              fileId: lastFileOid\n            });\n            if (found) {\n              if (Array.isArray(found)) {\n                if (lastCommit) {\n                  const lastFound = await resolveFileIdInTree({\n                    fs,\n                    cache,\n                    gitdir,\n                    oid: lastCommit.commit.tree,\n                    fileId: lastFileOid\n                  });\n                  if (Array.isArray(lastFound)) {\n                    found = found.filter(p => lastFound.indexOf(p) === -1);\n                    if (found.length === 1) {\n                      found = found[0];\n                      filepath = found;\n                      if (lastCommit) commits.push(lastCommit);\n                    } else {\n                      found = false;\n                      if (lastCommit) commits.push(lastCommit);\n                      break;\n                    }\n                  }\n                }\n              } else {\n                filepath = found;\n                if (lastCommit) commits.push(lastCommit);\n              }\n            }\n          }\n          if (!found) {\n            if (isOk && lastFileOid) {\n              commits.push(lastCommit);\n              if (!force) break;\n            }\n            if (!force && !follow) throw e;\n          }\n          lastCommit = commit;\n          isOk = false;\n        } else throw e;\n      }\n    } else {\n      commits.push(commit);\n    }\n\n    // Stop the loop if we have enough commits now.\n    if (depth !== undefined && commits.length === depth) {\n      endCommit(commit);\n      break;\n    }\n\n    // If this is not a shallow commit...\n    if (!shallowCommits.has(commit.oid)) {\n      // Add the parents of this commit to the queue\n      // Note: for the case of a commit with no parents, it will concat an empty array, having no net effect.\n      for (const oid of commit.commit.parent) {\n        const commit = await _readCommit({\n          fs,\n          cache,\n          gitdir,\n          oid\n        });\n        if (!tips.map(commit => commit.oid).includes(commit.oid)) {\n          tips.push(commit);\n        }\n      }\n    }\n\n    // Stop the loop if there are no more commit parents\n    if (tips.length === 0) {\n      endCommit(commit);\n    }\n\n    // Process tips in order by age\n    tips.sort((a, b) => compareAge(a.commit, b.commit));\n  }\n  return commits;\n}\n\n// @ts-check\n\n/**\n * Get commit descriptions from the git history\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string=} args.filepath optional get the commit for the filepath only\n * @param {string} [args.ref = 'HEAD'] - The commit to begin walking backwards through the history from\n * @param {number=} [args.depth] - Limit the number of commits returned. No limit by default.\n * @param {Date} [args.since] - Return history newer than the given date. Can be combined with `depth` to get whichever is shorter.\n * @param {boolean=} [args.force=false] do not throw error if filepath is not exist (works only for a single file). defaults to false\n * @param {boolean=} [args.follow=false] Continue listing the history of a file beyond renames (works only for a single file). defaults to false\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<Array<ReadCommitResult>>} Resolves to an array of ReadCommitResult objects\n * @see ReadCommitResult\n * @see CommitObject\n *\n * @example\n * let commits = await git.log({\n *   fs,\n *   dir: '/tutorial',\n *   depth: 5,\n *   ref: 'main'\n * })\n * console.log(commits)\n *\n */\nasync function log({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath,\n  ref = 'HEAD',\n  depth,\n  since,\n  // Date\n  force,\n  follow,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    return await _log({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      filepath,\n      ref,\n      depth,\n      since,\n      force,\n      follow\n    });\n  } catch (err) {\n    err.caller = 'git.log';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} MergeResult - Returns an object with a schema like this:\n * @property {string} [oid] - The SHA-1 object id that is now at the head of the branch. Absent only if `dryRun` was specified and `mergeCommit` is true.\n * @property {boolean} [alreadyMerged] - True if the branch was already merged so no changes were made\n * @property {boolean} [fastForward] - True if it was a fast-forward merge\n * @property {boolean} [mergeCommit] - True if merge resulted in a merge commit\n * @property {string} [tree] - The SHA-1 object id of the tree resulting from a merge commit\n *\n */\n\n/**\n * Merge two branches\n *\n * Currently it will fail if multiple candidate merge bases are found. (It doesn't yet implement the recursive merge strategy.)\n *\n * Currently it does not support selecting alternative merge strategies.\n *\n * Currently it is not possible to abort an incomplete merge. To restore the worktree to a clean state, you will need to checkout an earlier commit.\n *\n * Currently it does not directly support the behavior of `git merge --continue`. To complete a merge after manual conflict resolution, you will need to add and commit the files manually, and specify the appropriate parent commits.\n *\n * ## Manually resolving merge conflicts\n * By default, if isomorphic-git encounters a merge conflict it cannot resolve using the builtin diff3 algorithm or provided merge driver, it will abort and throw a `MergeNotSupportedError`.\n * This leaves the index and working tree untouched.\n *\n * When `abortOnConflict` is set to `false`, and a merge conflict cannot be automatically resolved, a `MergeConflictError` is thrown and the results of the incomplete merge will be written to the working directory.\n * This includes conflict markers in files with unresolved merge conflicts.\n *\n * To complete the merge, edit the conflicting files as you see fit, and then add and commit the resolved merge.\n *\n * For a proper merge commit, be sure to specify the branches or commits you are merging in the `parent` argument to `git.commit`.\n * For example, say we are merging the branch `feature` into the branch `main` and there is a conflict we want to resolve manually.\n * The flow would look like this:\n *\n * ```\n * await git.merge({\n *   fs,\n *   dir,\n *   ours: 'main',\n *   theirs: 'feature',\n *   abortOnConflict: false,\n * }).catch(e => {\n *   if (e instanceof Errors.MergeConflictError) {\n *     console.log(\n *       'Automatic merge failed for the following files: '\n *       + `${e.data}. `\n *       + 'Resolve these conflicts and then commit your changes.'\n *     )\n *   } else throw e\n * })\n *\n * // This is the where we manually edit the files that have been written to the working directory\n * // ...\n * // Files have been edited and we are ready to commit\n *\n * await git.add({\n *   fs,\n *   dir,\n *   filepath: '.',\n * })\n *\n * await git.commit({\n *   fs,\n *   dir,\n *   ref: 'main',\n *   message: \"Merge branch 'feature' into main\",\n *   parent: ['main', 'feature'], // Be sure to specify the parents when creating a merge commit\n * })\n * ```\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {SignCallback} [args.onSign] - a PGP signing implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ours] - The branch receiving the merge. If undefined, defaults to the current branch.\n * @param {string} args.theirs - The branch to be merged\n * @param {boolean} [args.fastForward = true] - If false, create a merge commit in all cases.\n * @param {boolean} [args.fastForwardOnly = false] - If true, then non-fast-forward merges will throw an Error instead of performing a merge.\n * @param {boolean} [args.dryRun = false] - If true, simulates a merge so you can test whether it would succeed.\n * @param {boolean} [args.noUpdateBranch = false] - If true, does not update the branch pointer after creating the commit.\n * @param {boolean} [args.abortOnConflict = true] - If true, merges with conflicts will not update the worktree or index.\n * @param {string} [args.message] - Overrides the default auto-generated merge commit message\n * @param {Object} [args.author] - passed to [commit](commit.md) when creating a merge commit\n * @param {string} [args.author.name] - Default is `user.name` config.\n * @param {string} [args.author.email] - Default is `user.email` config.\n * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {Object} [args.committer] - passed to [commit](commit.md) when creating a merge commit\n * @param {string} [args.committer.name] - Default is `user.name` config.\n * @param {string} [args.committer.email] - Default is `user.email` config.\n * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {string} [args.signingKey] - passed to [commit](commit.md) when creating a merge commit\n * @param {object} [args.cache] - a [cache](cache.md) object\n * @param {MergeDriverCallback} [args.mergeDriver] - a [merge driver](mergeDriver.md) implementation\n *\n * @returns {Promise<MergeResult>} Resolves to a description of the merge operation\n * @see MergeResult\n *\n * @example\n * let m = await git.merge({\n *   fs,\n *   dir: '/tutorial',\n *   ours: 'main',\n *   theirs: 'remotes/origin/main'\n * })\n * console.log(m)\n *\n */\nasync function merge({\n  fs: _fs,\n  onSign,\n  dir,\n  gitdir = join(dir, '.git'),\n  ours,\n  theirs,\n  fastForward = true,\n  fastForwardOnly = false,\n  dryRun = false,\n  noUpdateBranch = false,\n  abortOnConflict = true,\n  message,\n  author: _author,\n  committer: _committer,\n  signingKey,\n  cache = {},\n  mergeDriver\n}) {\n  try {\n    assertParameter('fs', _fs);\n    if (signingKey) {\n      assertParameter('onSign', onSign);\n    }\n    const fs = new FileSystem(_fs);\n    const author = await normalizeAuthorObject({\n      fs,\n      gitdir,\n      author: _author\n    });\n    if (!author && (!fastForwardOnly || !fastForward)) {\n      throw new MissingNameError('author');\n    }\n    const committer = await normalizeCommitterObject({\n      fs,\n      gitdir,\n      author,\n      committer: _committer\n    });\n    if (!committer && (!fastForwardOnly || !fastForward)) {\n      throw new MissingNameError('committer');\n    }\n    return await _merge({\n      fs,\n      cache,\n      dir,\n      gitdir,\n      ours,\n      theirs,\n      fastForward,\n      fastForwardOnly,\n      dryRun,\n      noUpdateBranch,\n      abortOnConflict,\n      message,\n      author,\n      committer,\n      signingKey,\n      onSign,\n      mergeDriver\n    });\n  } catch (err) {\n    err.caller = 'git.merge';\n    throw err;\n  }\n}\n\n/**\n * @enum {number}\n */\nconst types = {\n  commit: 0b0010000,\n  tree: 0b0100000,\n  blob: 0b0110000,\n  tag: 0b1000000,\n  ofs_delta: 0b1100000,\n  ref_delta: 0b1110000\n};\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string[]} args.oids\n */\nasync function _pack({\n  fs,\n  cache,\n  dir,\n  gitdir = join(dir, '.git'),\n  oids\n}) {\n  const hash = new Hash();\n  const outputStream = [];\n  function write(chunk, enc) {\n    const buff = Buffer.from(chunk, enc);\n    outputStream.push(buff);\n    hash.update(buff);\n  }\n  async function writeObject({\n    stype,\n    object\n  }) {\n    // Object type is encoded in bits 654\n    const type = types[stype];\n    // The length encoding gets complicated.\n    let length = object.length;\n    // Whether the next byte is part of the variable-length encoded number\n    // is encoded in bit 7\n    let multibyte = length > 0b1111 ? 0b10000000 : 0b0;\n    // Last four bits of length is encoded in bits 3210\n    const lastFour = length & 0b1111;\n    // Discard those bits\n    length = length >>> 4;\n    // The first byte is then (1-bit multibyte?), (3-bit type), (4-bit least sig 4-bits of length)\n    let byte = (multibyte | type | lastFour).toString(16);\n    write(byte, 'hex');\n    // Now we keep chopping away at length 7-bits at a time until its zero,\n    // writing out the bytes in what amounts to little-endian order.\n    while (multibyte) {\n      multibyte = length > 0b01111111 ? 0b10000000 : 0b0;\n      byte = multibyte | length & 0b01111111;\n      write(padHex(2, byte), 'hex');\n      length = length >>> 7;\n    }\n    // Lastly, we can compress and write the object.\n    write(Buffer.from(await deflate(object)));\n  }\n  write('PACK');\n  write('00000002', 'hex');\n  // Write a 4 byte (32-bit) int\n  write(padHex(8, oids.length), 'hex');\n  for (const oid of oids) {\n    const {\n      type,\n      object\n    } = await _readObject({\n      fs,\n      cache,\n      gitdir,\n      oid\n    });\n    await writeObject({\n      write,\n      object,\n      stype: type\n    });\n  }\n  // Write SHA1 checksum\n  const digest = hash.digest();\n  outputStream.push(digest);\n  return outputStream;\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} PackObjectsResult The packObjects command returns an object with two properties:\n * @property {string} filename - The suggested filename for the packfile if you want to save it to disk somewhere. It includes the packfile SHA.\n * @property {Uint8Array} [packfile] - The packfile contents. Not present if `write` parameter was true, in which case the packfile was written straight to disk.\n */\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string[]} args.oids\n * @param {boolean} args.write\n *\n * @returns {Promise<PackObjectsResult>}\n * @see PackObjectsResult\n */\nasync function _packObjects({\n  fs,\n  cache,\n  gitdir,\n  oids,\n  write\n}) {\n  const buffers = await _pack({\n    fs,\n    cache,\n    gitdir,\n    oids\n  });\n  const packfile = Buffer.from(await collect(buffers));\n  const packfileSha = packfile.slice(-20).toString('hex');\n  const filename = `pack-${packfileSha}.pack`;\n  if (write) {\n    await fs.write(join(gitdir, `objects/pack/${filename}`), packfile);\n    return {\n      filename\n    };\n  }\n  return {\n    filename,\n    packfile: new Uint8Array(packfile)\n  };\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} PackObjectsResult The packObjects command returns an object with two properties:\n * @property {string} filename - The suggested filename for the packfile if you want to save it to disk somewhere. It includes the packfile SHA.\n * @property {Uint8Array} [packfile] - The packfile contents. Not present if `write` parameter was true, in which case the packfile was written straight to disk.\n */\n\n/**\n * Create a packfile from an array of SHA-1 object ids\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string[]} args.oids - An array of SHA-1 object ids to be included in the packfile\n * @param {boolean} [args.write = false] - Whether to save the packfile to disk or not\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<PackObjectsResult>} Resolves successfully when the packfile is ready with the filename and buffer\n * @see PackObjectsResult\n *\n * @example\n * // Create a packfile containing only an empty tree\n * let { packfile } = await git.packObjects({\n *   fs,\n *   dir: '/tutorial',\n *   oids: ['4b825dc642cb6eb9a060e54bf8d69288fbee4904']\n * })\n * console.log(packfile)\n *\n */\nasync function packObjects({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oids,\n  write = false,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oids', oids);\n    return await _packObjects({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      oids,\n      write\n    });\n  } catch (err) {\n    err.caller = 'git.packObjects';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Fetch and merge commits from a remote repository\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {HttpClient} args.http - an HTTP client\n * @param {ProgressCallback} [args.onProgress] - optional progress event callback\n * @param {MessageCallback} [args.onMessage] - optional message event callback\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - Which branch to merge into. By default this is the currently checked out branch.\n * @param {string} [args.url] - (Added in 1.1.0) The URL of the remote repository. The default is the value set in the git config for that remote.\n * @param {string} [args.remote] - (Added in 1.1.0) If URL is not specified, determines which remote to use.\n * @param {string} [args.remoteRef] - (Added in 1.1.0) The name of the branch on the remote to fetch. By default this is the configured remote tracking branch.\n * @param {boolean} [args.prune = false] - Delete local remote-tracking branches that are not present on the remote\n * @param {boolean} [args.pruneTags = false] - Prune local tags that dont exist on the remote, and force-update those tags that differ\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.\n * @param {boolean} [args.singleBranch = false] - Instead of the default behavior of fetching all the branches, only fetch a single branch.\n * @param {boolean} [args.fastForward = true] -  If false, only create merge commits.\n * @param {boolean} [args.fastForwardOnly = false] - Only perform simple fast-forward merges. (Don't create merge commits.)\n * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n * @param {Object} [args.author] - The details about the author.\n * @param {string} [args.author.name] - Default is `user.name` config.\n * @param {string} [args.author.email] - Default is `user.email` config.\n * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {Object} [args.committer = author] - The details about the commit committer, in the same format as the author parameter. If not specified, the author details are used.\n * @param {string} [args.committer.name] - Default is `user.name` config.\n * @param {string} [args.committer.email] - Default is `user.email` config.\n * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {string} [args.signingKey] - passed to [commit](commit.md) when creating a merge commit\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully when pull operation completes\n *\n * @example\n * await git.pull({\n *   fs,\n *   http,\n *   dir: '/tutorial',\n *   ref: 'main',\n *   singleBranch: true\n * })\n * console.log('done')\n *\n */\nasync function pull({\n  fs: _fs,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  url,\n  remote,\n  remoteRef,\n  prune = false,\n  pruneTags = false,\n  fastForward = true,\n  fastForwardOnly = false,\n  corsProxy,\n  singleBranch,\n  headers = {},\n  author: _author,\n  committer: _committer,\n  signingKey,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    const fs = new FileSystem(_fs);\n    const author = await normalizeAuthorObject({\n      fs,\n      gitdir,\n      author: _author\n    });\n    if (!author) throw new MissingNameError('author');\n    const committer = await normalizeCommitterObject({\n      fs,\n      gitdir,\n      author,\n      committer: _committer\n    });\n    if (!committer) throw new MissingNameError('committer');\n    return await _pull({\n      fs,\n      cache,\n      http,\n      onProgress,\n      onMessage,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      dir,\n      gitdir,\n      ref,\n      url,\n      remote,\n      remoteRef,\n      fastForward,\n      fastForwardOnly,\n      corsProxy,\n      singleBranch,\n      headers,\n      author,\n      committer,\n      signingKey,\n      prune,\n      pruneTags\n    });\n  } catch (err) {\n    err.caller = 'git.pull';\n    throw err;\n  }\n}\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} [args.dir]\n * @param {string} args.gitdir\n * @param {Iterable<string>} args.start\n * @param {Iterable<string>} args.finish\n * @returns {Promise<Set<string>>}\n */\nasync function listCommitsAndTags({\n  fs,\n  cache,\n  dir,\n  gitdir = join(dir, '.git'),\n  start,\n  finish\n}) {\n  const shallows = await GitShallowManager.read({\n    fs,\n    gitdir\n  });\n  const startingSet = new Set();\n  const finishingSet = new Set();\n  for (const ref of start) {\n    startingSet.add(await GitRefManager.resolve({\n      fs,\n      gitdir,\n      ref\n    }));\n  }\n  for (const ref of finish) {\n    // We may not have these refs locally so we must try/catch\n    try {\n      const oid = await GitRefManager.resolve({\n        fs,\n        gitdir,\n        ref\n      });\n      finishingSet.add(oid);\n    } catch (err) {}\n  }\n  const visited = new Set();\n  // Because git commits are named by their hash, there is no\n  // way to construct a cycle. Therefore we won't worry about\n  // setting a default recursion limit.\n  async function walk(oid) {\n    visited.add(oid);\n    const {\n      type,\n      object\n    } = await _readObject({\n      fs,\n      cache,\n      gitdir,\n      oid\n    });\n    // Recursively resolve annotated tags\n    if (type === 'tag') {\n      const tag = GitAnnotatedTag.from(object);\n      const commit = tag.headers().object;\n      return walk(commit);\n    }\n    if (type !== 'commit') {\n      throw new ObjectTypeError(oid, type, 'commit');\n    }\n    if (!shallows.has(oid)) {\n      const commit = GitCommit.from(object);\n      const parents = commit.headers().parent;\n      for (oid of parents) {\n        if (!finishingSet.has(oid) && !visited.has(oid)) {\n          await walk(oid);\n        }\n      }\n    }\n  }\n  // Let's go walking!\n  for (const oid of startingSet) {\n    await walk(oid);\n  }\n  return visited;\n}\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} [args.dir]\n * @param {string} args.gitdir\n * @param {Iterable<string>} args.oids\n * @returns {Promise<Set<string>>}\n */\nasync function listObjects({\n  fs,\n  cache,\n  dir,\n  gitdir = join(dir, '.git'),\n  oids\n}) {\n  const visited = new Set();\n  // We don't do the purest simplest recursion, because we can\n  // avoid reading Blob objects entirely since the Tree objects\n  // tell us which oids are Blobs and which are Trees.\n  async function walk(oid) {\n    if (visited.has(oid)) return;\n    visited.add(oid);\n    const {\n      type,\n      object\n    } = await _readObject({\n      fs,\n      cache,\n      gitdir,\n      oid\n    });\n    if (type === 'tag') {\n      const tag = GitAnnotatedTag.from(object);\n      const obj = tag.headers().object;\n      await walk(obj);\n    } else if (type === 'commit') {\n      const commit = GitCommit.from(object);\n      const tree = commit.headers().tree;\n      await walk(tree);\n    } else if (type === 'tree') {\n      const tree = GitTree.from(object);\n      for (const entry of tree) {\n        // add blobs to the set\n        // skip over submodules whose type is 'commit'\n        if (entry.type === 'blob') {\n          visited.add(entry.oid);\n        }\n        // recurse for trees\n        if (entry.type === 'tree') {\n          await walk(entry.oid);\n        }\n      }\n    }\n  }\n  // Let's go walking!\n  for (const oid of oids) {\n    await walk(oid);\n  }\n  return visited;\n}\nasync function parseReceivePackResponse(packfile) {\n  /** @type PushResult */\n  const result = {};\n  let response = '';\n  const read = GitPktLine.streamReader(packfile);\n  let line = await read();\n  while (line !== true) {\n    if (line !== null) response += line.toString('utf8') + '\\n';\n    line = await read();\n  }\n  const lines = response.toString('utf8').split('\\n');\n  // We're expecting \"unpack {unpack-result}\"\n  line = lines.shift();\n  if (!line.startsWith('unpack ')) {\n    throw new ParseError('unpack ok\" or \"unpack [error message]', line);\n  }\n  result.ok = line === 'unpack ok';\n  if (!result.ok) {\n    result.error = line.slice('unpack '.length);\n  }\n  result.refs = {};\n  for (const line of lines) {\n    if (line.trim() === '') continue;\n    const status = line.slice(0, 2);\n    const refAndMessage = line.slice(3);\n    let space = refAndMessage.indexOf(' ');\n    if (space === -1) space = refAndMessage.length;\n    const ref = refAndMessage.slice(0, space);\n    const error = refAndMessage.slice(space + 1);\n    result.refs[ref] = {\n      ok: status === 'ok',\n      error\n    };\n  }\n  return result;\n}\nasync function writeReceivePackRequest({\n  capabilities = [],\n  triplets = []\n}) {\n  const packstream = [];\n  let capsFirstLine = `\\x00 ${capabilities.join(' ')}`;\n  for (const trip of triplets) {\n    packstream.push(GitPktLine.encode(`${trip.oldoid} ${trip.oid} ${trip.fullRef}${capsFirstLine}\\n`));\n    capsFirstLine = '';\n  }\n  packstream.push(GitPktLine.flush());\n  return packstream;\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {HttpClient} args.http\n * @param {ProgressCallback} [args.onProgress]\n * @param {MessageCallback} [args.onMessage]\n * @param {AuthCallback} [args.onAuth]\n * @param {AuthFailureCallback} [args.onAuthFailure]\n * @param {AuthSuccessCallback} [args.onAuthSuccess]\n * @param {string} args.gitdir\n * @param {string} [args.ref]\n * @param {string} [args.remoteRef]\n * @param {string} [args.remote]\n * @param {boolean} [args.force = false]\n * @param {boolean} [args.delete = false]\n * @param {string} [args.url]\n * @param {string} [args.corsProxy]\n * @param {Object<string, string>} [args.headers]\n *\n * @returns {Promise<PushResult>}\n */\nasync function _push({\n  fs,\n  cache,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  gitdir,\n  ref: _ref,\n  remoteRef: _remoteRef,\n  remote,\n  url: _url,\n  force = false,\n  delete: _delete = false,\n  corsProxy,\n  headers = {}\n}) {\n  const ref = _ref || (await _currentBranch({\n    fs,\n    gitdir\n  }));\n  if (typeof ref === 'undefined') {\n    throw new MissingParameterError('ref');\n  }\n  const config = await GitConfigManager.get({\n    fs,\n    gitdir\n  });\n  // Figure out what remote to use.\n  remote = remote || (await config.get(`branch.${ref}.pushRemote`)) || (await config.get('remote.pushDefault')) || (await config.get(`branch.${ref}.remote`)) || 'origin';\n  // Lookup the URL for the given remote.\n  const url = _url || (await config.get(`remote.${remote}.pushurl`)) || (await config.get(`remote.${remote}.url`));\n  if (typeof url === 'undefined') {\n    throw new MissingParameterError('remote OR url');\n  }\n  // Figure out what remote ref to use.\n  const remoteRef = _remoteRef || (await config.get(`branch.${ref}.merge`));\n  if (typeof url === 'undefined') {\n    throw new MissingParameterError('remoteRef');\n  }\n  if (corsProxy === undefined) {\n    corsProxy = await config.get('http.corsProxy');\n  }\n  const fullRef = await GitRefManager.expand({\n    fs,\n    gitdir,\n    ref\n  });\n  const oid = _delete ? '0000000000000000000000000000000000000000' : await GitRefManager.resolve({\n    fs,\n    gitdir,\n    ref: fullRef\n  });\n\n  /** @type typeof import(\"../managers/GitRemoteHTTP\").GitRemoteHTTP */\n  const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({\n    url\n  });\n  const httpRemote = await GitRemoteHTTP.discover({\n    http,\n    onAuth,\n    onAuthSuccess,\n    onAuthFailure,\n    corsProxy,\n    service: 'git-receive-pack',\n    url,\n    headers,\n    protocolVersion: 1\n  });\n  const auth = httpRemote.auth; // hack to get new credentials from CredentialManager API\n  let fullRemoteRef;\n  if (!remoteRef) {\n    fullRemoteRef = fullRef;\n  } else {\n    try {\n      fullRemoteRef = await GitRefManager.expandAgainstMap({\n        ref: remoteRef,\n        map: httpRemote.refs\n      });\n    } catch (err) {\n      if (err instanceof NotFoundError) {\n        // The remote reference doesn't exist yet.\n        // If it is fully specified, use that value. Otherwise, treat it as a branch.\n        fullRemoteRef = remoteRef.startsWith('refs/') ? remoteRef : `refs/heads/${remoteRef}`;\n      } else {\n        throw err;\n      }\n    }\n  }\n  const oldoid = httpRemote.refs.get(fullRemoteRef) || '0000000000000000000000000000000000000000';\n\n  // Remotes can always accept thin-packs UNLESS they specify the 'no-thin' capability\n  const thinPack = !httpRemote.capabilities.has('no-thin');\n  let objects = new Set();\n  if (!_delete) {\n    const finish = [...httpRemote.refs.values()];\n    let skipObjects = new Set();\n\n    // If remote branch is present, look for a common merge base.\n    if (oldoid !== '0000000000000000000000000000000000000000') {\n      // trick to speed up common force push scenarios\n      const mergebase = await _findMergeBase({\n        fs,\n        cache,\n        gitdir,\n        oids: [oid, oldoid]\n      });\n      for (const oid of mergebase) finish.push(oid);\n      if (thinPack) {\n        skipObjects = await listObjects({\n          fs,\n          cache,\n          gitdir,\n          oids: mergebase\n        });\n      }\n    }\n\n    // If remote does not have the commit, figure out the objects to send\n    if (!finish.includes(oid)) {\n      const commits = await listCommitsAndTags({\n        fs,\n        cache,\n        gitdir,\n        start: [oid],\n        finish\n      });\n      objects = await listObjects({\n        fs,\n        cache,\n        gitdir,\n        oids: commits\n      });\n    }\n    if (thinPack) {\n      // If there's a default branch for the remote lets skip those objects too.\n      // Since this is an optional optimization, we just catch and continue if there is\n      // an error (because we can't find a default branch, or can't find a commit, etc)\n      try {\n        // Sadly, the discovery phase with 'forPush' doesn't return symrefs, so we have to\n        // rely on existing ones.\n        const ref = await GitRefManager.resolve({\n          fs,\n          gitdir,\n          ref: `refs/remotes/${remote}/HEAD`,\n          depth: 2\n        });\n        const {\n          oid\n        } = await GitRefManager.resolveAgainstMap({\n          ref: ref.replace(`refs/remotes/${remote}/`, ''),\n          fullref: ref,\n          map: httpRemote.refs\n        });\n        const oids = [oid];\n        for (const oid of await listObjects({\n          fs,\n          cache,\n          gitdir,\n          oids\n        })) {\n          skipObjects.add(oid);\n        }\n      } catch (e) {}\n\n      // Remove objects that we know the remote already has\n      for (const oid of skipObjects) {\n        objects.delete(oid);\n      }\n    }\n    if (oid === oldoid) force = true;\n    if (!force) {\n      // Is it a tag that already exists?\n      if (fullRef.startsWith('refs/tags') && oldoid !== '0000000000000000000000000000000000000000') {\n        throw new PushRejectedError('tag-exists');\n      }\n      // Is it a non-fast-forward commit?\n      if (oid !== '0000000000000000000000000000000000000000' && oldoid !== '0000000000000000000000000000000000000000' && !(await _isDescendent({\n        fs,\n        cache,\n        gitdir,\n        oid,\n        ancestor: oldoid,\n        depth: -1\n      }))) {\n        throw new PushRejectedError('not-fast-forward');\n      }\n    }\n  }\n  // We can only safely use capabilities that the server also understands.\n  // For instance, AWS CodeCommit aborts a push if you include the `agent`!!!\n  const capabilities = filterCapabilities([...httpRemote.capabilities], ['report-status', 'side-band-64k', `agent=${pkg.agent}`]);\n  const packstream1 = await writeReceivePackRequest({\n    capabilities,\n    triplets: [{\n      oldoid,\n      oid,\n      fullRef: fullRemoteRef\n    }]\n  });\n  const packstream2 = _delete ? [] : await _pack({\n    fs,\n    cache,\n    gitdir,\n    oids: [...objects]\n  });\n  const res = await GitRemoteHTTP.connect({\n    http,\n    onProgress,\n    corsProxy,\n    service: 'git-receive-pack',\n    url,\n    auth,\n    headers,\n    body: [...packstream1, ...packstream2]\n  });\n  const {\n    packfile,\n    progress\n  } = await GitSideBand.demux(res.body);\n  if (onMessage) {\n    const lines = splitLines(progress);\n    forAwait(lines, async line => {\n      await onMessage(line);\n    });\n  }\n  // Parse the response!\n  const result = await parseReceivePackResponse(packfile);\n  if (res.headers) {\n    result.headers = res.headers;\n  }\n\n  // Update the local copy of the remote ref\n  if (remote && result.ok && result.refs[fullRemoteRef].ok) {\n    // TODO: I think this should actually be using a refspec transform rather than assuming 'refs/remotes/{remote}'\n    const ref = `refs/remotes/${remote}/${fullRemoteRef.replace('refs/heads', '')}`;\n    if (_delete) {\n      await GitRefManager.deleteRef({\n        fs,\n        gitdir,\n        ref\n      });\n    } else {\n      await GitRefManager.writeRef({\n        fs,\n        gitdir,\n        ref,\n        value: oid\n      });\n    }\n  }\n  if (result.ok && Object.values(result.refs).every(result => result.ok)) {\n    return result;\n  } else {\n    const prettyDetails = Object.entries(result.refs).filter(([k, v]) => !v.ok).map(([k, v]) => `\\n  - ${k}: ${v.error}`).join('');\n    throw new GitPushError(prettyDetails, result);\n  }\n}\n\n// @ts-check\n\n/**\n * Push a branch or tag\n *\n * The push command returns an object that describes the result of the attempted push operation.\n * *Notes:* If there were no errors, then there will be no `errors` property. There can be a mix of `ok` messages and `errors` messages.\n *\n * | param  | type [= default] | description                                                                                                                                                                                                      |\n * | ------ | ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n * | ok     | Array\\<string\\>  | The first item is \"unpack\" if the overall operation was successful. The remaining items are the names of refs that were updated successfully.                                                                    |\n * | errors | Array\\<string\\>  | If the overall operation threw and error, the first item will be \"unpack {Overall error message}\". The remaining items are individual refs that failed to be updated in the format \"{ref name} {error message}\". |\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {HttpClient} args.http - an HTTP client\n * @param {ProgressCallback} [args.onProgress] - optional progress event callback\n * @param {MessageCallback} [args.onMessage] - optional message event callback\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - Which branch to push. By default this is the currently checked out branch.\n * @param {string} [args.url] - The URL of the remote repository. The default is the value set in the git config for that remote.\n * @param {string} [args.remote] - If URL is not specified, determines which remote to use.\n * @param {string} [args.remoteRef] - The name of the receiving branch on the remote. By default this is the configured remote tracking branch.\n * @param {boolean} [args.force = false] - If true, behaves the same as `git push --force`\n * @param {boolean} [args.delete = false] - If true, delete the remote ref\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.\n * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<PushResult>} Resolves successfully when push completes with a detailed description of the operation from the server.\n * @see PushResult\n * @see RefUpdateStatus\n *\n * @example\n * let pushResult = await git.push({\n *   fs,\n *   http,\n *   dir: '/tutorial',\n *   remote: 'origin',\n *   ref: 'main',\n *   onAuth: () => ({ username: process.env.GITHUB_TOKEN }),\n * })\n * console.log(pushResult)\n *\n */\nasync function push({\n  fs,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  remoteRef,\n  remote = 'origin',\n  url,\n  force = false,\n  delete: _delete = false,\n  corsProxy,\n  headers = {},\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('http', http);\n    assertParameter('gitdir', gitdir);\n    return await _push({\n      fs: new FileSystem(fs),\n      cache,\n      http,\n      onProgress,\n      onMessage,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      gitdir,\n      ref,\n      remoteRef,\n      remote,\n      url,\n      force,\n      delete: _delete,\n      corsProxy,\n      headers\n    });\n  } catch (err) {\n    err.caller = 'git.push';\n    throw err;\n  }\n}\nasync function resolveBlob({\n  fs,\n  cache,\n  gitdir,\n  oid\n}) {\n  const {\n    type,\n    object\n  } = await _readObject({\n    fs,\n    cache,\n    gitdir,\n    oid\n  });\n  // Resolve annotated tag objects to whatever\n  if (type === 'tag') {\n    oid = GitAnnotatedTag.from(object).parse().object;\n    return resolveBlob({\n      fs,\n      cache,\n      gitdir,\n      oid\n    });\n  }\n  if (type !== 'blob') {\n    throw new ObjectTypeError(oid, type, 'blob');\n  }\n  return {\n    oid,\n    blob: new Uint8Array(object)\n  };\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} ReadBlobResult - The object returned has the following schema:\n * @property {string} oid\n * @property {Uint8Array} blob\n *\n */\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} args.oid\n * @param {string} [args.filepath]\n *\n * @returns {Promise<ReadBlobResult>} Resolves successfully with a blob object description\n * @see ReadBlobResult\n */\nasync function _readBlob({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  filepath = undefined\n}) {\n  if (filepath !== undefined) {\n    oid = await resolveFilepath({\n      fs,\n      cache,\n      gitdir,\n      oid,\n      filepath\n    });\n  }\n  const blob = await resolveBlob({\n    fs,\n    cache,\n    gitdir,\n    oid\n  });\n  return blob;\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} ReadBlobResult - The object returned has the following schema:\n * @property {string} oid\n * @property {Uint8Array} blob\n *\n */\n\n/**\n * Read a blob object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.oid - The SHA-1 object id to get. Annotated tags, commits, and trees are peeled.\n * @param {string} [args.filepath] - Don't return the object with `oid` itself, but resolve `oid` to a tree and then return the blob object at that filepath.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<ReadBlobResult>} Resolves successfully with a blob object description\n * @see ReadBlobResult\n *\n * @example\n * // Get the contents of 'README.md' in the main branch.\n * let commitOid = await git.resolveRef({ fs, dir: '/tutorial', ref: 'main' })\n * console.log(commitOid)\n * let { blob } = await git.readBlob({\n *   fs,\n *   dir: '/tutorial',\n *   oid: commitOid,\n *   filepath: 'README.md'\n * })\n * console.log(Buffer.from(blob).toString('utf8'))\n *\n */\nasync function readBlob({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oid,\n  filepath,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n    return await _readBlob({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      oid,\n      filepath\n    });\n  } catch (err) {\n    err.caller = 'git.readBlob';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Read a commit object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.oid - The SHA-1 object id to get. Annotated tags are peeled.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<ReadCommitResult>} Resolves successfully with a git commit object\n * @see ReadCommitResult\n * @see CommitObject\n *\n * @example\n * // Read a commit object\n * let sha = await git.resolveRef({ fs, dir: '/tutorial', ref: 'main' })\n * console.log(sha)\n * let commit = await git.readCommit({ fs, dir: '/tutorial', oid: sha })\n * console.log(commit)\n *\n */\nasync function readCommit({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oid,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n    return await _readCommit({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      oid\n    });\n  } catch (err) {\n    err.caller = 'git.readCommit';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Read the contents of a note\n *\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} [args.ref] - The notes ref to look under\n * @param {string} args.oid\n *\n * @returns {Promise<Uint8Array>} Resolves successfully with note contents as a Buffer.\n */\n\nasync function _readNote({\n  fs,\n  cache,\n  gitdir,\n  ref = 'refs/notes/commits',\n  oid\n}) {\n  const parent = await GitRefManager.resolve({\n    gitdir,\n    fs,\n    ref\n  });\n  const {\n    blob\n  } = await _readBlob({\n    fs,\n    cache,\n    gitdir,\n    oid: parent,\n    filepath: oid\n  });\n  return blob;\n}\n\n// @ts-check\n\n/**\n * Read the contents of a note\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - The notes ref to look under\n * @param {string} args.oid - The SHA-1 object id of the object to get the note for.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<Uint8Array>} Resolves successfully with note contents as a Buffer.\n */\n\nasync function readNote({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref = 'refs/notes/commits',\n  oid,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    assertParameter('oid', oid);\n    return await _readNote({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      ref,\n      oid\n    });\n  } catch (err) {\n    err.caller = 'git.readNote';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} DeflatedObject\n * @property {string} oid\n * @property {'deflated'} type\n * @property {'deflated'} format\n * @property {Uint8Array} object\n * @property {string} [source]\n *\n */\n\n/**\n *\n * @typedef {Object} WrappedObject\n * @property {string} oid\n * @property {'wrapped'} type\n * @property {'wrapped'} format\n * @property {Uint8Array} object\n * @property {string} [source]\n *\n */\n\n/**\n *\n * @typedef {Object} RawObject\n * @property {string} oid\n * @property {'blob'|'commit'|'tree'|'tag'} type\n * @property {'content'} format\n * @property {Uint8Array} object\n * @property {string} [source]\n *\n */\n\n/**\n *\n * @typedef {Object} ParsedBlobObject\n * @property {string} oid\n * @property {'blob'} type\n * @property {'parsed'} format\n * @property {string} object\n * @property {string} [source]\n *\n */\n\n/**\n *\n * @typedef {Object} ParsedCommitObject\n * @property {string} oid\n * @property {'commit'} type\n * @property {'parsed'} format\n * @property {CommitObject} object\n * @property {string} [source]\n *\n */\n\n/**\n *\n * @typedef {Object} ParsedTreeObject\n * @property {string} oid\n * @property {'tree'} type\n * @property {'parsed'} format\n * @property {TreeObject} object\n * @property {string} [source]\n *\n */\n\n/**\n *\n * @typedef {Object} ParsedTagObject\n * @property {string} oid\n * @property {'tag'} type\n * @property {'parsed'} format\n * @property {TagObject} object\n * @property {string} [source]\n *\n */\n\n/**\n *\n * @typedef {ParsedBlobObject | ParsedCommitObject | ParsedTreeObject | ParsedTagObject} ParsedObject\n */\n\n/**\n *\n * @typedef {DeflatedObject | WrappedObject | RawObject | ParsedObject } ReadObjectResult\n */\n\n/**\n * Read a git object directly by its SHA-1 object id\n *\n * Regarding `ReadObjectResult`:\n *\n * - `oid` will be the same as the `oid` argument unless the `filepath` argument is provided, in which case it will be the oid of the tree or blob being returned.\n * - `type` of deflated objects is `'deflated'`, and `type` of wrapped objects is `'wrapped'`\n * - `format` is usually, but not always, the format you requested. Packfiles do not store each object individually compressed so if you end up reading the object from a packfile it will be returned in format 'content' even if you requested 'deflated' or 'wrapped'.\n * - `object` will be an actual Object if format is 'parsed' and the object is a commit, tree, or annotated tag. Blobs are still formatted as Buffers unless an encoding is provided in which case they'll be strings. If format is anything other than 'parsed', object will be a Buffer.\n * - `source` is the name of the packfile or loose object file where the object was found.\n *\n * The `format` parameter can have the following values:\n *\n * | param      | description                                                                                                                                                                                               |\n * | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n * | 'deflated' | Return the raw deflate-compressed buffer for an object if possible. Useful for efficiently shuffling around loose objects when you don't care about the contents and can save time by not inflating them. |\n * | 'wrapped'  | Return the inflated object buffer wrapped in the git object header if possible. This is the raw data used when calculating the SHA-1 object id of a git object.                                           |\n * | 'content'  | Return the object buffer without the git header.                                                                                                                                                          |\n * | 'parsed'   | Returns a parsed representation of the object.                                                                                                                                                            |\n *\n * The result will be in one of the following schemas:\n *\n * ## `'deflated'` format\n *\n * {@link DeflatedObject typedef}\n *\n * ## `'wrapped'` format\n *\n * {@link WrappedObject typedef}\n *\n * ## `'content'` format\n *\n * {@link RawObject typedef}\n *\n * ## `'parsed'` format\n *\n * ### parsed `'blob'` type\n *\n * {@link ParsedBlobObject typedef}\n *\n * ### parsed `'commit'` type\n *\n * {@link ParsedCommitObject typedef}\n * {@link CommitObject typedef}\n *\n * ### parsed `'tree'` type\n *\n * {@link ParsedTreeObject typedef}\n * {@link TreeObject typedef}\n * {@link TreeEntry typedef}\n *\n * ### parsed `'tag'` type\n *\n * {@link ParsedTagObject typedef}\n * {@link TagObject typedef}\n *\n * @deprecated\n * > This command is overly complicated.\n * >\n * > If you know the type of object you are reading, use [`readBlob`](./readBlob.md), [`readCommit`](./readCommit.md), [`readTag`](./readTag.md), or [`readTree`](./readTree.md).\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.oid - The SHA-1 object id to get\n * @param {'deflated' | 'wrapped' | 'content' | 'parsed'} [args.format = 'parsed'] - What format to return the object in. The choices are described in more detail below.\n * @param {string} [args.filepath] - Don't return the object with `oid` itself, but resolve `oid` to a tree and then return the object at that filepath. To return the root directory of a tree set filepath to `''`\n * @param {string} [args.encoding] - A convenience argument that only affects blobs. Instead of returning `object` as a buffer, it returns a string parsed using the given encoding.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<ReadObjectResult>} Resolves successfully with a git object description\n * @see ReadObjectResult\n *\n * @example\n * // Given a ransom SHA-1 object id, figure out what it is\n * let { type, object } = await git.readObject({\n *   fs,\n *   dir: '/tutorial',\n *   oid: '0698a781a02264a6f37ba3ff41d78067eaf0f075'\n * })\n * switch (type) {\n *   case 'commit': {\n *     console.log(object)\n *     break\n *   }\n *   case 'tree': {\n *     console.log(object)\n *     break\n *   }\n *   case 'blob': {\n *     console.log(object)\n *     break\n *   }\n *   case 'tag': {\n *     console.log(object)\n *     break\n *   }\n * }\n *\n */\nasync function readObject({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oid,\n  format = 'parsed',\n  filepath = undefined,\n  encoding = undefined,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n    const fs = new FileSystem(_fs);\n    if (filepath !== undefined) {\n      oid = await resolveFilepath({\n        fs,\n        cache,\n        gitdir,\n        oid,\n        filepath\n      });\n    }\n    // GitObjectManager does not know how to parse content, so we tweak that parameter before passing it.\n    const _format = format === 'parsed' ? 'content' : format;\n    const result = await _readObject({\n      fs,\n      cache,\n      gitdir,\n      oid,\n      format: _format\n    });\n    result.oid = oid;\n    if (format === 'parsed') {\n      result.format = 'parsed';\n      switch (result.type) {\n        case 'commit':\n          result.object = GitCommit.from(result.object).parse();\n          break;\n        case 'tree':\n          result.object = GitTree.from(result.object).entries();\n          break;\n        case 'blob':\n          // Here we consider returning a raw Buffer as the 'content' format\n          // and returning a string as the 'parsed' format\n          if (encoding) {\n            result.object = result.object.toString(encoding);\n          } else {\n            result.object = new Uint8Array(result.object);\n            result.format = 'content';\n          }\n          break;\n        case 'tag':\n          result.object = GitAnnotatedTag.from(result.object).parse();\n          break;\n        default:\n          throw new ObjectTypeError(result.oid, result.type, 'blob|commit|tag|tree');\n      }\n    } else if (result.format === 'deflated' || result.format === 'wrapped') {\n      result.type = result.format;\n    }\n    return result;\n  } catch (err) {\n    err.caller = 'git.readObject';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} ReadTagResult - The object returned has the following schema:\n * @property {string} oid - SHA-1 object id of this tag\n * @property {TagObject} tag - the parsed tag object\n * @property {string} payload - PGP signing payload\n */\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} args.oid\n *\n * @returns {Promise<ReadTagResult>}\n */\nasync function _readTag({\n  fs,\n  cache,\n  gitdir,\n  oid\n}) {\n  const {\n    type,\n    object\n  } = await _readObject({\n    fs,\n    cache,\n    gitdir,\n    oid,\n    format: 'content'\n  });\n  if (type !== 'tag') {\n    throw new ObjectTypeError(oid, type, 'tag');\n  }\n  const tag = GitAnnotatedTag.from(object);\n  const result = {\n    oid,\n    tag: tag.parse(),\n    payload: tag.payload()\n  };\n  // @ts-ignore\n  return result;\n}\n\n/**\n *\n * @typedef {Object} ReadTagResult - The object returned has the following schema:\n * @property {string} oid - SHA-1 object id of this tag\n * @property {TagObject} tag - the parsed tag object\n * @property {string} payload - PGP signing payload\n */\n\n/**\n * Read an annotated tag object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.oid - The SHA-1 object id to get\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<ReadTagResult>} Resolves successfully with a git object description\n * @see ReadTagResult\n * @see TagObject\n *\n */\nasync function readTag({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oid,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n    return await _readTag({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      oid\n    });\n  } catch (err) {\n    err.caller = 'git.readTag';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} ReadTreeResult - The object returned has the following schema:\n * @property {string} oid - SHA-1 object id of this tree\n * @property {TreeObject} tree - the parsed tree object\n */\n\n/**\n * Read a tree object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.oid - The SHA-1 object id to get. Annotated tags and commits are peeled.\n * @param {string} [args.filepath] - Don't return the object with `oid` itself, but resolve `oid` to a tree and then return the tree object at that filepath.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<ReadTreeResult>} Resolves successfully with a git tree object\n * @see ReadTreeResult\n * @see TreeObject\n * @see TreeEntry\n *\n */\nasync function readTree({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oid,\n  filepath = undefined,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n    return await _readTree({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      oid,\n      filepath\n    });\n  } catch (err) {\n    err.caller = 'git.readTree';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Remove a file from the git index (aka staging area)\n *\n * Note that this does NOT delete the file in the working directory.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.filepath - The path to the file to remove from the index\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully once the git index has been updated\n *\n * @example\n * await git.remove({ fs, dir: '/tutorial', filepath: 'README.md' })\n * console.log('done')\n *\n */\nasync function remove({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('filepath', filepath);\n    await GitIndexManager.acquire({\n      fs: new FileSystem(_fs),\n      gitdir,\n      cache\n    }, async function (index) {\n      index.delete({\n        filepath\n      });\n    });\n  } catch (err) {\n    err.caller = 'git.remove';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {SignCallback} [args.onSign]\n * @param {string} [args.dir]\n * @param {string} [args.gitdir=join(dir,'.git')]\n * @param {string} [args.ref]\n * @param {string} args.oid\n * @param {Object} args.author\n * @param {string} args.author.name\n * @param {string} args.author.email\n * @param {number} args.author.timestamp\n * @param {number} args.author.timezoneOffset\n * @param {Object} args.committer\n * @param {string} args.committer.name\n * @param {string} args.committer.email\n * @param {number} args.committer.timestamp\n * @param {number} args.committer.timezoneOffset\n * @param {string} [args.signingKey]\n *\n * @returns {Promise<string>}\n */\n\nasync function _removeNote({\n  fs,\n  cache,\n  onSign,\n  gitdir,\n  ref = 'refs/notes/commits',\n  oid,\n  author,\n  committer,\n  signingKey\n}) {\n  // Get the current note commit\n  let parent;\n  try {\n    parent = await GitRefManager.resolve({\n      gitdir,\n      fs,\n      ref\n    });\n  } catch (err) {\n    if (!(err instanceof NotFoundError)) {\n      throw err;\n    }\n  }\n\n  // I'm using the \"empty tree\" magic number here for brevity\n  const result = await _readTree({\n    fs,\n    gitdir,\n    oid: parent || '4b825dc642cb6eb9a060e54bf8d69288fbee4904'\n  });\n  let tree = result.tree;\n\n  // Remove the note blob entry from the tree\n  tree = tree.filter(entry => entry.path !== oid);\n\n  // Create the new note tree\n  const treeOid = await _writeTree({\n    fs,\n    gitdir,\n    tree\n  });\n\n  // Create the new note commit\n  const commitOid = await _commit({\n    fs,\n    cache,\n    onSign,\n    gitdir,\n    ref,\n    tree: treeOid,\n    parent: parent && [parent],\n    message: `Note removed by 'isomorphic-git removeNote'\\n`,\n    author,\n    committer,\n    signingKey\n  });\n  return commitOid;\n}\n\n// @ts-check\n\n/**\n * Remove an object note\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {SignCallback} [args.onSign] - a PGP signing implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - The notes ref to look under\n * @param {string} args.oid - The SHA-1 object id of the object to remove the note from.\n * @param {Object} [args.author] - The details about the author.\n * @param {string} [args.author.name] - Default is `user.name` config.\n * @param {string} [args.author.email] - Default is `user.email` config.\n * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {Object} [args.committer = author] - The details about the note committer, in the same format as the author parameter. If not specified, the author details are used.\n * @param {string} [args.committer.name] - Default is `user.name` config.\n * @param {string} [args.committer.email] - Default is `user.email` config.\n * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {string} [args.signingKey] - Sign the tag object using this private PGP key.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the commit object for the note removal.\n */\n\nasync function removeNote({\n  fs: _fs,\n  onSign,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref = 'refs/notes/commits',\n  oid,\n  author: _author,\n  committer: _committer,\n  signingKey,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n    const fs = new FileSystem(_fs);\n    const author = await normalizeAuthorObject({\n      fs,\n      gitdir,\n      author: _author\n    });\n    if (!author) throw new MissingNameError('author');\n    const committer = await normalizeCommitterObject({\n      fs,\n      gitdir,\n      author,\n      committer: _committer\n    });\n    if (!committer) throw new MissingNameError('committer');\n    return await _removeNote({\n      fs,\n      cache,\n      onSign,\n      gitdir,\n      ref,\n      oid,\n      author,\n      committer,\n      signingKey\n    });\n  } catch (err) {\n    err.caller = 'git.removeNote';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Rename a branch\n *\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.ref - The name of the new branch\n * @param {string} args.oldref - The name of the old branch\n * @param {boolean} [args.checkout = false]\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n */\nasync function _renameBranch({\n  fs,\n  gitdir,\n  oldref,\n  ref,\n  checkout = false\n}) {\n  if (ref !== cleanGitRef.clean(ref)) {\n    throw new InvalidRefNameError(ref, cleanGitRef.clean(ref));\n  }\n  if (oldref !== cleanGitRef.clean(oldref)) {\n    throw new InvalidRefNameError(oldref, cleanGitRef.clean(oldref));\n  }\n  const fulloldref = `refs/heads/${oldref}`;\n  const fullnewref = `refs/heads/${ref}`;\n  const newexist = await GitRefManager.exists({\n    fs,\n    gitdir,\n    ref: fullnewref\n  });\n  if (newexist) {\n    throw new AlreadyExistsError('branch', ref, false);\n  }\n  const value = await GitRefManager.resolve({\n    fs,\n    gitdir,\n    ref: fulloldref,\n    depth: 1\n  });\n  await GitRefManager.writeRef({\n    fs,\n    gitdir,\n    ref: fullnewref,\n    value\n  });\n  await GitRefManager.deleteRef({\n    fs,\n    gitdir,\n    ref: fulloldref\n  });\n  const fullCurrentBranchRef = await _currentBranch({\n    fs,\n    gitdir,\n    fullname: true\n  });\n  const isCurrentBranch = fullCurrentBranchRef === fulloldref;\n  if (checkout || isCurrentBranch) {\n    // Update HEAD\n    await GitRefManager.writeSymbolicRef({\n      fs,\n      gitdir,\n      ref: 'HEAD',\n      value: fullnewref\n    });\n  }\n}\n\n// @ts-check\n\n/**\n * Rename a branch\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - What to name the branch\n * @param {string} args.oldref - What the name of the branch was\n * @param {boolean} [args.checkout = false] - Update `HEAD` to point at the newly created branch\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.renameBranch({ fs, dir: '/tutorial', ref: 'main', oldref: 'master' })\n * console.log('done')\n *\n */\nasync function renameBranch({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  oldref,\n  checkout = false\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    assertParameter('oldref', oldref);\n    return await _renameBranch({\n      fs: new FileSystem(fs),\n      gitdir,\n      ref,\n      oldref,\n      checkout\n    });\n  } catch (err) {\n    err.caller = 'git.renameBranch';\n    throw err;\n  }\n}\nasync function hashObject$1({\n  gitdir,\n  type,\n  object\n}) {\n  return shasum(GitObject.wrap({\n    type,\n    object\n  }));\n}\n\n// @ts-check\n\n/**\n * Reset a file in the git index (aka staging area)\n *\n * Note that this does NOT modify the file in the working directory.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.filepath - The path to the file to reset in the index\n * @param {string} [args.ref = 'HEAD'] - A ref to the commit to use\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully once the git index has been updated\n *\n * @example\n * await git.resetIndex({ fs, dir: '/tutorial', filepath: 'README.md' })\n * console.log('done')\n *\n */\nasync function resetIndex({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath,\n  ref,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('filepath', filepath);\n    const fs = new FileSystem(_fs);\n    let oid;\n    let workdirOid;\n    try {\n      // Resolve commit\n      oid = await GitRefManager.resolve({\n        fs,\n        gitdir,\n        ref: ref || 'HEAD'\n      });\n    } catch (e) {\n      if (ref) {\n        // Only throw the error if a ref is explicitly provided\n        throw e;\n      }\n    }\n\n    // Not having an oid at this point means `resetIndex()` was called without explicit `ref` on a new git\n    // repository. If that happens, we can skip resolving the file path.\n    if (oid) {\n      try {\n        // Resolve blob\n        oid = await resolveFilepath({\n          fs,\n          cache,\n          gitdir,\n          oid,\n          filepath\n        });\n      } catch (e) {\n        // This means we're resetting the file to a \"deleted\" state\n        oid = null;\n      }\n    }\n\n    // For files that aren't in the workdir use zeros\n    let stats = {\n      ctime: new Date(0),\n      mtime: new Date(0),\n      dev: 0,\n      ino: 0,\n      mode: 0,\n      uid: 0,\n      gid: 0,\n      size: 0\n    };\n    // If the file exists in the workdir...\n    const object = dir && (await fs.read(join(dir, filepath)));\n    if (object) {\n      // ... and has the same hash as the desired state...\n      workdirOid = await hashObject$1({\n        gitdir,\n        type: 'blob',\n        object\n      });\n      if (oid === workdirOid) {\n        // ... use the workdir Stats object\n        stats = await fs.lstat(join(dir, filepath));\n      }\n    }\n    await GitIndexManager.acquire({\n      fs,\n      gitdir,\n      cache\n    }, async function (index) {\n      index.delete({\n        filepath\n      });\n      if (oid) {\n        index.insert({\n          filepath,\n          stats,\n          oid\n        });\n      }\n    });\n  } catch (err) {\n    err.caller = 'git.reset';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Get the value of a symbolic ref or resolve a ref to its SHA-1 object id\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - The ref to resolve\n * @param {number} [args.depth = undefined] - How many symbolic references to follow before returning\n *\n * @returns {Promise<string>} Resolves successfully with a SHA-1 object id or the value of a symbolic ref\n *\n * @example\n * let currentCommit = await git.resolveRef({ fs, dir: '/tutorial', ref: 'HEAD' })\n * console.log(currentCommit)\n * let currentBranch = await git.resolveRef({ fs, dir: '/tutorial', ref: 'HEAD', depth: 2 })\n * console.log(currentBranch)\n *\n */\nasync function resolveRef({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  depth\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    const oid = await GitRefManager.resolve({\n      fs: new FileSystem(fs),\n      gitdir,\n      ref,\n      depth\n    });\n    return oid;\n  } catch (err) {\n    err.caller = 'git.resolveRef';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Write an entry to the git config files.\n *\n * *Caveats:*\n * - Currently only the local `$GIT_DIR/config` file can be read or written. However support for the global `~/.gitconfig` and system `$(prefix)/etc/gitconfig` will be added in the future.\n * - The current parser does not support the more exotic features of the git-config file format such as `[include]` and `[includeIf]`.\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.path - The key of the git config entry\n * @param {string | boolean | number | void} args.value - A value to store at that path. (Use `undefined` as the value to delete a config entry.)\n * @param {boolean} [args.append = false] - If true, will append rather than replace when setting (use with multi-valued config options).\n *\n * @returns {Promise<void>} Resolves successfully when operation completed\n *\n * @example\n * // Write config value\n * await git.setConfig({\n *   fs,\n *   dir: '/tutorial',\n *   path: 'user.name',\n *   value: 'Mr. Test'\n * })\n *\n * // Print out config file\n * let file = await fs.promises.readFile('/tutorial/.git/config', 'utf8')\n * console.log(file)\n *\n * // Delete a config entry\n * await git.setConfig({\n *   fs,\n *   dir: '/tutorial',\n *   path: 'user.name',\n *   value: undefined\n * })\n *\n * // Print out config file\n * file = await fs.promises.readFile('/tutorial/.git/config', 'utf8')\n * console.log(file)\n */\nasync function setConfig({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  path,\n  value,\n  append = false\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('path', path);\n    // assertParameter('value', value) // We actually allow 'undefined' as a value to unset/delete\n\n    const fs = new FileSystem(_fs);\n    const config = await GitConfigManager.get({\n      fs,\n      gitdir\n    });\n    if (append) {\n      await config.append(path, value);\n    } else {\n      await config.set(path, value);\n    }\n    await GitConfigManager.save({\n      fs,\n      gitdir,\n      config\n    });\n  } catch (err) {\n    err.caller = 'git.setConfig';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Tell whether a file has been changed\n *\n * The possible resolve values are:\n *\n * | status                | description                                                                           |\n * | --------------------- | ------------------------------------------------------------------------------------- |\n * | `\"ignored\"`           | file ignored by a .gitignore rule                                                     |\n * | `\"unmodified\"`        | file unchanged from HEAD commit                                                       |\n * | `\"*modified\"`         | file has modifications, not yet staged                                                |\n * | `\"*deleted\"`          | file has been removed, but the removal is not yet staged                              |\n * | `\"*added\"`            | file is untracked, not yet staged                                                     |\n * | `\"absent\"`            | file not present in HEAD commit, staging area, or working dir                         |\n * | `\"modified\"`          | file has modifications, staged                                                        |\n * | `\"deleted\"`           | file has been removed, staged                                                         |\n * | `\"added\"`             | previously untracked file, staged                                                     |\n * | `\"*unmodified\"`       | working dir and HEAD commit match, but index differs                                  |\n * | `\"*absent\"`           | file not present in working dir or HEAD commit, but present in the index              |\n * | `\"*undeleted\"`        | file was deleted from the index, but is still in the working dir                      |\n * | `\"*undeletemodified\"` | file was deleted from the index, but is present with modifications in the working dir |\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.filepath - The path to the file to query\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<'ignored'|'unmodified'|'*modified'|'*deleted'|'*added'|'absent'|'modified'|'deleted'|'added'|'*unmodified'|'*absent'|'*undeleted'|'*undeletemodified'>} Resolves successfully with the file's git status\n *\n * @example\n * let status = await git.status({ fs, dir: '/tutorial', filepath: 'README.md' })\n * console.log(status)\n *\n */\nasync function status({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('filepath', filepath);\n    const fs = new FileSystem(_fs);\n    const ignored = await GitIgnoreManager.isIgnored({\n      fs,\n      gitdir,\n      dir,\n      filepath\n    });\n    if (ignored) {\n      return 'ignored';\n    }\n    const headTree = await getHeadTree({\n      fs,\n      cache,\n      gitdir\n    });\n    const treeOid = await getOidAtPath({\n      fs,\n      cache,\n      gitdir,\n      tree: headTree,\n      path: filepath\n    });\n    const indexEntry = await GitIndexManager.acquire({\n      fs,\n      gitdir,\n      cache\n    }, async function (index) {\n      for (const entry of index) {\n        if (entry.path === filepath) return entry;\n      }\n      return null;\n    });\n    const stats = await fs.lstat(join(dir, filepath));\n    const H = treeOid !== null; // head\n    const I = indexEntry !== null; // index\n    const W = stats !== null; // working dir\n\n    const getWorkdirOid = async () => {\n      if (I && !compareStats(indexEntry, stats)) {\n        return indexEntry.oid;\n      } else {\n        const object = await fs.read(join(dir, filepath));\n        const workdirOid = await hashObject$1({\n          gitdir,\n          type: 'blob',\n          object\n        });\n        // If the oid in the index === working dir oid but stats differed update cache\n        if (I && indexEntry.oid === workdirOid) {\n          // and as long as our fs.stats aren't bad.\n          // size of -1 happens over a BrowserFS HTTP Backend that doesn't serve Content-Length headers\n          // (like the Karma webserver) because BrowserFS HTTP Backend uses HTTP HEAD requests to do fs.stat\n          if (stats.size !== -1) {\n            // We don't await this so we can return faster for one-off cases.\n            GitIndexManager.acquire({\n              fs,\n              gitdir,\n              cache\n            }, async function (index) {\n              index.insert({\n                filepath,\n                stats,\n                oid: workdirOid\n              });\n            });\n          }\n        }\n        return workdirOid;\n      }\n    };\n    if (!H && !W && !I) return 'absent'; // ---\n    if (!H && !W && I) return '*absent'; // -A-\n    if (!H && W && !I) return '*added'; // --A\n    if (!H && W && I) {\n      const workdirOid = await getWorkdirOid();\n      // @ts-ignore\n      return workdirOid === indexEntry.oid ? 'added' : '*added'; // -AA : -AB\n    }\n    if (H && !W && !I) return 'deleted'; // A--\n    if (H && !W && I) {\n      // @ts-ignore\n      return treeOid === indexEntry.oid ? '*deleted' : '*deleted'; // AA- : AB-\n    }\n    if (H && W && !I) {\n      const workdirOid = await getWorkdirOid();\n      return workdirOid === treeOid ? '*undeleted' : '*undeletemodified'; // A-A : A-B\n    }\n    if (H && W && I) {\n      const workdirOid = await getWorkdirOid();\n      if (workdirOid === treeOid) {\n        // @ts-ignore\n        return workdirOid === indexEntry.oid ? 'unmodified' : '*unmodified'; // AAA : ABA\n      } else {\n        // @ts-ignore\n        return workdirOid === indexEntry.oid ? 'modified' : '*modified'; // ABB : AAB\n      }\n    }\n    /*\n    ---\n    -A-\n    --A\n    -AA\n    -AB\n    A--\n    AA-\n    AB-\n    A-A\n    A-B\n    AAA\n    ABA\n    ABB\n    AAB\n    */\n  } catch (err) {\n    err.caller = 'git.status';\n    throw err;\n  }\n}\nasync function getOidAtPath({\n  fs,\n  cache,\n  gitdir,\n  tree,\n  path\n}) {\n  if (typeof path === 'string') path = path.split('/');\n  const dirname = path.shift();\n  for (const entry of tree) {\n    if (entry.path === dirname) {\n      if (path.length === 0) {\n        return entry.oid;\n      }\n      const {\n        type,\n        object\n      } = await _readObject({\n        fs,\n        cache,\n        gitdir,\n        oid: entry.oid\n      });\n      if (type === 'tree') {\n        const tree = GitTree.from(object);\n        return getOidAtPath({\n          fs,\n          cache,\n          gitdir,\n          tree,\n          path\n        });\n      }\n      if (type === 'blob') {\n        throw new ObjectTypeError(entry.oid, type, 'blob', path.join('/'));\n      }\n    }\n  }\n  return null;\n}\nasync function getHeadTree({\n  fs,\n  cache,\n  gitdir\n}) {\n  // Get the tree from the HEAD commit.\n  let oid;\n  try {\n    oid = await GitRefManager.resolve({\n      fs,\n      gitdir,\n      ref: 'HEAD'\n    });\n  } catch (e) {\n    // Handle fresh branches with no commits\n    if (e instanceof NotFoundError) {\n      return [];\n    }\n  }\n  const {\n    tree\n  } = await _readTree({\n    fs,\n    cache,\n    gitdir,\n    oid\n  });\n  return tree;\n}\n\n// @ts-check\n\n/**\n * Efficiently get the status of multiple files at once.\n *\n * The returned `StatusMatrix` is admittedly not the easiest format to read.\n * However it conveys a large amount of information in dense format that should make it easy to create reports about the current state of the repository;\n * without having to do multiple, time-consuming isomorphic-git calls.\n * My hope is that the speed and flexibility of the function will make up for the learning curve of interpreting the return value.\n *\n * ```js live\n * // get the status of all the files in 'src'\n * let status = await git.statusMatrix({\n *   fs,\n *   dir: '/tutorial',\n *   filter: f => f.startsWith('src/')\n * })\n * console.log(status)\n * ```\n *\n * ```js live\n * // get the status of all the JSON and Markdown files\n * let status = await git.statusMatrix({\n *   fs,\n *   dir: '/tutorial',\n *   filter: f => f.endsWith('.json') || f.endsWith('.md')\n * })\n * console.log(status)\n * ```\n *\n * The result is returned as a 2D array.\n * The outer array represents the files and/or blobs in the repo, in alphabetical order.\n * The inner arrays describe the status of the file:\n * the first value is the filepath, and the next three are integers\n * representing the HEAD status, WORKDIR status, and STAGE status of the entry.\n *\n * ```js\n * // example StatusMatrix\n * [\n *   [\"a.txt\", 0, 2, 0], // new, untracked\n *   [\"b.txt\", 0, 2, 2], // added, staged\n *   [\"c.txt\", 0, 2, 3], // added, staged, with unstaged changes\n *   [\"d.txt\", 1, 1, 1], // unmodified\n *   [\"e.txt\", 1, 2, 1], // modified, unstaged\n *   [\"f.txt\", 1, 2, 2], // modified, staged\n *   [\"g.txt\", 1, 2, 3], // modified, staged, with unstaged changes\n *   [\"h.txt\", 1, 0, 1], // deleted, unstaged\n *   [\"i.txt\", 1, 0, 0], // deleted, staged\n * ]\n * ```\n *\n * - The HEAD status is either absent (0) or present (1).\n * - The WORKDIR status is either absent (0), identical to HEAD (1), or different from HEAD (2).\n * - The STAGE status is either absent (0), identical to HEAD (1), identical to WORKDIR (2), or different from WORKDIR (3).\n *\n * ```ts\n * type Filename      = string\n * type HeadStatus    = 0 | 1\n * type WorkdirStatus = 0 | 1 | 2\n * type StageStatus   = 0 | 1 | 2 | 3\n *\n * type StatusRow     = [Filename, HeadStatus, WorkdirStatus, StageStatus]\n *\n * type StatusMatrix  = StatusRow[]\n * ```\n *\n * > Think of the natural progression of file modifications as being from HEAD (previous) -> WORKDIR (current) -> STAGE (next).\n * > Then HEAD is \"version 1\", WORKDIR is \"version 2\", and STAGE is \"version 3\".\n * > Then, imagine a \"version 0\" which is before the file was created.\n * > Then the status value in each column corresponds to the oldest version of the file it is identical to.\n * > (For a file to be identical to \"version 0\" means the file is deleted.)\n *\n * Here are some examples of queries you can answer using the result:\n *\n * #### Q: What files have been deleted?\n * ```js\n * const FILE = 0, WORKDIR = 2\n *\n * const filenames = (await statusMatrix({ dir }))\n *   .filter(row => row[WORKDIR] === 0)\n *   .map(row => row[FILE])\n * ```\n *\n * #### Q: What files have unstaged changes?\n * ```js\n * const FILE = 0, WORKDIR = 2, STAGE = 3\n *\n * const filenames = (await statusMatrix({ dir }))\n *   .filter(row => row[WORKDIR] !== row[STAGE])\n *   .map(row => row[FILE])\n * ```\n *\n * #### Q: What files have been modified since the last commit?\n * ```js\n * const FILE = 0, HEAD = 1, WORKDIR = 2\n *\n * const filenames = (await statusMatrix({ dir }))\n *   .filter(row => row[HEAD] !== row[WORKDIR])\n *   .map(row => row[FILE])\n * ```\n *\n * #### Q: What files will NOT be changed if I commit right now?\n * ```js\n * const FILE = 0, HEAD = 1, STAGE = 3\n *\n * const filenames = (await statusMatrix({ dir }))\n *   .filter(row => row[HEAD] === row[STAGE])\n *   .map(row => row[FILE])\n * ```\n *\n * For reference, here are all possible combinations:\n *\n * | HEAD | WORKDIR | STAGE | `git status --short` equivalent |\n * | ---- | ------- | ----- | ------------------------------- |\n * | 0    | 0       | 0     | ``                              |\n * | 0    | 0       | 3     | `AD`                            |\n * | 0    | 2       | 0     | `??`                            |\n * | 0    | 2       | 2     | `A `                            |\n * | 0    | 2       | 3     | `AM`                            |\n * | 1    | 0       | 0     | `D `                            |\n * | 1    | 0       | 1     | ` D`                            |\n * | 1    | 0       | 3     | `MD`                            |\n * | 1    | 1       | 0     | `D ` + `??`                     |\n * | 1    | 1       | 1     | ``                              |\n * | 1    | 1       | 3     | `MM`                            |\n * | 1    | 2       | 0     | `D ` + `??`                     |\n * | 1    | 2       | 1     | ` M`                            |\n * | 1    | 2       | 2     | `M `                            |\n * | 1    | 2       | 3     | `MM`                            |\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref = 'HEAD'] - Optionally specify a different commit to compare against the workdir and stage instead of the HEAD\n * @param {string[]} [args.filepaths = ['.']] - Limit the query to the given files and directories\n * @param {function(string): boolean} [args.filter] - Filter the results to only those whose filepath matches a function.\n * @param {object} [args.cache] - a [cache](cache.md) object\n * @param {boolean} [args.ignored = false] - include ignored files in the result\n *\n * @returns {Promise<Array<StatusRow>>} Resolves with a status matrix, described below.\n * @see StatusRow\n */\nasync function statusMatrix({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref = 'HEAD',\n  filepaths = ['.'],\n  filter,\n  cache = {},\n  ignored: shouldIgnore = false\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    const fs = new FileSystem(_fs);\n    return await _walk({\n      fs,\n      cache,\n      dir,\n      gitdir,\n      trees: [TREE({\n        ref\n      }), WORKDIR(), STAGE()],\n      map: async function (filepath, [head, workdir, stage]) {\n        // Ignore ignored files, but only if they are not already tracked.\n        if (!head && !stage && workdir) {\n          if (!shouldIgnore) {\n            const isIgnored = await GitIgnoreManager.isIgnored({\n              fs,\n              dir,\n              filepath\n            });\n            if (isIgnored) {\n              return null;\n            }\n          }\n        }\n        // match against base paths\n        if (!filepaths.some(base => worthWalking(filepath, base))) {\n          return null;\n        }\n        // Late filter against file names\n        if (filter) {\n          if (!filter(filepath)) return;\n        }\n        const [headType, workdirType, stageType] = await Promise.all([head && head.type(), workdir && workdir.type(), stage && stage.type()]);\n        const isBlob = [headType, workdirType, stageType].includes('blob');\n\n        // For now, bail on directories unless the file is also a blob in another tree\n        if ((headType === 'tree' || headType === 'special') && !isBlob) return;\n        if (headType === 'commit') return null;\n        if ((workdirType === 'tree' || workdirType === 'special') && !isBlob) return;\n        if (stageType === 'commit') return null;\n        if ((stageType === 'tree' || stageType === 'special') && !isBlob) return;\n\n        // Figure out the oids for files, using the staged oid for the working dir oid if the stats match.\n        const headOid = headType === 'blob' ? await head.oid() : undefined;\n        const stageOid = stageType === 'blob' ? await stage.oid() : undefined;\n        let workdirOid;\n        if (headType !== 'blob' && workdirType === 'blob' && stageType !== 'blob') {\n          // We don't actually NEED the sha. Any sha will do\n          // TODO: update this logic to handle N trees instead of just 3.\n          workdirOid = '42';\n        } else if (workdirType === 'blob') {\n          workdirOid = await workdir.oid();\n        }\n        const entry = [undefined, headOid, workdirOid, stageOid];\n        const result = entry.map(value => entry.indexOf(value));\n        result.shift(); // remove leading undefined entry\n        return [filepath, ...result];\n      }\n    });\n  } catch (err) {\n    err.caller = 'git.statusMatrix';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Create a lightweight tag\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - What to name the tag\n * @param {string} [args.object = 'HEAD'] - What oid the tag refers to. (Will resolve to oid if value is a ref.) By default, the commit object which is referred by the current `HEAD` is used.\n * @param {boolean} [args.force = false] - Instead of throwing an error if a tag named `ref` already exists, overwrite the existing tag.\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.tag({ fs, dir: '/tutorial', ref: 'test-tag' })\n * console.log('done')\n *\n */\nasync function tag({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  object,\n  force = false\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    const fs = new FileSystem(_fs);\n    if (ref === undefined) {\n      throw new MissingParameterError('ref');\n    }\n    ref = ref.startsWith('refs/tags/') ? ref : `refs/tags/${ref}`;\n\n    // Resolve passed object\n    const value = await GitRefManager.resolve({\n      fs,\n      gitdir,\n      ref: object || 'HEAD'\n    });\n    if (!force && (await GitRefManager.exists({\n      fs,\n      gitdir,\n      ref\n    }))) {\n      throw new AlreadyExistsError('tag', ref);\n    }\n    await GitRefManager.writeRef({\n      fs,\n      gitdir,\n      ref,\n      value\n    });\n  } catch (err) {\n    err.caller = 'git.tag';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Register file contents in the working tree or object database to the git index (aka staging area).\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.filepath - File to act upon.\n * @param {string} [args.oid] - OID of the object in the object database to add to the index with the specified filepath.\n * @param {number} [args.mode = 100644] - The file mode to add the file to the index.\n * @param {boolean} [args.add] - Adds the specified file to the index if it does not yet exist in the index.\n * @param {boolean} [args.remove] - Remove the specified file from the index if it does not exist in the workspace anymore.\n * @param {boolean} [args.force] - Remove the specified file from the index, even if it still exists in the workspace.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<string | void>} Resolves successfully with the SHA-1 object id of the object written or updated in the index, or nothing if the file was removed.\n *\n * @example\n * await git.updateIndex({\n *   fs,\n *   dir: '/tutorial',\n *   filepath: 'readme.md'\n * })\n *\n * @example\n * // Manually create a blob in the object database.\n * let oid = await git.writeBlob({\n *   fs,\n *   dir: '/tutorial',\n *   blob: new Uint8Array([])\n * })\n *\n * // Write the object in the object database to the index.\n * await git.updateIndex({\n *   fs,\n *   dir: '/tutorial',\n *   add: true,\n *   filepath: 'readme.md',\n *   oid\n * })\n */\nasync function updateIndex({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  cache = {},\n  filepath,\n  oid,\n  mode,\n  add,\n  remove,\n  force\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('filepath', filepath);\n    const fs = new FileSystem(_fs);\n    if (remove) {\n      return await GitIndexManager.acquire({\n        fs,\n        gitdir,\n        cache\n      }, async function (index) {\n        let fileStats;\n        if (!force) {\n          // Check if the file is still present in the working directory\n          fileStats = await fs.lstat(join(dir, filepath));\n          if (fileStats) {\n            if (fileStats.isDirectory()) {\n              // Removing directories should not work\n              throw new InvalidFilepathError('directory');\n            }\n\n            // Do nothing if we don't force and the file still exists in the workdir\n            return;\n          }\n        }\n\n        // Directories are not allowed, so we make sure the provided filepath exists in the index\n        if (index.has({\n          filepath\n        })) {\n          index.delete({\n            filepath\n          });\n        }\n      });\n    }\n\n    // Test if it is a file and exists on disk if `remove` is not provided, only of no oid is provided\n    let fileStats;\n    if (!oid) {\n      fileStats = await fs.lstat(join(dir, filepath));\n      if (!fileStats) {\n        throw new NotFoundError(`file at \"${filepath}\" on disk and \"remove\" not set`);\n      }\n      if (fileStats.isDirectory()) {\n        throw new InvalidFilepathError('directory');\n      }\n    }\n    return await GitIndexManager.acquire({\n      fs,\n      gitdir,\n      cache\n    }, async function (index) {\n      if (!add && !index.has({\n        filepath\n      })) {\n        // If the index does not contain the filepath yet and `add` is not set, we should throw\n        throw new NotFoundError(`file at \"${filepath}\" in index and \"add\" not set`);\n      }\n\n      // By default we use 0 for the stats of the index file\n      let stats = {\n        ctime: new Date(0),\n        mtime: new Date(0),\n        dev: 0,\n        ino: 0,\n        mode,\n        uid: 0,\n        gid: 0,\n        size: 0\n      };\n      if (!oid) {\n        stats = fileStats;\n\n        // Write the file to the object database\n        const object = stats.isSymbolicLink() ? await fs.readlink(join(dir, filepath)) : await fs.read(join(dir, filepath));\n        oid = await _writeObject({\n          fs,\n          gitdir,\n          type: 'blob',\n          format: 'content',\n          object\n        });\n      }\n      index.insert({\n        filepath,\n        oid: oid,\n        stats\n      });\n      return oid;\n    });\n  } catch (err) {\n    err.caller = 'git.updateIndex';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Return the version number of isomorphic-git\n *\n * I don't know why you might need this. I added it just so I could check that I was getting\n * the correct version of the library and not a cached version.\n *\n * @returns {string} the version string taken from package.json at publication time\n *\n * @example\n * console.log(git.version())\n *\n */\nfunction version() {\n  try {\n    return pkg.version;\n  } catch (err) {\n    err.caller = 'git.version';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * @callback WalkerMap\n * @param {string} filename\n * @param {Array<WalkerEntry | null>} entries\n * @returns {Promise<any>}\n */\n\n/**\n * @callback WalkerReduce\n * @param {any} parent\n * @param {any[]} children\n * @returns {Promise<any>}\n */\n\n/**\n * @callback WalkerIterateCallback\n * @param {WalkerEntry[]} entries\n * @returns {Promise<any[]>}\n */\n\n/**\n * @callback WalkerIterate\n * @param {WalkerIterateCallback} walk\n * @param {IterableIterator<WalkerEntry[]>} children\n * @returns {Promise<any[]>}\n */\n\n/**\n * A powerful recursive tree-walking utility.\n *\n * The `walk` API simplifies gathering detailed information about a tree or comparing all the filepaths in two or more trees.\n * Trees can be git commits, the working directory, or the or git index (staging area).\n * As long as a file or directory is present in at least one of the trees, it will be traversed.\n * Entries are traversed in alphabetical order.\n *\n * The arguments to `walk` are the `trees` you want to traverse, and 3 optional transform functions:\n *  `map`, `reduce`, and `iterate`.\n *\n * ## `TREE`, `WORKDIR`, and `STAGE`\n *\n * Tree walkers are represented by three separate functions that can be imported:\n *\n * ```js\n * import { TREE, WORKDIR, STAGE } from 'isomorphic-git'\n * ```\n *\n * These functions return opaque handles called `Walker`s.\n * The only thing that `Walker` objects are good for is passing into `walk`.\n * Here are the three `Walker`s passed into `walk` by the `statusMatrix` command for example:\n *\n * ```js\n * let ref = 'HEAD'\n *\n * let trees = [TREE({ ref }), WORKDIR(), STAGE()]\n * ```\n *\n * For the arguments, see the doc pages for [TREE](./TREE.md), [WORKDIR](./WORKDIR.md), and [STAGE](./STAGE.md).\n *\n * `map`, `reduce`, and `iterate` allow you control the recursive walk by pruning and transforming `WalkerEntry`s into the desired result.\n *\n * ## WalkerEntry\n *\n * {@link WalkerEntry typedef}\n *\n * `map` receives an array of `WalkerEntry[]` as its main argument, one `WalkerEntry` for each `Walker` in the `trees` argument.\n * The methods are memoized per `WalkerEntry` so calling them multiple times in a `map` function does not adversely impact performance.\n * By only computing these values if needed, you build can build lean, mean, efficient walking machines.\n *\n * ### WalkerEntry#type()\n *\n * Returns the kind as a string. This is normally either `tree` or `blob`.\n *\n * `TREE`, `STAGE`, and `WORKDIR` walkers all return a string.\n *\n * Possible values:\n *\n * - `'tree'` directory\n * - `'blob'` file\n * - `'special'` used by `WORKDIR` to represent irregular files like sockets and FIFOs\n * - `'commit'` used by `TREE` to represent submodules\n *\n * ```js\n * await entry.type()\n * ```\n *\n * ### WalkerEntry#mode()\n *\n * Returns the file mode as a number. Use this to distinguish between regular files, symlinks, and executable files.\n *\n * `TREE`, `STAGE`, and `WORKDIR` walkers all return a number for all `type`s of entries.\n *\n * It has been normalized to one of the 4 values that are allowed in git commits:\n *\n * - `0o40000` directory\n * - `0o100644` file\n * - `0o100755` file (executable)\n * - `0o120000` symlink\n *\n * Tip: to make modes more readable, you can print them to octal using `.toString(8)`.\n *\n * ```js\n * await entry.mode()\n * ```\n *\n * ### WalkerEntry#oid()\n *\n * Returns the SHA-1 object id for blobs and trees.\n *\n * `TREE` walkers return a string for `blob` and `tree` entries.\n *\n * `STAGE` and `WORKDIR` walkers return a string for `blob` entries and `undefined` for `tree` entries.\n *\n * ```js\n * await entry.oid()\n * ```\n *\n * ### WalkerEntry#content()\n *\n * Returns the file contents as a Buffer.\n *\n * `TREE` and `WORKDIR` walkers return a Buffer for `blob` entries and `undefined` for `tree` entries.\n *\n * `STAGE` walkers always return `undefined` since the file contents are never stored in the stage.\n *\n * ```js\n * await entry.content()\n * ```\n *\n * ### WalkerEntry#stat()\n *\n * Returns a normalized subset of filesystem Stat data.\n *\n * `WORKDIR` walkers return a `Stat` for `blob` and `tree` entries.\n *\n * `STAGE` walkers return a `Stat` for `blob` entries and `undefined` for `tree` entries.\n *\n * `TREE` walkers return `undefined` for all entry types.\n *\n * ```js\n * await entry.stat()\n * ```\n *\n * {@link Stat typedef}\n *\n * ## map(string, Array<WalkerEntry|null>) => Promise<any>\n *\n * {@link WalkerMap typedef}\n *\n * This is the function that is called once per entry BEFORE visiting the children of that node.\n *\n * If you return `null` for a `tree` entry, then none of the children of that `tree` entry will be walked.\n *\n * This is a good place for query logic, such as examining the contents of a file.\n * Ultimately, compare all the entries and return any values you are interested in.\n * If you do not return a value (or return undefined) that entry will be filtered from the results.\n *\n * Example 1: Find all the files containing the word 'foo'.\n * ```js\n * async function map(filepath, [head, workdir]) {\n *   let content = (await workdir.content()).toString('utf8')\n *   if (content.contains('foo')) {\n *     return {\n *       filepath,\n *       content\n *     }\n *   }\n * }\n * ```\n *\n * Example 2: Return the difference between the working directory and the HEAD commit\n * ```js\n * const map = async (filepath, [head, workdir]) => {\n *   return {\n *     filepath,\n *     oid: await head?.oid(),\n *     diff: diff(\n *       (await head?.content())?.toString('utf8') || '',\n *       (await workdir?.content())?.toString('utf8') || ''\n *     )\n *   }\n * }\n * ```\n *\n * Example 3:\n * ```js\n * let path = require('path')\n * // Only examine files in the directory `cwd`\n * let cwd = 'src/app'\n * async function map (filepath, [head, workdir, stage]) {\n *   if (\n *     // don't skip the root directory\n *     head.fullpath !== '.' &&\n *     // return true for 'src' and 'src/app'\n *     !cwd.startsWith(filepath) &&\n *     // return true for 'src/app/*'\n *     path.dirname(filepath) !== cwd\n *   ) {\n *     return null\n *   } else {\n *     return filepath\n *   }\n * }\n * ```\n *\n * ## reduce(parent, children)\n *\n * {@link WalkerReduce typedef}\n *\n * This is the function that is called once per entry AFTER visiting the children of that node.\n *\n * Default: `async (parent, children) => parent === undefined ? children.flat() : [parent, children].flat()`\n *\n * The default implementation of this function returns all directories and children in a giant flat array.\n * You can define a different accumulation method though.\n *\n * Example: Return a hierarchical structure\n * ```js\n * async function reduce (parent, children) {\n *   return Object.assign(parent, { children })\n * }\n * ```\n *\n * ## iterate(walk, children)\n *\n * {@link WalkerIterate typedef}\n *\n * {@link WalkerIterateCallback typedef}\n *\n * Default: `(walk, children) => Promise.all([...children].map(walk))`\n *\n * The default implementation recurses all children concurrently using Promise.all.\n * However you could use a custom function to traverse children serially or use a global queue to throttle recursion.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {Walker[]} args.trees - The trees you want to traverse\n * @param {WalkerMap} [args.map] - Transform `WalkerEntry`s into a result form\n * @param {WalkerReduce} [args.reduce] - Control how mapped entries are combined with their parent result\n * @param {WalkerIterate} [args.iterate] - Fine-tune how entries within a tree are iterated over\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<any>} The finished tree-walking result\n */\nasync function walk({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  trees,\n  map,\n  reduce,\n  iterate,\n  cache = {}\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('trees', trees);\n    return await _walk({\n      fs: new FileSystem(fs),\n      cache,\n      dir,\n      gitdir,\n      trees,\n      map,\n      reduce,\n      iterate\n    });\n  } catch (err) {\n    err.caller = 'git.walk';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Write a blob object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {Uint8Array} args.blob - The blob object to write\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object\n *\n * @example\n * // Manually create a blob.\n * let oid = await git.writeBlob({\n *   fs,\n *   dir: '/tutorial',\n *   blob: new Uint8Array([])\n * })\n *\n * console.log('oid', oid) // should be 'e69de29bb2d1d6434b8b29ae775ad8c2e48c5391'\n *\n */\nasync function writeBlob({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  blob\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('blob', blob);\n    return await _writeObject({\n      fs: new FileSystem(fs),\n      gitdir,\n      type: 'blob',\n      object: blob,\n      format: 'content'\n    });\n  } catch (err) {\n    err.caller = 'git.writeBlob';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {CommitObject} args.commit\n *\n * @returns {Promise<string>}\n * @see CommitObject\n *\n */\nasync function _writeCommit({\n  fs,\n  gitdir,\n  commit\n}) {\n  // Convert object to buffer\n  const object = GitCommit.from(commit).toObject();\n  const oid = await _writeObject({\n    fs,\n    gitdir,\n    type: 'commit',\n    object,\n    format: 'content'\n  });\n  return oid;\n}\n\n// @ts-check\n\n/**\n * Write a commit object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {CommitObject} args.commit - The object to write\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object\n * @see CommitObject\n *\n */\nasync function writeCommit({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  commit\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('commit', commit);\n    return await _writeCommit({\n      fs: new FileSystem(fs),\n      gitdir,\n      commit\n    });\n  } catch (err) {\n    err.caller = 'git.writeCommit';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Write a git object directly\n *\n * `format` can have the following values:\n *\n * | param      | description                                                                                                                                                      |\n * | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n * | 'deflated' | Treat `object` as the raw deflate-compressed buffer for an object, meaning can be written to `.git/objects/**` as-is.                                           |\n * | 'wrapped'  | Treat `object` as the inflated object buffer wrapped in the git object header. This is the raw buffer used when calculating the SHA-1 object id of a git object. |\n * | 'content'  | Treat `object` as the object buffer without the git header.                                                                                                      |\n * | 'parsed'   | Treat `object` as a parsed representation of the object.                                                                                                         |\n *\n * If `format` is `'parsed'`, then `object` must match one of the schemas for `CommitObject`, `TreeObject`, `TagObject`, or a `string` (for blobs).\n *\n * {@link CommitObject typedef}\n *\n * {@link TreeObject typedef}\n *\n * {@link TagObject typedef}\n *\n * If `format` is `'content'`, `'wrapped'`, or `'deflated'`, `object` should be a `Uint8Array`.\n *\n * @deprecated\n * > This command is overly complicated.\n * >\n * > If you know the type of object you are writing, use [`writeBlob`](./writeBlob.md), [`writeCommit`](./writeCommit.md), [`writeTag`](./writeTag.md), or [`writeTree`](./writeTree.md).\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string | Uint8Array | CommitObject | TreeObject | TagObject} args.object - The object to write.\n * @param {'blob'|'tree'|'commit'|'tag'} [args.type] - The kind of object to write.\n * @param {'deflated' | 'wrapped' | 'content' | 'parsed'} [args.format = 'parsed'] - What format the object is in. The possible choices are listed below.\n * @param {string} [args.oid] - If `format` is `'deflated'` then this param is required. Otherwise it is calculated.\n * @param {string} [args.encoding] - If `type` is `'blob'` then `object` will be converted to a Uint8Array using `encoding`.\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object.\n *\n * @example\n * // Manually create an annotated tag.\n * let sha = await git.resolveRef({ fs, dir: '/tutorial', ref: 'HEAD' })\n * console.log('commit', sha)\n *\n * let oid = await git.writeObject({\n *   fs,\n *   dir: '/tutorial',\n *   type: 'tag',\n *   object: {\n *     object: sha,\n *     type: 'commit',\n *     tag: 'my-tag',\n *     tagger: {\n *       name: 'your name',\n *       email: 'email@example.com',\n *       timestamp: Math.floor(Date.now()/1000),\n *       timezoneOffset: new Date().getTimezoneOffset()\n *     },\n *     message: 'Optional message'\n *   }\n * })\n *\n * console.log('tag', oid)\n *\n */\nasync function writeObject({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  type,\n  object,\n  format = 'parsed',\n  oid,\n  encoding = undefined\n}) {\n  try {\n    const fs = new FileSystem(_fs);\n    // Convert object to buffer\n    if (format === 'parsed') {\n      switch (type) {\n        case 'commit':\n          object = GitCommit.from(object).toObject();\n          break;\n        case 'tree':\n          object = GitTree.from(object).toObject();\n          break;\n        case 'blob':\n          object = Buffer.from(object, encoding);\n          break;\n        case 'tag':\n          object = GitAnnotatedTag.from(object).toObject();\n          break;\n        default:\n          throw new ObjectTypeError(oid || '', type, 'blob|commit|tag|tree');\n      }\n      // GitObjectManager does not know how to serialize content, so we tweak that parameter before passing it.\n      format = 'content';\n    }\n    oid = await _writeObject({\n      fs,\n      gitdir,\n      type,\n      object,\n      oid,\n      format\n    });\n    return oid;\n  } catch (err) {\n    err.caller = 'git.writeObject';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Write a ref which refers to the specified SHA-1 object id, or a symbolic ref which refers to the specified ref.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - The name of the ref to write\n * @param {string} args.value - When `symbolic` is false, a ref or an SHA-1 object id. When true, a ref starting with `refs/`.\n * @param {boolean} [args.force = false] - Instead of throwing an error if a ref named `ref` already exists, overwrite the existing ref.\n * @param {boolean} [args.symbolic = false] - Whether the ref is symbolic or not.\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.writeRef({\n *   fs,\n *   dir: '/tutorial',\n *   ref: 'refs/heads/another-branch',\n *   value: 'HEAD'\n * })\n * await git.writeRef({\n *   fs,\n *   dir: '/tutorial',\n *   ref: 'HEAD',\n *   value: 'refs/heads/another-branch',\n *   force: true,\n *   symbolic: true\n * })\n * console.log('done')\n *\n */\nasync function writeRef({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  value,\n  force = false,\n  symbolic = false\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    assertParameter('value', value);\n    const fs = new FileSystem(_fs);\n    if (ref !== cleanGitRef.clean(ref)) {\n      throw new InvalidRefNameError(ref, cleanGitRef.clean(ref));\n    }\n    if (!force && (await GitRefManager.exists({\n      fs,\n      gitdir,\n      ref\n    }))) {\n      throw new AlreadyExistsError('ref', ref);\n    }\n    if (symbolic) {\n      await GitRefManager.writeSymbolicRef({\n        fs,\n        gitdir,\n        ref,\n        value\n      });\n    } else {\n      value = await GitRefManager.resolve({\n        fs,\n        gitdir,\n        ref: value\n      });\n      await GitRefManager.writeRef({\n        fs,\n        gitdir,\n        ref,\n        value\n      });\n    }\n  } catch (err) {\n    err.caller = 'git.writeRef';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {TagObject} args.tag\n *\n * @returns {Promise<string>}\n */\nasync function _writeTag({\n  fs,\n  gitdir,\n  tag\n}) {\n  // Convert object to buffer\n  const object = GitAnnotatedTag.from(tag).toObject();\n  const oid = await _writeObject({\n    fs,\n    gitdir,\n    type: 'tag',\n    object,\n    format: 'content'\n  });\n  return oid;\n}\n\n// @ts-check\n\n/**\n * Write an annotated tag object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {TagObject} args.tag - The object to write\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object\n * @see TagObject\n *\n * @example\n * // Manually create an annotated tag.\n * let sha = await git.resolveRef({ fs, dir: '/tutorial', ref: 'HEAD' })\n * console.log('commit', sha)\n *\n * let oid = await git.writeTag({\n *   fs,\n *   dir: '/tutorial',\n *   tag: {\n *     object: sha,\n *     type: 'commit',\n *     tag: 'my-tag',\n *     tagger: {\n *       name: 'your name',\n *       email: 'email@example.com',\n *       timestamp: Math.floor(Date.now()/1000),\n *       timezoneOffset: new Date().getTimezoneOffset()\n *     },\n *     message: 'Optional message'\n *   }\n * })\n *\n * console.log('tag', oid)\n *\n */\nasync function writeTag({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  tag\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('tag', tag);\n    return await _writeTag({\n      fs: new FileSystem(fs),\n      gitdir,\n      tag\n    });\n  } catch (err) {\n    err.caller = 'git.writeTag';\n    throw err;\n  }\n}\n\n// @ts-check\n\n/**\n * Write a tree object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {TreeObject} args.tree - The object to write\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object.\n * @see TreeObject\n * @see TreeEntry\n *\n */\nasync function writeTree({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  tree\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('tree', tree);\n    return await _writeTree({\n      fs: new FileSystem(fs),\n      gitdir,\n      tree\n    });\n  } catch (err) {\n    err.caller = 'git.writeTree';\n    throw err;\n  }\n}\n\n// default export\nvar index = {\n  Errors,\n  STAGE,\n  TREE,\n  WORKDIR,\n  add,\n  abortMerge,\n  addNote,\n  addRemote,\n  annotatedTag,\n  branch,\n  checkout,\n  clone,\n  commit,\n  getConfig,\n  getConfigAll,\n  setConfig,\n  currentBranch,\n  deleteBranch,\n  deleteRef,\n  deleteRemote,\n  deleteTag,\n  expandOid,\n  expandRef,\n  fastForward,\n  fetch,\n  findMergeBase,\n  findRoot,\n  getRemoteInfo,\n  getRemoteInfo2,\n  hashBlob,\n  indexPack,\n  init,\n  isDescendent,\n  isIgnored,\n  listBranches,\n  listFiles,\n  listNotes,\n  listRemotes,\n  listServerRefs,\n  listTags,\n  log,\n  merge,\n  packObjects,\n  pull,\n  push,\n  readBlob,\n  readCommit,\n  readNote,\n  readObject,\n  readTag,\n  readTree,\n  remove,\n  removeNote,\n  renameBranch,\n  resetIndex,\n  updateIndex,\n  resolveRef,\n  status,\n  statusMatrix,\n  tag,\n  version,\n  walk,\n  writeBlob,\n  writeCommit,\n  writeObject,\n  writeRef,\n  writeTag,\n  writeTree\n};\nexport default index;\nexport { Errors, STAGE, TREE, WORKDIR, abortMerge, add, addNote, addRemote, annotatedTag, branch, checkout, clone, commit, currentBranch, deleteBranch, deleteRef, deleteRemote, deleteTag, expandOid, expandRef, fastForward, fetch, findMergeBase, findRoot, getConfig, getConfigAll, getRemoteInfo, getRemoteInfo2, hashBlob, indexPack, init, isDescendent, isIgnored, listBranches, listFiles, listNotes, listRemotes, listServerRefs, listTags, log, merge, packObjects, pull, push, readBlob, readCommit, readNote, readObject, readTag, readTree, remove, removeNote, renameBranch, resetIndex, resolveRef, setConfig, status, statusMatrix, tag, updateIndex, version, walk, writeBlob, writeCommit, writeObject, writeRef, writeTag, writeTree };","map":{"version":3,"names":["AsyncLock","Hash","crc32","pako","pify","ignore","cleanGitRef","diff3Merge","BaseError","Error","constructor","message","caller","toJSON","code","data","stack","fromJSON","json","e","isIsomorphicGitError","UnmergedPathsError","filepaths","toString","name","InternalError","UnsafeFilepathError","filepath","BufferCursor","buffer","_start","eof","length","tell","seek","n","slice","r","enc","write","value","copy","source","start","end","readUInt8","writeUInt8","readUInt16BE","writeUInt16BE","readUInt32BE","writeUInt32BE","compareStrings","a","b","comparePath","path","normalizeMode","mode","type","permissions","MAX_UINT32","SecondsNanoseconds","givenSeconds","givenNanoseconds","milliseconds","date","undefined","valueOf","seconds","Math","floor","nanoseconds","normalizeStats","ctimeSeconds","ctimeNanoseconds","ctimeMs","ctime","mtimeSeconds","mtimeNanoseconds","mtimeMs","mtime","dev","ino","uid","gid","size","toHex","hex","byte","Uint8Array","supportsSubtleSHA1","shasum","testSubtleSHA1","subtleSHA1","shasumSync","update","digest","hash","crypto","subtle","_","parseCacheEntryFlags","bits","assumeValid","Boolean","extended","stage","nameLength","renderCacheEntryFlags","entry","flags","min","Buffer","from","GitIndex","entries","unmergedPaths","_dirty","_unmergedPaths","Set","_entries","Map","_addEntry","stages","set","delete","existingEntry","get","add","isBuffer","fromBuffer","index","reader","magic","shaComputed","shaClaimed","version","numEntries","i","oid","pathlength","indexOf","includes","padding","tmp","values","sort","entriesMap","entriesFlat","flatMap","filter","x","Symbol","iterator","insert","stats","bfilepath","has","key","keys","startsWith","clear","render","map","join","_entryToBuffer","bpath","ceil","written","alloc","writer","stat","toObject","header","entryBuffers","push","Promise","all","body","concat","main","sum","compareStats","s","staleness","lock","IndexCache","createCache","updateCachedIndexFile","fs","cache","lstat","rawIndexFile","read","isIndexStale","savedStats","currStats","GitIndexManager","acquire","gitdir","allowUnmerged","closure","maxPending","Infinity","result","basename","last","max","lastIndexOf","dirname","flatFileListToDirectoryStructure","files","inodes","mkdir","dir","fullpath","metadata","children","parent","mkfile","file","mode2type","GitWalkerIndex","treePromise","walker","ConstructEntry","StageEntry","_fullpath","_type","_mode","_stat","_oid","content","readdir","tree","inode","names","_entry","GitWalkSymbol","STAGE","o","Object","create","defineProperty","freeze","NotFoundError","what","ObjectTypeError","actual","expected","InvalidOidError","NoRefspecError","remote","GitPackedRefs","text","refs","parsedConfig","trim","split","line","test","comment","ref","peeled","GitRefSpec","remotePath","localPath","force","matchPrefix","assign","refspec","forceMatch","remoteGlobMatch","localGlobMatch","match","remoteIsGlob","localIsGlob","translate","remoteBranch","replace","reverseTranslate","localBranch","GitRefSpecSet","rules","refspecs","rule","remoteRefs","remoteRef","localRef","translateOne","localNamespaces","compareRefNames","_a","_b","endsWith","normalizePath","parts","num","val","toLowerCase","parseInt","bool","schema","core","filemode","bare","logallrefupdates","symlinks","ignorecase","bigFileThreshold","SECTION_LINE_REGEX","SECTION_REGEX","VARIABLE_LINE_REGEX","VARIABLE_NAME_REGEX","VARIABLE_VALUE_COMMENT_REGEX","extractSectionLine","matches","exec","section","subsection","extractVariableLine","rawValue","valueWithoutComments","removeComments","valueWithoutQuotes","removeQuotes","commentMatches","valueWithoutComment","hasOddNumberOfQuotes","numberOfQuotes","reduce","newText","c","idx","isQuote","isEscapeForQuote","lower","getPath","normalizePath$1","pathSegments","shift","pop","sectionPath","findLastIndex","array","callback","lastIndex","item","GitConfig","trimmedLine","extractedSection","isSection","extractedVariable","isVariable","getall","normalizedPath","allValues","config","fn","getSubsections","deleteSection","append","configIndex","splice","modifiedConfig","modified","sectionIndex","findIndex","newConfig","newSection","GitConfigManager","encoding","save","refpaths","GIT_FILES","GitRefManager","updateRemoteRefs","symrefs","tags","prune","pruneTags","unshift","actualRefsToWrite","listRefs","deleteRefs","tag","serverRef","exists","refTranslations","translatedRef","symrefTranslations","symtarget","pruned","writeRef","writeSymbolicRef","deleteRef","rm","packed","beforeSize","resolve","depth","sha","packedMap","packedRefs","allpaths","p","expand","err","expandAgainstMap","resolveAgainstMap","fullref","readdirDeep","listBranches","listTags","compareTreeEntryPath","appendSlashIfDir","mode2type$1","parseBuffer","cursor","space","nullchar","limitModeToAllowed","nudgeIntoShape","GitTree","Array","isArray","GitObject","wrap","object","byteLength","unwrap","actualLength","readObjectLoose","format","applyDelta","delta","sourceSize","readVarIntLE","targetSize","target","firstOp","readOp","readCompactLE","COPY","OFFS","SIZE","offset","fromValue","queue","next","done","return","asyncIterator","getIterator","iterable","StreamReader","stream","undoCursor","started","_ended","_discardedBytes","_init","_loadnext","_moveCursor","chunk","_trim","_accumulate","skip","undo","_next","buffers","lengthBuffers","nextbuffer","acc","listpack","onData","PACK","numObjects","ofs","reference","parseHeader","inflator","Inflate","msg","strm","avail_in","bytes","buf","supportsDecompressionStream","inflate","testDecompressionStream","browserInflate","ds","DecompressionStream","d","Blob","pipeThrough","Response","arrayBuffer","decodeVarInt","multibyte","lastSeven","otherVarIntDecode","startWith","GitPackIndex","stuff","offsetCache","fromIdx","getExternalRefDelta","hashes","offsets","packfileSha","crcs","fromPack","pack","onProgress","listpackTypes","offsetToObject","totalObjectCount","lastPercent","percent","phase","loaded","total","offsetArray","Number","crc","count","objectsByDepth","readDepth","externalReadDepth","readSlice","toBuffer","str","fanoutBuffer","crcsBuffer","offsetsBuffer","totalBuffer","shaBuffer","load","unload","types","raw","btype","lastFour","base","baseOffset","PackfileCache","loadPackIndex","filename","emitter","emitterPrefix","readPackIndex","readObjectPacked","list","indexFile","error","packFile","_readObject","AlreadyExistsError","noun","where","canForce","AmbiguousError","nouns","short","CheckoutConflictError","CommitNotFetchedError","EmptyServerResponseError","FastForwardError","GitPushError","prettyDetails","HttpError","statusCode","statusMessage","response","InvalidFilepathError","reason","InvalidRefNameError","suggestion","MaxDepthError","MergeNotSupportedError","MergeConflictError","bothModified","deleteByUs","deleteByTheirs","MissingNameError","role","MissingParameterError","parameter","MultipleGitError","errors","ParseError","PushRejectedError","RemoteCapabilityError","capability","SmartHttpError","preview","UnknownTransportError","url","transport","UrlParseError","UserCanceledError","IndexResetError","Errors","__proto__","formatAuthor","email","timestamp","timezoneOffset","formatTimezoneOffset","minutes","sign","simpleSign","negateExceptForZero","abs","hours","strHours","String","strMinutes","is","normalizeNewlines","parseAuthor","author","parseTimezoneOffset","negateExceptForZero$1","GitAnnotatedTag","_tag","obj","tagger","gpgsig","justHeaders","withoutSignature","parse","headers","hs","h","committer","signature","payload","secretKey","signedTag","indent","outdent","GitCommit","commit","_commit","fromPayloadSignature","justMessage","parseHeaders","renderHeaders","isolateSignature","signedCommit","resolveTree","GitWalkerRepo","mapPromise","TreeEntry","_content","JSON","stringify","TREE","GitWalkerFs","WorkdirEntry","isDirectory","isFile","isSymbolicLink","_actualSize","WORKDIR","arrayRange","flat","prototype","RunningMinimum","consider","reset","unionOfIterators","sets","minimum","heads","numsets","_walk","trees","flatten","iterate","walk","walkers","proxy","root","fill","range","unionWalkerFromReaddir","subdirs","iterators","find","walkedChildren","rmRecursive","subpath","then","rmdir","isPromiseLike","isObject","isFunction","catch","isPromiseFs","targetFs","readFile","commands","bindFs","command","bind","_rm","FileSystem","_original_unwrapped_fs","promises","getOwnPropertyDescriptor","enumerable","options","console","log","_readFile","contents","_writeFile","_selfCall","_mkdir","_unlink","opts","recursive","_rmdir","_readdir","subdir","res","f","_lstat","readlink","link","_readlink","writelink","_symlink","assertParameter","abortMerge","_fs","results","head","workdir","staged","unmerged","unmodified","TextDecoder","decode","GitIgnoreManager","isIgnored","excludes","excludesFile","pairs","gitignore","pieces","folder","ignoredStatus","ign","parentdir","ignores","unignored","ignored","writeObjectLoose","supportsCompressionStream","deflate","testCompressionStream","browserDeflate","cs","CompressionStream","_writeObject","dryRun","posixifyPathBuffer","parallel","addToIndex","currentFilepath","child","settledPromises","allSettled","rejectedPromises","settle","status","fulfilledPromises","onSign","signingKey","noUpdateBranch","constructTree","comm","resolveFilepath","pathArray","_resolveFilepath","_readTree","treeOid","_writeTree","_addNote","note","noteOid","commitOid","_getConfig","normalizeAuthorObject","Date","now","getTimezoneOffset","normalizeCommitterObject","addNote","_author","_committer","_addRemote","clean","remoteNames","addRemote","_annotatedTag","tagObject","annotatedTag","_tagger","_branch","checkout","exist","branch","worthWalking","_checkout","noCheckout","noUpdateHead","track","ops","analyze","conflicts","method","chmod","fullRef","some","_ref","abbreviateRx","RegExp","abbreviateRef","_currentBranch","fullname","translateSSHtoHTTP","calculateBasicAuthHeader","username","password","forAwait","cb","iter","collect","nextIndex","extractAuthFromUrl","userpass","auth","padHex","repeat","GitPktLine","flush","delim","encode","hexlength","streamReader","parseCapabilitiesV2","capabilities2","protocolVersion","parseRefsAdResponse","service","capabilities","lineOne","lineTwo","firstRef","capabilitiesLine","splitAndAssert","cap","m","sep","corsProxify","corsProxy","updateHeaders","Authorization","stringifyBody","GitRemoteHTTP","discover","http","onAuth","onAuthSuccess","onAuthFailure","_origUrl","proxifiedURL","tryAgain","providedAuthBefore","request","getAuth","cancel","remoteHTTP","connect","urlAuth","accept","parseRemoteUrl","address","GitRemoteManager","getRemoteHelperFor","remoteHelpers","lock$1","GitShallowManager","oids","hasObjectLoose","hasObjectPacked","hasObject","emptyPackfile","pheader","obCount","filterCapabilities","server","client","serverNames","pkg","agent","FIFO","_queue","_waiting","destroy","findSplit","splitLines","input","output","GitSideBand","demux","packetlines","packfile","progress","nextBit","parseUploadPackResponse","shallows","unshallows","acks","nak","reject","writeUploadPackRequest","wants","haves","since","exclude","packstream","firstLineCapabilities","_fetch","onMessage","_remoteRef","_remote","_url","relative","singleBranch","defaultBranch","fetchHead","fetchHeadDescription","haveRefs","packbuffer","hasParents","haveAllParents","every","bail","realRef","HEAD","FETCH_HEAD","description","lines","folders","_clone","noTags","maxRetries","clone","currentBranch","_deleteBranch","currentRef","deleteBranch","_deleteRemote","deleteRemote","_deleteTag","deleteTag","expandOidLoose","prefix","objectsSuffixes","suffix","expandOidPacked","_expandOid","packedOids","packedOid","expandOid","expandRef","_findMergeBase","visits","passes","newheads","LINEBREAKS","mergeFile","branches","ourName","theirName","baseContent","ourContent","theirContent","ours","theirs","markerSize","mergedText","cleanMerge","ok","conflict","mergeTree","ourOid","baseOid","theirOid","baseName","abortOnConflict","mergeDriver","ourTree","baseTree","theirTree","unmergedFiles","ourChange","theirChange","mergeBlobs","mergeResult","_merge","fastForward","fastForwardOnly","baseOids","alreadyMerged","mergeCommit","_pull","thisWillNotBeUsed","fetch","findMergeBase","_findRoot","findRoot","getConfig","_getConfigAll","getConfigAll","getRemoteInfo","forPush","part","symref","formatInfoRefs","peelTags","_key","getRemoteInfo2","hashObject","hashBlob","_object","_indexPack","indexPack","init","_isDescendent","ancestor","visited","searchdepth","isDescendent","_listFiles","filenames","accumulateFilesFromOid","listFiles","_listNotes","notes","listNotes","_listRemotes","remotes","listRemotes","parseListRefsResponse","attrs","attr","writeListRefsRequest","listServerRefs","resolveCommit","_readCommit","compareAge","EMPTY_OID","resolveFileIdInTree","fileId","_resolveFileId","parentPath","walks","_log","follow","sinceTimestamp","commits","shallowCommits","tips","lastFileOid","lastCommit","isOk","endCommit","vFileOid","found","lastFound","merge","blob","ofs_delta","ref_delta","_pack","outputStream","buff","writeObject","stype","_packObjects","packObjects","pull","listCommitsAndTags","finish","startingSet","finishingSet","parents","listObjects","parseReceivePackResponse","refAndMessage","writeReceivePackRequest","triplets","capsFirstLine","trip","oldoid","_push","_delete","httpRemote","fullRemoteRef","thinPack","objects","skipObjects","mergebase","packstream1","packstream2","k","v","resolveBlob","_readBlob","readBlob","readCommit","_readNote","readNote","readObject","_format","_readTag","readTag","readTree","remove","_removeNote","removeNote","_renameBranch","oldref","fulloldref","fullnewref","newexist","fullCurrentBranchRef","isCurrentBranch","renameBranch","hashObject$1","resetIndex","workdirOid","resolveRef","setConfig","headTree","getHeadTree","getOidAtPath","indexEntry","H","I","W","getWorkdirOid","statusMatrix","shouldIgnore","headType","workdirType","stageType","isBlob","headOid","stageOid","updateIndex","fileStats","writeBlob","_writeCommit","writeCommit","symbolic","_writeTag","writeTag","writeTree"],"sources":["C:/Users/HarshitSrivastava/Desktop/Practice/React/Project2/my-app/node_modules/isomorphic-git/index.js"],"sourcesContent":["import AsyncLock from 'async-lock';\nimport Hash from 'sha.js/sha1.js';\nimport crc32 from 'crc-32';\nimport pako from 'pako';\nimport pify from 'pify';\nimport ignore from 'ignore';\nimport cleanGitRef from 'clean-git-ref';\nimport diff3Merge from 'diff3';\n\n/**\n * @typedef {Object} GitProgressEvent\n * @property {string} phase\n * @property {number} loaded\n * @property {number} total\n */\n\n/**\n * @callback ProgressCallback\n * @param {GitProgressEvent} progress\n * @returns {void | Promise<void>}\n */\n\n/**\n * @typedef {Object} GitHttpRequest\n * @property {string} url - The URL to request\n * @property {string} [method='GET'] - The HTTP method to use\n * @property {Object<string, string>} [headers={}] - Headers to include in the HTTP request\n * @property {Object} [agent] - An HTTP or HTTPS agent that manages connections for the HTTP client (Node.js only)\n * @property {AsyncIterableIterator<Uint8Array>} [body] - An async iterator of Uint8Arrays that make up the body of POST requests\n * @property {ProgressCallback} [onProgress] - Reserved for future use (emitting `GitProgressEvent`s)\n * @property {object} [signal] - Reserved for future use (canceling a request)\n */\n\n/**\n * @typedef {Object} GitHttpResponse\n * @property {string} url - The final URL that was fetched after any redirects\n * @property {string} [method] - The HTTP method that was used\n * @property {Object<string, string>} [headers] - HTTP response headers\n * @property {AsyncIterableIterator<Uint8Array>} [body] - An async iterator of Uint8Arrays that make up the body of the response\n * @property {number} statusCode - The HTTP status code\n * @property {string} statusMessage - The HTTP status message\n */\n\n/**\n * @callback HttpFetch\n * @param {GitHttpRequest} request\n * @returns {Promise<GitHttpResponse>}\n */\n\n/**\n * @typedef {Object} HttpClient\n * @property {HttpFetch} request\n */\n\n/**\n * A git commit object.\n *\n * @typedef {Object} CommitObject\n * @property {string} message Commit message\n * @property {string} tree SHA-1 object id of corresponding file tree\n * @property {string[]} parent an array of zero or more SHA-1 object ids\n * @property {Object} author\n * @property {string} author.name The author's name\n * @property {string} author.email The author's email\n * @property {number} author.timestamp UTC Unix timestamp in seconds\n * @property {number} author.timezoneOffset Timezone difference from UTC in minutes\n * @property {Object} committer\n * @property {string} committer.name The committer's name\n * @property {string} committer.email The committer's email\n * @property {number} committer.timestamp UTC Unix timestamp in seconds\n * @property {number} committer.timezoneOffset Timezone difference from UTC in minutes\n * @property {string} [gpgsig] PGP signature (if present)\n */\n\n/**\n * An entry from a git tree object. Files are called 'blobs' and directories are called 'trees'.\n *\n * @typedef {Object} TreeEntry\n * @property {string} mode the 6 digit hexadecimal mode\n * @property {string} path the name of the file or directory\n * @property {string} oid the SHA-1 object id of the blob or tree\n * @property {'commit'|'blob'|'tree'} type the type of object\n */\n\n/**\n * A git tree object. Trees represent a directory snapshot.\n *\n * @typedef {TreeEntry[]} TreeObject\n */\n\n/**\n * A git annotated tag object.\n *\n * @typedef {Object} TagObject\n * @property {string} object SHA-1 object id of object being tagged\n * @property {'blob' | 'tree' | 'commit' | 'tag'} type the type of the object being tagged\n * @property {string} tag the tag name\n * @property {Object} tagger\n * @property {string} tagger.name the tagger's name\n * @property {string} tagger.email the tagger's email\n * @property {number} tagger.timestamp UTC Unix timestamp in seconds\n * @property {number} tagger.timezoneOffset timezone difference from UTC in minutes\n * @property {string} message tag message\n * @property {string} [gpgsig] PGP signature (if present)\n */\n\n/**\n * @typedef {Object} ReadCommitResult\n * @property {string} oid - SHA-1 object id of this commit\n * @property {CommitObject} commit - the parsed commit object\n * @property {string} payload - PGP signing payload\n */\n\n/**\n * @typedef {Object} ServerRef - This object has the following schema:\n * @property {string} ref - The name of the ref\n * @property {string} oid - The SHA-1 object id the ref points to\n * @property {string} [target] - The target ref pointed to by a symbolic ref\n * @property {string} [peeled] - If the oid is the SHA-1 object id of an annotated tag, this is the SHA-1 object id that the annotated tag points to\n */\n\n/**\n * @typedef Walker\n * @property {Symbol} Symbol('GitWalkerSymbol')\n */\n\n/**\n * Normalized subset of filesystem `stat` data:\n *\n * @typedef {Object} Stat\n * @property {number} ctimeSeconds\n * @property {number} ctimeNanoseconds\n * @property {number} mtimeSeconds\n * @property {number} mtimeNanoseconds\n * @property {number} dev\n * @property {number} ino\n * @property {number} mode\n * @property {number} uid\n * @property {number} gid\n * @property {number} size\n */\n\n/**\n * The `WalkerEntry` is an interface that abstracts computing many common tree / blob stats.\n *\n * @typedef {Object} WalkerEntry\n * @property {function(): Promise<'tree'|'blob'|'special'|'commit'>} type\n * @property {function(): Promise<number>} mode\n * @property {function(): Promise<string>} oid\n * @property {function(): Promise<Uint8Array|void>} content\n * @property {function(): Promise<Stat>} stat\n */\n\n/**\n * @typedef {Object} CallbackFsClient\n * @property {function} readFile - https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback\n * @property {function} writeFile - https://nodejs.org/api/fs.html#fs_fs_writefile_file_data_options_callback\n * @property {function} unlink - https://nodejs.org/api/fs.html#fs_fs_unlink_path_callback\n * @property {function} readdir - https://nodejs.org/api/fs.html#fs_fs_readdir_path_options_callback\n * @property {function} mkdir - https://nodejs.org/api/fs.html#fs_fs_mkdir_path_mode_callback\n * @property {function} rmdir - https://nodejs.org/api/fs.html#fs_fs_rmdir_path_callback\n * @property {function} stat - https://nodejs.org/api/fs.html#fs_fs_stat_path_options_callback\n * @property {function} lstat - https://nodejs.org/api/fs.html#fs_fs_lstat_path_options_callback\n * @property {function} [readlink] - https://nodejs.org/api/fs.html#fs_fs_readlink_path_options_callback\n * @property {function} [symlink] - https://nodejs.org/api/fs.html#fs_fs_symlink_target_path_type_callback\n * @property {function} [chmod] - https://nodejs.org/api/fs.html#fs_fs_chmod_path_mode_callback\n */\n\n/**\n * @typedef {Object} PromiseFsClient\n * @property {Object} promises\n * @property {function} promises.readFile - https://nodejs.org/api/fs.html#fs_fspromises_readfile_path_options\n * @property {function} promises.writeFile - https://nodejs.org/api/fs.html#fs_fspromises_writefile_file_data_options\n * @property {function} promises.unlink - https://nodejs.org/api/fs.html#fs_fspromises_unlink_path\n * @property {function} promises.readdir - https://nodejs.org/api/fs.html#fs_fspromises_readdir_path_options\n * @property {function} promises.mkdir - https://nodejs.org/api/fs.html#fs_fspromises_mkdir_path_options\n * @property {function} promises.rmdir - https://nodejs.org/api/fs.html#fs_fspromises_rmdir_path\n * @property {function} promises.stat - https://nodejs.org/api/fs.html#fs_fspromises_stat_path_options\n * @property {function} promises.lstat - https://nodejs.org/api/fs.html#fs_fspromises_lstat_path_options\n * @property {function} [promises.readlink] - https://nodejs.org/api/fs.html#fs_fspromises_readlink_path_options\n * @property {function} [promises.symlink] - https://nodejs.org/api/fs.html#fs_fspromises_symlink_target_path_type\n * @property {function} [promises.chmod] - https://nodejs.org/api/fs.html#fs_fspromises_chmod_path_mode\n */\n\n/**\n * @typedef {CallbackFsClient | PromiseFsClient} FsClient\n */\n\n/**\n * @callback MessageCallback\n * @param {string} message\n * @returns {void | Promise<void>}\n */\n\n/**\n * @typedef {Object} GitAuth\n * @property {string} [username]\n * @property {string} [password]\n * @property {Object<string, string>} [headers]\n * @property {boolean} [cancel] Tells git to throw a `UserCanceledError` (instead of an `HttpError`).\n */\n\n/**\n * @callback AuthCallback\n * @param {string} url\n * @param {GitAuth} auth Might have some values if the URL itself originally contained a username or password.\n * @returns {GitAuth | void | Promise<GitAuth | void>}\n */\n\n/**\n * @callback AuthFailureCallback\n * @param {string} url\n * @param {GitAuth} auth The credentials that failed\n * @returns {GitAuth | void | Promise<GitAuth | void>}\n */\n\n/**\n * @callback AuthSuccessCallback\n * @param {string} url\n * @param {GitAuth} auth\n * @returns {void | Promise<void>}\n */\n\n/**\n * @typedef {Object} SignParams\n * @property {string} payload - a plaintext message\n * @property {string} secretKey - an 'ASCII armor' encoded PGP key (technically can actually contain _multiple_ keys)\n */\n\n/**\n * @callback SignCallback\n * @param {SignParams} args\n * @return {{signature: string} | Promise<{signature: string}>} - an 'ASCII armor' encoded \"detached\" signature\n */\n\n/**\n * @typedef {Object} MergeDriverParams\n * @property {Array<string>} branches\n * @property {Array<string>} contents\n * @property {string} path\n */\n\n/**\n * @callback MergeDriverCallback\n * @param {MergeDriverParams} args\n * @return {{cleanMerge: boolean, mergedText: string} | Promise<{cleanMerge: boolean, mergedText: string}>}\n */\n\n/**\n * @callback WalkerMap\n * @param {string} filename\n * @param {WalkerEntry[]} entries\n * @returns {Promise<any>}\n */\n\n/**\n * @callback WalkerReduce\n * @param {any} parent\n * @param {any[]} children\n * @returns {Promise<any>}\n */\n\n/**\n * @callback WalkerIterateCallback\n * @param {WalkerEntry[]} entries\n * @returns {Promise<any[]>}\n */\n\n/**\n * @callback WalkerIterate\n * @param {WalkerIterateCallback} walk\n * @param {IterableIterator<WalkerEntry[]>} children\n * @returns {Promise<any[]>}\n */\n\n/**\n * @typedef {Object} RefUpdateStatus\n * @property {boolean} ok\n * @property {string} error\n */\n\n/**\n * @typedef {Object} PushResult\n * @property {boolean} ok\n * @property {?string} error\n * @property {Object<string, RefUpdateStatus>} refs\n * @property {Object<string, string>} [headers]\n */\n\n/**\n * @typedef {0|1} HeadStatus\n */\n\n/**\n * @typedef {0|1|2} WorkdirStatus\n */\n\n/**\n * @typedef {0|1|2|3} StageStatus\n */\n\n/**\n * @typedef {[string, HeadStatus, WorkdirStatus, StageStatus]} StatusRow\n */\n\nclass BaseError extends Error {\n  constructor(message) {\n    super(message);\n    // Setting this here allows TS to infer that all git errors have a `caller` property and\n    // that its type is string.\n    this.caller = '';\n  }\n\n  toJSON() {\n    // Error objects aren't normally serializable. So we do something about that.\n    return {\n      code: this.code,\n      data: this.data,\n      caller: this.caller,\n      message: this.message,\n      stack: this.stack,\n    }\n  }\n\n  fromJSON(json) {\n    const e = new BaseError(json.message);\n    e.code = json.code;\n    e.data = json.data;\n    e.caller = json.caller;\n    e.stack = json.stack;\n    return e\n  }\n\n  get isIsomorphicGitError() {\n    return true\n  }\n}\n\nclass UnmergedPathsError extends BaseError {\n  /**\n   * @param {Array<string>} filepaths\n   */\n  constructor(filepaths) {\n    super(\n      `Modifying the index is not possible because you have unmerged files: ${filepaths.toString}. Fix them up in the work tree, and then use 'git add/rm as appropriate to mark resolution and make a commit.`\n    );\n    this.code = this.name = UnmergedPathsError.code;\n    this.data = { filepaths };\n  }\n}\n/** @type {'UnmergedPathsError'} */\nUnmergedPathsError.code = 'UnmergedPathsError';\n\nclass InternalError extends BaseError {\n  /**\n   * @param {string} message\n   */\n  constructor(message) {\n    super(\n      `An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${message}`\n    );\n    this.code = this.name = InternalError.code;\n    this.data = { message };\n  }\n}\n/** @type {'InternalError'} */\nInternalError.code = 'InternalError';\n\nclass UnsafeFilepathError extends BaseError {\n  /**\n   * @param {string} filepath\n   */\n  constructor(filepath) {\n    super(`The filepath \"${filepath}\" contains unsafe character sequences`);\n    this.code = this.name = UnsafeFilepathError.code;\n    this.data = { filepath };\n  }\n}\n/** @type {'UnsafeFilepathError'} */\nUnsafeFilepathError.code = 'UnsafeFilepathError';\n\n// Modeled after https://github.com/tjfontaine/node-buffercursor\n// but with the goal of being much lighter weight.\nclass BufferCursor {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this._start = 0;\n  }\n\n  eof() {\n    return this._start >= this.buffer.length\n  }\n\n  tell() {\n    return this._start\n  }\n\n  seek(n) {\n    this._start = n;\n  }\n\n  slice(n) {\n    const r = this.buffer.slice(this._start, this._start + n);\n    this._start += n;\n    return r\n  }\n\n  toString(enc, length) {\n    const r = this.buffer.toString(enc, this._start, this._start + length);\n    this._start += length;\n    return r\n  }\n\n  write(value, length, enc) {\n    const r = this.buffer.write(value, this._start, length, enc);\n    this._start += length;\n    return r\n  }\n\n  copy(source, start, end) {\n    const r = source.copy(this.buffer, this._start, start, end);\n    this._start += r;\n    return r\n  }\n\n  readUInt8() {\n    const r = this.buffer.readUInt8(this._start);\n    this._start += 1;\n    return r\n  }\n\n  writeUInt8(value) {\n    const r = this.buffer.writeUInt8(value, this._start);\n    this._start += 1;\n    return r\n  }\n\n  readUInt16BE() {\n    const r = this.buffer.readUInt16BE(this._start);\n    this._start += 2;\n    return r\n  }\n\n  writeUInt16BE(value) {\n    const r = this.buffer.writeUInt16BE(value, this._start);\n    this._start += 2;\n    return r\n  }\n\n  readUInt32BE() {\n    const r = this.buffer.readUInt32BE(this._start);\n    this._start += 4;\n    return r\n  }\n\n  writeUInt32BE(value) {\n    const r = this.buffer.writeUInt32BE(value, this._start);\n    this._start += 4;\n    return r\n  }\n}\n\nfunction compareStrings(a, b) {\n  // https://stackoverflow.com/a/40355107/2168416\n  return -(a < b) || +(a > b)\n}\n\nfunction comparePath(a, b) {\n  // https://stackoverflow.com/a/40355107/2168416\n  return compareStrings(a.path, b.path)\n}\n\n/**\n * From https://github.com/git/git/blob/master/Documentation/technical/index-format.txt\n *\n * 32-bit mode, split into (high to low bits)\n *\n *  4-bit object type\n *    valid values in binary are 1000 (regular file), 1010 (symbolic link)\n *    and 1110 (gitlink)\n *\n *  3-bit unused\n *\n *  9-bit unix permission. Only 0755 and 0644 are valid for regular files.\n *  Symbolic links and gitlinks have value 0 in this field.\n */\nfunction normalizeMode(mode) {\n  // Note: BrowserFS will use -1 for \"unknown\"\n  // I need to make it non-negative for these bitshifts to work.\n  let type = mode > 0 ? mode >> 12 : 0;\n  // If it isn't valid, assume it as a \"regular file\"\n  // 0100 = directory\n  // 1000 = regular file\n  // 1010 = symlink\n  // 1110 = gitlink\n  if (\n    type !== 0b0100 &&\n    type !== 0b1000 &&\n    type !== 0b1010 &&\n    type !== 0b1110\n  ) {\n    type = 0b1000;\n  }\n  let permissions = mode & 0o777;\n  // Is the file executable? then 755. Else 644.\n  if (permissions & 0b001001001) {\n    permissions = 0o755;\n  } else {\n    permissions = 0o644;\n  }\n  // If it's not a regular file, scrub all permissions\n  if (type !== 0b1000) permissions = 0;\n  return (type << 12) + permissions\n}\n\nconst MAX_UINT32 = 2 ** 32;\n\nfunction SecondsNanoseconds(\n  givenSeconds,\n  givenNanoseconds,\n  milliseconds,\n  date\n) {\n  if (givenSeconds !== undefined && givenNanoseconds !== undefined) {\n    return [givenSeconds, givenNanoseconds]\n  }\n  if (milliseconds === undefined) {\n    milliseconds = date.valueOf();\n  }\n  const seconds = Math.floor(milliseconds / 1000);\n  const nanoseconds = (milliseconds - seconds * 1000) * 1000000;\n  return [seconds, nanoseconds]\n}\n\nfunction normalizeStats(e) {\n  const [ctimeSeconds, ctimeNanoseconds] = SecondsNanoseconds(\n    e.ctimeSeconds,\n    e.ctimeNanoseconds,\n    e.ctimeMs,\n    e.ctime\n  );\n  const [mtimeSeconds, mtimeNanoseconds] = SecondsNanoseconds(\n    e.mtimeSeconds,\n    e.mtimeNanoseconds,\n    e.mtimeMs,\n    e.mtime\n  );\n\n  return {\n    ctimeSeconds: ctimeSeconds % MAX_UINT32,\n    ctimeNanoseconds: ctimeNanoseconds % MAX_UINT32,\n    mtimeSeconds: mtimeSeconds % MAX_UINT32,\n    mtimeNanoseconds: mtimeNanoseconds % MAX_UINT32,\n    dev: e.dev % MAX_UINT32,\n    ino: e.ino % MAX_UINT32,\n    mode: normalizeMode(e.mode % MAX_UINT32),\n    uid: e.uid % MAX_UINT32,\n    gid: e.gid % MAX_UINT32,\n    // size of -1 happens over a BrowserFS HTTP Backend that doesn't serve Content-Length headers\n    // (like the Karma webserver) because BrowserFS HTTP Backend uses HTTP HEAD requests to do fs.stat\n    size: e.size > -1 ? e.size % MAX_UINT32 : 0,\n  }\n}\n\nfunction toHex(buffer) {\n  let hex = '';\n  for (const byte of new Uint8Array(buffer)) {\n    if (byte < 16) hex += '0';\n    hex += byte.toString(16);\n  }\n  return hex\n}\n\n/* eslint-env node, browser */\n\nlet supportsSubtleSHA1 = null;\n\nasync function shasum(buffer) {\n  if (supportsSubtleSHA1 === null) {\n    supportsSubtleSHA1 = await testSubtleSHA1();\n  }\n  return supportsSubtleSHA1 ? subtleSHA1(buffer) : shasumSync(buffer)\n}\n\n// This is modeled after @dominictarr's \"shasum\" module,\n// but without the 'json-stable-stringify' dependency and\n// extra type-casting features.\nfunction shasumSync(buffer) {\n  return new Hash().update(buffer).digest('hex')\n}\n\nasync function subtleSHA1(buffer) {\n  const hash = await crypto.subtle.digest('SHA-1', buffer);\n  return toHex(hash)\n}\n\nasync function testSubtleSHA1() {\n  // I'm using a rather crude method of progressive enhancement, because\n  // some browsers that have crypto.subtle.digest don't actually implement SHA-1.\n  try {\n    const hash = await subtleSHA1(new Uint8Array([]));\n    if (hash === 'da39a3ee5e6b4b0d3255bfef95601890afd80709') return true\n  } catch (_) {\n    // no bother\n  }\n  return false\n}\n\n// Extract 1-bit assume-valid, 1-bit extended flag, 2-bit merge state flag, 12-bit path length flag\nfunction parseCacheEntryFlags(bits) {\n  return {\n    assumeValid: Boolean(bits & 0b1000000000000000),\n    extended: Boolean(bits & 0b0100000000000000),\n    stage: (bits & 0b0011000000000000) >> 12,\n    nameLength: bits & 0b0000111111111111,\n  }\n}\n\nfunction renderCacheEntryFlags(entry) {\n  const flags = entry.flags;\n  // 1-bit extended flag (must be zero in version 2)\n  flags.extended = false;\n  // 12-bit name length if the length is less than 0xFFF; otherwise 0xFFF\n  // is stored in this field.\n  flags.nameLength = Math.min(Buffer.from(entry.path).length, 0xfff);\n  return (\n    (flags.assumeValid ? 0b1000000000000000 : 0) +\n    (flags.extended ? 0b0100000000000000 : 0) +\n    ((flags.stage & 0b11) << 12) +\n    (flags.nameLength & 0b111111111111)\n  )\n}\n\nclass GitIndex {\n  /*::\n   _entries: Map<string, CacheEntry>\n   _dirty: boolean // Used to determine if index needs to be saved to filesystem\n   */\n  constructor(entries, unmergedPaths) {\n    this._dirty = false;\n    this._unmergedPaths = unmergedPaths || new Set();\n    this._entries = entries || new Map();\n  }\n\n  _addEntry(entry) {\n    if (entry.flags.stage === 0) {\n      entry.stages = [entry];\n      this._entries.set(entry.path, entry);\n      this._unmergedPaths.delete(entry.path);\n    } else {\n      let existingEntry = this._entries.get(entry.path);\n      if (!existingEntry) {\n        this._entries.set(entry.path, entry);\n        existingEntry = entry;\n      }\n      existingEntry.stages[entry.flags.stage] = entry;\n      this._unmergedPaths.add(entry.path);\n    }\n  }\n\n  static async from(buffer) {\n    if (Buffer.isBuffer(buffer)) {\n      return GitIndex.fromBuffer(buffer)\n    } else if (buffer === null) {\n      return new GitIndex(null)\n    } else {\n      throw new InternalError('invalid type passed to GitIndex.from')\n    }\n  }\n\n  static async fromBuffer(buffer) {\n    if (buffer.length === 0) {\n      throw new InternalError('Index file is empty (.git/index)')\n    }\n\n    const index = new GitIndex();\n    const reader = new BufferCursor(buffer);\n    const magic = reader.toString('utf8', 4);\n    if (magic !== 'DIRC') {\n      throw new InternalError(`Invalid dircache magic file number: ${magic}`)\n    }\n\n    // Verify shasum after we ensured that the file has a magic number\n    const shaComputed = await shasum(buffer.slice(0, -20));\n    const shaClaimed = buffer.slice(-20).toString('hex');\n    if (shaClaimed !== shaComputed) {\n      throw new InternalError(\n        `Invalid checksum in GitIndex buffer: expected ${shaClaimed} but saw ${shaComputed}`\n      )\n    }\n\n    const version = reader.readUInt32BE();\n    if (version !== 2) {\n      throw new InternalError(`Unsupported dircache version: ${version}`)\n    }\n    const numEntries = reader.readUInt32BE();\n    let i = 0;\n    while (!reader.eof() && i < numEntries) {\n      const entry = {};\n      entry.ctimeSeconds = reader.readUInt32BE();\n      entry.ctimeNanoseconds = reader.readUInt32BE();\n      entry.mtimeSeconds = reader.readUInt32BE();\n      entry.mtimeNanoseconds = reader.readUInt32BE();\n      entry.dev = reader.readUInt32BE();\n      entry.ino = reader.readUInt32BE();\n      entry.mode = reader.readUInt32BE();\n      entry.uid = reader.readUInt32BE();\n      entry.gid = reader.readUInt32BE();\n      entry.size = reader.readUInt32BE();\n      entry.oid = reader.slice(20).toString('hex');\n      const flags = reader.readUInt16BE();\n      entry.flags = parseCacheEntryFlags(flags);\n      // TODO: handle if (version === 3 && entry.flags.extended)\n      const pathlength = buffer.indexOf(0, reader.tell() + 1) - reader.tell();\n      if (pathlength < 1) {\n        throw new InternalError(`Got a path length of: ${pathlength}`)\n      }\n      // TODO: handle pathnames larger than 12 bits\n      entry.path = reader.toString('utf8', pathlength);\n\n      // Prevent malicious paths like \"..\\foo\"\n      if (entry.path.includes('..\\\\') || entry.path.includes('../')) {\n        throw new UnsafeFilepathError(entry.path)\n      }\n\n      // The next bit is awkward. We expect 1 to 8 null characters\n      // such that the total size of the entry is a multiple of 8 bits.\n      // (Hence subtract 12 bytes for the header.)\n      let padding = 8 - ((reader.tell() - 12) % 8);\n      if (padding === 0) padding = 8;\n      while (padding--) {\n        const tmp = reader.readUInt8();\n        if (tmp !== 0) {\n          throw new InternalError(\n            `Expected 1-8 null characters but got '${tmp}' after ${entry.path}`\n          )\n        } else if (reader.eof()) {\n          throw new InternalError('Unexpected end of file')\n        }\n      }\n      // end of awkward part\n      entry.stages = [];\n\n      index._addEntry(entry);\n\n      i++;\n    }\n    return index\n  }\n\n  get unmergedPaths() {\n    return [...this._unmergedPaths]\n  }\n\n  get entries() {\n    return [...this._entries.values()].sort(comparePath)\n  }\n\n  get entriesMap() {\n    return this._entries\n  }\n\n  get entriesFlat() {\n    return [...this.entries].flatMap(entry => {\n      return entry.stages.length > 1 ? entry.stages.filter(x => x) : entry\n    })\n  }\n\n  *[Symbol.iterator]() {\n    for (const entry of this.entries) {\n      yield entry;\n    }\n  }\n\n  insert({ filepath, stats, oid, stage = 0 }) {\n    if (!stats) {\n      stats = {\n        ctimeSeconds: 0,\n        ctimeNanoseconds: 0,\n        mtimeSeconds: 0,\n        mtimeNanoseconds: 0,\n        dev: 0,\n        ino: 0,\n        mode: 0,\n        uid: 0,\n        gid: 0,\n        size: 0,\n      };\n    }\n    stats = normalizeStats(stats);\n    const bfilepath = Buffer.from(filepath);\n    const entry = {\n      ctimeSeconds: stats.ctimeSeconds,\n      ctimeNanoseconds: stats.ctimeNanoseconds,\n      mtimeSeconds: stats.mtimeSeconds,\n      mtimeNanoseconds: stats.mtimeNanoseconds,\n      dev: stats.dev,\n      ino: stats.ino,\n      // We provide a fallback value for `mode` here because not all fs\n      // implementations assign it, but we use it in GitTree.\n      // '100644' is for a \"regular non-executable file\"\n      mode: stats.mode || 0o100644,\n      uid: stats.uid,\n      gid: stats.gid,\n      size: stats.size,\n      path: filepath,\n      oid: oid,\n      flags: {\n        assumeValid: false,\n        extended: false,\n        stage,\n        nameLength: bfilepath.length < 0xfff ? bfilepath.length : 0xfff,\n      },\n      stages: [],\n    };\n\n    this._addEntry(entry);\n\n    this._dirty = true;\n  }\n\n  delete({ filepath }) {\n    if (this._entries.has(filepath)) {\n      this._entries.delete(filepath);\n    } else {\n      for (const key of this._entries.keys()) {\n        if (key.startsWith(filepath + '/')) {\n          this._entries.delete(key);\n        }\n      }\n    }\n\n    if (this._unmergedPaths.has(filepath)) {\n      this._unmergedPaths.delete(filepath);\n    }\n    this._dirty = true;\n  }\n\n  clear() {\n    this._entries.clear();\n    this._dirty = true;\n  }\n\n  has({ filepath }) {\n    return this._entries.has(filepath)\n  }\n\n  render() {\n    return this.entries\n      .map(entry => `${entry.mode.toString(8)} ${entry.oid}    ${entry.path}`)\n      .join('\\n')\n  }\n\n  static async _entryToBuffer(entry) {\n    const bpath = Buffer.from(entry.path);\n    // the fixed length + the filename + at least one null char => align by 8\n    const length = Math.ceil((62 + bpath.length + 1) / 8) * 8;\n    const written = Buffer.alloc(length);\n    const writer = new BufferCursor(written);\n    const stat = normalizeStats(entry);\n    writer.writeUInt32BE(stat.ctimeSeconds);\n    writer.writeUInt32BE(stat.ctimeNanoseconds);\n    writer.writeUInt32BE(stat.mtimeSeconds);\n    writer.writeUInt32BE(stat.mtimeNanoseconds);\n    writer.writeUInt32BE(stat.dev);\n    writer.writeUInt32BE(stat.ino);\n    writer.writeUInt32BE(stat.mode);\n    writer.writeUInt32BE(stat.uid);\n    writer.writeUInt32BE(stat.gid);\n    writer.writeUInt32BE(stat.size);\n    writer.write(entry.oid, 20, 'hex');\n    writer.writeUInt16BE(renderCacheEntryFlags(entry));\n    writer.write(entry.path, bpath.length, 'utf8');\n    return written\n  }\n\n  async toObject() {\n    const header = Buffer.alloc(12);\n    const writer = new BufferCursor(header);\n    writer.write('DIRC', 4, 'utf8');\n    writer.writeUInt32BE(2);\n    writer.writeUInt32BE(this.entriesFlat.length);\n\n    let entryBuffers = [];\n    for (const entry of this.entries) {\n      entryBuffers.push(GitIndex._entryToBuffer(entry));\n      if (entry.stages.length > 1) {\n        for (const stage of entry.stages) {\n          if (stage && stage !== entry) {\n            entryBuffers.push(GitIndex._entryToBuffer(stage));\n          }\n        }\n      }\n    }\n    entryBuffers = await Promise.all(entryBuffers);\n\n    const body = Buffer.concat(entryBuffers);\n    const main = Buffer.concat([header, body]);\n    const sum = await shasum(main);\n    return Buffer.concat([main, Buffer.from(sum, 'hex')])\n  }\n}\n\nfunction compareStats(entry, stats) {\n  // Comparison based on the description in Paragraph 4 of\n  // https://www.kernel.org/pub/software/scm/git/docs/technical/racy-git.txt\n  const e = normalizeStats(entry);\n  const s = normalizeStats(stats);\n  const staleness =\n    e.mode !== s.mode ||\n    e.mtimeSeconds !== s.mtimeSeconds ||\n    e.ctimeSeconds !== s.ctimeSeconds ||\n    e.uid !== s.uid ||\n    e.gid !== s.gid ||\n    e.ino !== s.ino ||\n    e.size !== s.size;\n  return staleness\n}\n\n// import LockManager from 'travix-lock-manager'\n\n// import Lock from '../utils.js'\n\n// const lm = new LockManager()\nlet lock = null;\n\nconst IndexCache = Symbol('IndexCache');\n\nfunction createCache() {\n  return {\n    map: new Map(),\n    stats: new Map(),\n  }\n}\n\nasync function updateCachedIndexFile(fs, filepath, cache) {\n  const stat = await fs.lstat(filepath);\n  const rawIndexFile = await fs.read(filepath);\n  const index = await GitIndex.from(rawIndexFile);\n  // cache the GitIndex object so we don't need to re-read it every time.\n  cache.map.set(filepath, index);\n  // Save the stat data for the index so we know whether the cached file is stale (modified by an outside process).\n  cache.stats.set(filepath, stat);\n}\n\n// Determine whether our copy of the index file is stale\nasync function isIndexStale(fs, filepath, cache) {\n  const savedStats = cache.stats.get(filepath);\n  if (savedStats === undefined) return true\n  const currStats = await fs.lstat(filepath);\n  if (savedStats === null) return false\n  if (currStats === null) return false\n  return compareStats(savedStats, currStats)\n}\n\nclass GitIndexManager {\n  /**\n   *\n   * @param {object} opts\n   * @param {import('../models/FileSystem.js').FileSystem} opts.fs\n   * @param {string} opts.gitdir\n   * @param {object} opts.cache\n   * @param {bool} opts.allowUnmerged\n   * @param {function(GitIndex): any} closure\n   */\n  static async acquire({ fs, gitdir, cache, allowUnmerged = true }, closure) {\n    if (!cache[IndexCache]) cache[IndexCache] = createCache();\n\n    const filepath = `${gitdir}/index`;\n    if (lock === null) lock = new AsyncLock({ maxPending: Infinity });\n    let result;\n    let unmergedPaths = [];\n    await lock.acquire(filepath, async () => {\n      // Acquire a file lock while we're reading the index\n      // to make sure other processes aren't writing to it\n      // simultaneously, which could result in a corrupted index.\n      // const fileLock = await Lock(filepath)\n      if (await isIndexStale(fs, filepath, cache[IndexCache])) {\n        await updateCachedIndexFile(fs, filepath, cache[IndexCache]);\n      }\n      const index = cache[IndexCache].map.get(filepath);\n      unmergedPaths = index.unmergedPaths;\n\n      if (unmergedPaths.length && !allowUnmerged)\n        throw new UnmergedPathsError(unmergedPaths)\n\n      result = await closure(index);\n      if (index._dirty) {\n        // Acquire a file lock while we're writing the index file\n        // let fileLock = await Lock(filepath)\n        const buffer = await index.toObject();\n        await fs.write(filepath, buffer);\n        // Update cached stat value\n        cache[IndexCache].stats.set(filepath, await fs.lstat(filepath));\n        index._dirty = false;\n      }\n    });\n\n    return result\n  }\n}\n\nfunction basename(path) {\n  const last = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\\\'));\n  if (last > -1) {\n    path = path.slice(last + 1);\n  }\n  return path\n}\n\nfunction dirname(path) {\n  const last = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\\\'));\n  if (last === -1) return '.'\n  if (last === 0) return '/'\n  return path.slice(0, last)\n}\n\n/*::\ntype Node = {\n  type: string,\n  fullpath: string,\n  basename: string,\n  metadata: Object, // mode, oid\n  parent?: Node,\n  children: Array<Node>\n}\n*/\n\nfunction flatFileListToDirectoryStructure(files) {\n  const inodes = new Map();\n  const mkdir = function(name) {\n    if (!inodes.has(name)) {\n      const dir = {\n        type: 'tree',\n        fullpath: name,\n        basename: basename(name),\n        metadata: {},\n        children: [],\n      };\n      inodes.set(name, dir);\n      // This recursively generates any missing parent folders.\n      // We do it after we've added the inode to the set so that\n      // we don't recurse infinitely trying to create the root '.' dirname.\n      dir.parent = mkdir(dirname(name));\n      if (dir.parent && dir.parent !== dir) dir.parent.children.push(dir);\n    }\n    return inodes.get(name)\n  };\n\n  const mkfile = function(name, metadata) {\n    if (!inodes.has(name)) {\n      const file = {\n        type: 'blob',\n        fullpath: name,\n        basename: basename(name),\n        metadata: metadata,\n        // This recursively generates any missing parent folders.\n        parent: mkdir(dirname(name)),\n        children: [],\n      };\n      if (file.parent) file.parent.children.push(file);\n      inodes.set(name, file);\n    }\n    return inodes.get(name)\n  };\n\n  mkdir('.');\n  for (const file of files) {\n    mkfile(file.path, file);\n  }\n  return inodes\n}\n\n/**\n *\n * @param {number} mode\n */\nfunction mode2type(mode) {\n  // prettier-ignore\n  switch (mode) {\n    case 0o040000: return 'tree'\n    case 0o100644: return 'blob'\n    case 0o100755: return 'blob'\n    case 0o120000: return 'blob'\n    case 0o160000: return 'commit'\n  }\n  throw new InternalError(`Unexpected GitTree entry mode: ${mode.toString(8)}`)\n}\n\nclass GitWalkerIndex {\n  constructor({ fs, gitdir, cache }) {\n    this.treePromise = GitIndexManager.acquire(\n      { fs, gitdir, cache },\n      async function(index) {\n        return flatFileListToDirectoryStructure(index.entries)\n      }\n    );\n    const walker = this;\n    this.ConstructEntry = class StageEntry {\n      constructor(fullpath) {\n        this._fullpath = fullpath;\n        this._type = false;\n        this._mode = false;\n        this._stat = false;\n        this._oid = false;\n      }\n\n      async type() {\n        return walker.type(this)\n      }\n\n      async mode() {\n        return walker.mode(this)\n      }\n\n      async stat() {\n        return walker.stat(this)\n      }\n\n      async content() {\n        return walker.content(this)\n      }\n\n      async oid() {\n        return walker.oid(this)\n      }\n    };\n  }\n\n  async readdir(entry) {\n    const filepath = entry._fullpath;\n    const tree = await this.treePromise;\n    const inode = tree.get(filepath);\n    if (!inode) return null\n    if (inode.type === 'blob') return null\n    if (inode.type !== 'tree') {\n      throw new Error(`ENOTDIR: not a directory, scandir '${filepath}'`)\n    }\n    const names = inode.children.map(inode => inode.fullpath);\n    names.sort(compareStrings);\n    return names\n  }\n\n  async type(entry) {\n    if (entry._type === false) {\n      await entry.stat();\n    }\n    return entry._type\n  }\n\n  async mode(entry) {\n    if (entry._mode === false) {\n      await entry.stat();\n    }\n    return entry._mode\n  }\n\n  async stat(entry) {\n    if (entry._stat === false) {\n      const tree = await this.treePromise;\n      const inode = tree.get(entry._fullpath);\n      if (!inode) {\n        throw new Error(\n          `ENOENT: no such file or directory, lstat '${entry._fullpath}'`\n        )\n      }\n      const stats = inode.type === 'tree' ? {} : normalizeStats(inode.metadata);\n      entry._type = inode.type === 'tree' ? 'tree' : mode2type(stats.mode);\n      entry._mode = stats.mode;\n      if (inode.type === 'tree') {\n        entry._stat = undefined;\n      } else {\n        entry._stat = stats;\n      }\n    }\n    return entry._stat\n  }\n\n  async content(_entry) {\n    // Cannot get content for an index entry\n  }\n\n  async oid(entry) {\n    if (entry._oid === false) {\n      const tree = await this.treePromise;\n      const inode = tree.get(entry._fullpath);\n      entry._oid = inode.metadata.oid;\n    }\n    return entry._oid\n  }\n}\n\n// This is part of an elaborate system to facilitate code-splitting / tree-shaking.\n// commands/walk.js can depend on only this, and the actual Walker classes exported\n// can be opaque - only having a single property (this symbol) that is not enumerable,\n// and thus the constructor can be passed as an argument to walk while being \"unusable\"\n// outside of it.\nconst GitWalkSymbol = Symbol('GitWalkSymbol');\n\n// @ts-check\n\n/**\n * @returns {Walker}\n */\nfunction STAGE() {\n  const o = Object.create(null);\n  Object.defineProperty(o, GitWalkSymbol, {\n    value: function({ fs, gitdir, cache }) {\n      return new GitWalkerIndex({ fs, gitdir, cache })\n    },\n  });\n  Object.freeze(o);\n  return o\n}\n\n// @ts-check\n\nclass NotFoundError extends BaseError {\n  /**\n   * @param {string} what\n   */\n  constructor(what) {\n    super(`Could not find ${what}.`);\n    this.code = this.name = NotFoundError.code;\n    this.data = { what };\n  }\n}\n/** @type {'NotFoundError'} */\nNotFoundError.code = 'NotFoundError';\n\nclass ObjectTypeError extends BaseError {\n  /**\n   * @param {string} oid\n   * @param {'blob'|'commit'|'tag'|'tree'} actual\n   * @param {'blob'|'commit'|'tag'|'tree'} expected\n   * @param {string} [filepath]\n   */\n  constructor(oid, actual, expected, filepath) {\n    super(\n      `Object ${oid} ${\n        filepath ? `at ${filepath}` : ''\n      }was anticipated to be a ${expected} but it is a ${actual}.`\n    );\n    this.code = this.name = ObjectTypeError.code;\n    this.data = { oid, actual, expected, filepath };\n  }\n}\n/** @type {'ObjectTypeError'} */\nObjectTypeError.code = 'ObjectTypeError';\n\nclass InvalidOidError extends BaseError {\n  /**\n   * @param {string} value\n   */\n  constructor(value) {\n    super(`Expected a 40-char hex object id but saw \"${value}\".`);\n    this.code = this.name = InvalidOidError.code;\n    this.data = { value };\n  }\n}\n/** @type {'InvalidOidError'} */\nInvalidOidError.code = 'InvalidOidError';\n\nclass NoRefspecError extends BaseError {\n  /**\n   * @param {string} remote\n   */\n  constructor(remote) {\n    super(`Could not find a fetch refspec for remote \"${remote}\". Make sure the config file has an entry like the following:\n[remote \"${remote}\"]\n\\tfetch = +refs/heads/*:refs/remotes/origin/*\n`);\n    this.code = this.name = NoRefspecError.code;\n    this.data = { remote };\n  }\n}\n/** @type {'NoRefspecError'} */\nNoRefspecError.code = 'NoRefspecError';\n\nclass GitPackedRefs {\n  constructor(text) {\n    this.refs = new Map();\n    this.parsedConfig = [];\n    if (text) {\n      let key = null;\n      this.parsedConfig = text\n        .trim()\n        .split('\\n')\n        .map(line => {\n          if (/^\\s*#/.test(line)) {\n            return { line, comment: true }\n          }\n          const i = line.indexOf(' ');\n          if (line.startsWith('^')) {\n            // This is a oid for the commit associated with the annotated tag immediately preceding this line.\n            // Trim off the '^'\n            const value = line.slice(1);\n            // The tagname^{} syntax is based on the output of `git show-ref --tags -d`\n            this.refs.set(key + '^{}', value);\n            return { line, ref: key, peeled: value }\n          } else {\n            // This is an oid followed by the ref name\n            const value = line.slice(0, i);\n            key = line.slice(i + 1);\n            this.refs.set(key, value);\n            return { line, ref: key, oid: value }\n          }\n        });\n    }\n    return this\n  }\n\n  static from(text) {\n    return new GitPackedRefs(text)\n  }\n\n  delete(ref) {\n    this.parsedConfig = this.parsedConfig.filter(entry => entry.ref !== ref);\n    this.refs.delete(ref);\n  }\n\n  toString() {\n    return this.parsedConfig.map(({ line }) => line).join('\\n') + '\\n'\n  }\n}\n\nclass GitRefSpec {\n  constructor({ remotePath, localPath, force, matchPrefix }) {\n    Object.assign(this, {\n      remotePath,\n      localPath,\n      force,\n      matchPrefix,\n    });\n  }\n\n  static from(refspec) {\n    const [\n      forceMatch,\n      remotePath,\n      remoteGlobMatch,\n      localPath,\n      localGlobMatch,\n    ] = refspec.match(/^(\\+?)(.*?)(\\*?):(.*?)(\\*?)$/).slice(1);\n    const force = forceMatch === '+';\n    const remoteIsGlob = remoteGlobMatch === '*';\n    const localIsGlob = localGlobMatch === '*';\n    // validate\n    // TODO: Make this check more nuanced, and depend on whether this is a fetch refspec or a push refspec\n    if (remoteIsGlob !== localIsGlob) {\n      throw new InternalError('Invalid refspec')\n    }\n    return new GitRefSpec({\n      remotePath,\n      localPath,\n      force,\n      matchPrefix: remoteIsGlob,\n    })\n    // TODO: We need to run resolveRef on both paths to expand them to their full name.\n  }\n\n  translate(remoteBranch) {\n    if (this.matchPrefix) {\n      if (remoteBranch.startsWith(this.remotePath)) {\n        return this.localPath + remoteBranch.replace(this.remotePath, '')\n      }\n    } else {\n      if (remoteBranch === this.remotePath) return this.localPath\n    }\n    return null\n  }\n\n  reverseTranslate(localBranch) {\n    if (this.matchPrefix) {\n      if (localBranch.startsWith(this.localPath)) {\n        return this.remotePath + localBranch.replace(this.localPath, '')\n      }\n    } else {\n      if (localBranch === this.localPath) return this.remotePath\n    }\n    return null\n  }\n}\n\nclass GitRefSpecSet {\n  constructor(rules = []) {\n    this.rules = rules;\n  }\n\n  static from(refspecs) {\n    const rules = [];\n    for (const refspec of refspecs) {\n      rules.push(GitRefSpec.from(refspec)); // might throw\n    }\n    return new GitRefSpecSet(rules)\n  }\n\n  add(refspec) {\n    const rule = GitRefSpec.from(refspec); // might throw\n    this.rules.push(rule);\n  }\n\n  translate(remoteRefs) {\n    const result = [];\n    for (const rule of this.rules) {\n      for (const remoteRef of remoteRefs) {\n        const localRef = rule.translate(remoteRef);\n        if (localRef) {\n          result.push([remoteRef, localRef]);\n        }\n      }\n    }\n    return result\n  }\n\n  translateOne(remoteRef) {\n    let result = null;\n    for (const rule of this.rules) {\n      const localRef = rule.translate(remoteRef);\n      if (localRef) {\n        result = localRef;\n      }\n    }\n    return result\n  }\n\n  localNamespaces() {\n    return this.rules\n      .filter(rule => rule.matchPrefix)\n      .map(rule => rule.localPath.replace(/\\/$/, ''))\n  }\n}\n\nfunction compareRefNames(a, b) {\n  // https://stackoverflow.com/a/40355107/2168416\n  const _a = a.replace(/\\^\\{\\}$/, '');\n  const _b = b.replace(/\\^\\{\\}$/, '');\n  const tmp = -(_a < _b) || +(_a > _b);\n  if (tmp === 0) {\n    return a.endsWith('^{}') ? 1 : -1\n  }\n  return tmp\n}\n\nfunction normalizePath(path) {\n  return path\n    .replace(/\\/\\.\\//g, '/') // Replace '/./' with '/'\n    .replace(/\\/{2,}/g, '/') // Replace consecutive '/'\n    .replace(/^\\/\\.$/, '/') // if path === '/.' return '/'\n    .replace(/^\\.\\/$/, '.') // if path === './' return '.'\n    .replace(/^\\.\\//, '') // Remove leading './'\n    .replace(/\\/\\.$/, '') // Remove trailing '/.'\n    .replace(/(.+)\\/$/, '$1') // Remove trailing '/'\n    .replace(/^$/, '.') // if path === '' return '.'\n}\n\n// For some reason path.posix.join is undefined in webpack\n\nfunction join(...parts) {\n  return normalizePath(parts.map(normalizePath).join('/'))\n}\n\n// This is straight from parse_unit_factor in config.c of canonical git\nconst num = val => {\n  val = val.toLowerCase();\n  let n = parseInt(val);\n  if (val.endsWith('k')) n *= 1024;\n  if (val.endsWith('m')) n *= 1024 * 1024;\n  if (val.endsWith('g')) n *= 1024 * 1024 * 1024;\n  return n\n};\n\n// This is straight from git_parse_maybe_bool_text in config.c of canonical git\nconst bool = val => {\n  val = val.trim().toLowerCase();\n  if (val === 'true' || val === 'yes' || val === 'on') return true\n  if (val === 'false' || val === 'no' || val === 'off') return false\n  throw Error(\n    `Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ${val}`\n  )\n};\n\nconst schema = {\n  core: {\n    filemode: bool,\n    bare: bool,\n    logallrefupdates: bool,\n    symlinks: bool,\n    ignorecase: bool,\n    bigFileThreshold: num,\n  },\n};\n\n// https://git-scm.com/docs/git-config#_syntax\n\n// section starts with [ and ends with ]\n// section is alphanumeric (ASCII) with - and .\n// section is case insensitive\n// subsection is optionnal\n// subsection is specified after section and one or more spaces\n// subsection is specified between double quotes\nconst SECTION_LINE_REGEX = /^\\[([A-Za-z0-9-.]+)(?: \"(.*)\")?\\]$/;\nconst SECTION_REGEX = /^[A-Za-z0-9-.]+$/;\n\n// variable lines contain a name, and equal sign and then a value\n// variable lines can also only contain a name (the implicit value is a boolean true)\n// variable name is alphanumeric (ASCII) with -\n// variable name starts with an alphabetic character\n// variable name is case insensitive\nconst VARIABLE_LINE_REGEX = /^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/;\nconst VARIABLE_NAME_REGEX = /^[A-Za-z][A-Za-z-]*$/;\n\nconst VARIABLE_VALUE_COMMENT_REGEX = /^(.*?)( *[#;].*)$/;\n\nconst extractSectionLine = line => {\n  const matches = SECTION_LINE_REGEX.exec(line);\n  if (matches != null) {\n    const [section, subsection] = matches.slice(1);\n    return [section, subsection]\n  }\n  return null\n};\n\nconst extractVariableLine = line => {\n  const matches = VARIABLE_LINE_REGEX.exec(line);\n  if (matches != null) {\n    const [name, rawValue = 'true'] = matches.slice(1);\n    const valueWithoutComments = removeComments(rawValue);\n    const valueWithoutQuotes = removeQuotes(valueWithoutComments);\n    return [name, valueWithoutQuotes]\n  }\n  return null\n};\n\nconst removeComments = rawValue => {\n  const commentMatches = VARIABLE_VALUE_COMMENT_REGEX.exec(rawValue);\n  if (commentMatches == null) {\n    return rawValue\n  }\n  const [valueWithoutComment, comment] = commentMatches.slice(1);\n  // if odd number of quotes before and after comment => comment is escaped\n  if (\n    hasOddNumberOfQuotes(valueWithoutComment) &&\n    hasOddNumberOfQuotes(comment)\n  ) {\n    return `${valueWithoutComment}${comment}`\n  }\n  return valueWithoutComment\n};\n\nconst hasOddNumberOfQuotes = text => {\n  const numberOfQuotes = (text.match(/(?:^|[^\\\\])\"/g) || []).length;\n  return numberOfQuotes % 2 !== 0\n};\n\nconst removeQuotes = text => {\n  return text.split('').reduce((newText, c, idx, text) => {\n    const isQuote = c === '\"' && text[idx - 1] !== '\\\\';\n    const isEscapeForQuote = c === '\\\\' && text[idx + 1] === '\"';\n    if (isQuote || isEscapeForQuote) {\n      return newText\n    }\n    return newText + c\n  }, '')\n};\n\nconst lower = text => {\n  return text != null ? text.toLowerCase() : null\n};\n\nconst getPath = (section, subsection, name) => {\n  return [lower(section), subsection, lower(name)]\n    .filter(a => a != null)\n    .join('.')\n};\n\nconst normalizePath$1 = path => {\n  const pathSegments = path.split('.');\n  const section = pathSegments.shift();\n  const name = pathSegments.pop();\n  const subsection = pathSegments.length ? pathSegments.join('.') : undefined;\n\n  return {\n    section,\n    subsection,\n    name,\n    path: getPath(section, subsection, name),\n    sectionPath: getPath(section, subsection, null),\n  }\n};\n\nconst findLastIndex = (array, callback) => {\n  return array.reduce((lastIndex, item, index) => {\n    return callback(item) ? index : lastIndex\n  }, -1)\n};\n\n// Note: there are a LOT of edge cases that aren't covered (e.g. keys in sections that also\n// have subsections, [include] directives, etc.\nclass GitConfig {\n  constructor(text) {\n    let section = null;\n    let subsection = null;\n    this.parsedConfig = text.split('\\n').map(line => {\n      let name = null;\n      let value = null;\n\n      const trimmedLine = line.trim();\n      const extractedSection = extractSectionLine(trimmedLine);\n      const isSection = extractedSection != null;\n      if (isSection) {\n        ;[section, subsection] = extractedSection;\n      } else {\n        const extractedVariable = extractVariableLine(trimmedLine);\n        const isVariable = extractedVariable != null;\n        if (isVariable) {\n          ;[name, value] = extractedVariable;\n        }\n      }\n\n      const path = getPath(section, subsection, name);\n      return { line, isSection, section, subsection, name, value, path }\n    });\n  }\n\n  static from(text) {\n    return new GitConfig(text)\n  }\n\n  async get(path, getall = false) {\n    const normalizedPath = normalizePath$1(path).path;\n    const allValues = this.parsedConfig\n      .filter(config => config.path === normalizedPath)\n      .map(({ section, name, value }) => {\n        const fn = schema[section] && schema[section][name];\n        return fn ? fn(value) : value\n      });\n    return getall ? allValues : allValues.pop()\n  }\n\n  async getall(path) {\n    return this.get(path, true)\n  }\n\n  async getSubsections(section) {\n    return this.parsedConfig\n      .filter(config => config.section === section && config.isSection)\n      .map(config => config.subsection)\n  }\n\n  async deleteSection(section, subsection) {\n    this.parsedConfig = this.parsedConfig.filter(\n      config =>\n        !(config.section === section && config.subsection === subsection)\n    );\n  }\n\n  async append(path, value) {\n    return this.set(path, value, true)\n  }\n\n  async set(path, value, append = false) {\n    const {\n      section,\n      subsection,\n      name,\n      path: normalizedPath,\n      sectionPath,\n    } = normalizePath$1(path);\n    const configIndex = findLastIndex(\n      this.parsedConfig,\n      config => config.path === normalizedPath\n    );\n    if (value == null) {\n      if (configIndex !== -1) {\n        this.parsedConfig.splice(configIndex, 1);\n      }\n    } else {\n      if (configIndex !== -1) {\n        const config = this.parsedConfig[configIndex];\n        // Name should be overwritten in case the casing changed\n        const modifiedConfig = Object.assign({}, config, {\n          name,\n          value,\n          modified: true,\n        });\n        if (append) {\n          this.parsedConfig.splice(configIndex + 1, 0, modifiedConfig);\n        } else {\n          this.parsedConfig[configIndex] = modifiedConfig;\n        }\n      } else {\n        const sectionIndex = this.parsedConfig.findIndex(\n          config => config.path === sectionPath\n        );\n        const newConfig = {\n          section,\n          subsection,\n          name,\n          value,\n          modified: true,\n          path: normalizedPath,\n        };\n        if (SECTION_REGEX.test(section) && VARIABLE_NAME_REGEX.test(name)) {\n          if (sectionIndex >= 0) {\n            // Reuse existing section\n            this.parsedConfig.splice(sectionIndex + 1, 0, newConfig);\n          } else {\n            // Add a new section\n            const newSection = {\n              section,\n              subsection,\n              modified: true,\n              path: sectionPath,\n            };\n            this.parsedConfig.push(newSection, newConfig);\n          }\n        }\n      }\n    }\n  }\n\n  toString() {\n    return this.parsedConfig\n      .map(({ line, section, subsection, name, value, modified = false }) => {\n        if (!modified) {\n          return line\n        }\n        if (name != null && value != null) {\n          if (typeof value === 'string' && /[#;]/.test(value)) {\n            // A `#` or `;` symbol denotes a comment, so we have to wrap it in double quotes\n            return `\\t${name} = \"${value}\"`\n          }\n          return `\\t${name} = ${value}`\n        }\n        if (subsection != null) {\n          return `[${section} \"${subsection}\"]`\n        }\n        return `[${section}]`\n      })\n      .join('\\n')\n  }\n}\n\nclass GitConfigManager {\n  static async get({ fs, gitdir }) {\n    // We can improve efficiency later if needed.\n    // TODO: read from full list of git config files\n    const text = await fs.read(`${gitdir}/config`, { encoding: 'utf8' });\n    return GitConfig.from(text)\n  }\n\n  static async save({ fs, gitdir, config }) {\n    // We can improve efficiency later if needed.\n    // TODO: handle saving to the correct global/user/repo location\n    await fs.write(`${gitdir}/config`, config.toString(), {\n      encoding: 'utf8',\n    });\n  }\n}\n\n// This is a convenience wrapper for reading and writing files in the 'refs' directory.\n\n// @see https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions\nconst refpaths = ref => [\n  `${ref}`,\n  `refs/${ref}`,\n  `refs/tags/${ref}`,\n  `refs/heads/${ref}`,\n  `refs/remotes/${ref}`,\n  `refs/remotes/${ref}/HEAD`,\n];\n\n// @see https://git-scm.com/docs/gitrepository-layout\nconst GIT_FILES = ['config', 'description', 'index', 'shallow', 'commondir'];\n\nclass GitRefManager {\n  static async updateRemoteRefs({\n    fs,\n    gitdir,\n    remote,\n    refs,\n    symrefs,\n    tags,\n    refspecs = undefined,\n    prune = false,\n    pruneTags = false,\n  }) {\n    // Validate input\n    for (const value of refs.values()) {\n      if (!value.match(/[0-9a-f]{40}/)) {\n        throw new InvalidOidError(value)\n      }\n    }\n    const config = await GitConfigManager.get({ fs, gitdir });\n    if (!refspecs) {\n      refspecs = await config.getall(`remote.${remote}.fetch`);\n      if (refspecs.length === 0) {\n        throw new NoRefspecError(remote)\n      }\n      // There's some interesting behavior with HEAD that doesn't follow the refspec.\n      refspecs.unshift(`+HEAD:refs/remotes/${remote}/HEAD`);\n    }\n    const refspec = GitRefSpecSet.from(refspecs);\n    const actualRefsToWrite = new Map();\n    // Delete all current tags if the pruneTags argument is true.\n    if (pruneTags) {\n      const tags = await GitRefManager.listRefs({\n        fs,\n        gitdir,\n        filepath: 'refs/tags',\n      });\n      await GitRefManager.deleteRefs({\n        fs,\n        gitdir,\n        refs: tags.map(tag => `refs/tags/${tag}`),\n      });\n    }\n    // Add all tags if the fetch tags argument is true.\n    if (tags) {\n      for (const serverRef of refs.keys()) {\n        if (serverRef.startsWith('refs/tags') && !serverRef.endsWith('^{}')) {\n          // Git's behavior is to only fetch tags that do not conflict with tags already present.\n          if (!(await GitRefManager.exists({ fs, gitdir, ref: serverRef }))) {\n            // Always use the object id of the tag itself, and not the peeled object id.\n            const oid = refs.get(serverRef);\n            actualRefsToWrite.set(serverRef, oid);\n          }\n        }\n      }\n    }\n    // Combine refs and symrefs giving symrefs priority\n    const refTranslations = refspec.translate([...refs.keys()]);\n    for (const [serverRef, translatedRef] of refTranslations) {\n      const value = refs.get(serverRef);\n      actualRefsToWrite.set(translatedRef, value);\n    }\n    const symrefTranslations = refspec.translate([...symrefs.keys()]);\n    for (const [serverRef, translatedRef] of symrefTranslations) {\n      const value = symrefs.get(serverRef);\n      const symtarget = refspec.translateOne(value);\n      if (symtarget) {\n        actualRefsToWrite.set(translatedRef, `ref: ${symtarget}`);\n      }\n    }\n    // If `prune` argument is true, clear out the existing local refspec roots\n    const pruned = [];\n    if (prune) {\n      for (const filepath of refspec.localNamespaces()) {\n        const refs = (\n          await GitRefManager.listRefs({\n            fs,\n            gitdir,\n            filepath,\n          })\n        ).map(file => `${filepath}/${file}`);\n        for (const ref of refs) {\n          if (!actualRefsToWrite.has(ref)) {\n            pruned.push(ref);\n          }\n        }\n      }\n      if (pruned.length > 0) {\n        await GitRefManager.deleteRefs({ fs, gitdir, refs: pruned });\n      }\n    }\n    // Update files\n    // TODO: For large repos with a history of thousands of pull requests\n    // (i.e. gitlab-ce) it would be vastly more efficient to write them\n    // to .git/packed-refs.\n    // The trick is to make sure we a) don't write a packed ref that is\n    // already shadowed by a loose ref and b) don't loose any refs already\n    // in packed-refs. Doing this efficiently may be difficult. A\n    // solution that might work is\n    // a) load the current packed-refs file\n    // b) add actualRefsToWrite, overriding the existing values if present\n    // c) enumerate all the loose refs currently in .git/refs/remotes/${remote}\n    // d) overwrite their value with the new value.\n    // Examples of refs we need to avoid writing in loose format for efficieny's sake\n    // are .git/refs/remotes/origin/refs/remotes/remote_mirror_3059\n    // and .git/refs/remotes/origin/refs/merge-requests\n    for (const [key, value] of actualRefsToWrite) {\n      await fs.write(join(gitdir, key), `${value.trim()}\\n`, 'utf8');\n    }\n    return { pruned }\n  }\n\n  // TODO: make this less crude?\n  static async writeRef({ fs, gitdir, ref, value }) {\n    // Validate input\n    if (!value.match(/[0-9a-f]{40}/)) {\n      throw new InvalidOidError(value)\n    }\n    await fs.write(join(gitdir, ref), `${value.trim()}\\n`, 'utf8');\n  }\n\n  static async writeSymbolicRef({ fs, gitdir, ref, value }) {\n    await fs.write(join(gitdir, ref), 'ref: ' + `${value.trim()}\\n`, 'utf8');\n  }\n\n  static async deleteRef({ fs, gitdir, ref }) {\n    return GitRefManager.deleteRefs({ fs, gitdir, refs: [ref] })\n  }\n\n  static async deleteRefs({ fs, gitdir, refs }) {\n    // Delete regular ref\n    await Promise.all(refs.map(ref => fs.rm(join(gitdir, ref))));\n    // Delete any packed ref\n    let text = await fs.read(`${gitdir}/packed-refs`, { encoding: 'utf8' });\n    const packed = GitPackedRefs.from(text);\n    const beforeSize = packed.refs.size;\n    for (const ref of refs) {\n      if (packed.refs.has(ref)) {\n        packed.delete(ref);\n      }\n    }\n    if (packed.refs.size < beforeSize) {\n      text = packed.toString();\n      await fs.write(`${gitdir}/packed-refs`, text, { encoding: 'utf8' });\n    }\n  }\n\n  /**\n   * @param {object} args\n   * @param {import('../models/FileSystem.js').FileSystem} args.fs\n   * @param {string} args.gitdir\n   * @param {string} args.ref\n   * @param {number} [args.depth]\n   * @returns {Promise<string>}\n   */\n  static async resolve({ fs, gitdir, ref, depth = undefined }) {\n    if (depth !== undefined) {\n      depth--;\n      if (depth === -1) {\n        return ref\n      }\n    }\n    let sha;\n    // Is it a ref pointer?\n    if (ref.startsWith('ref: ')) {\n      ref = ref.slice('ref: '.length);\n      return GitRefManager.resolve({ fs, gitdir, ref, depth })\n    }\n    // Is it a complete and valid SHA?\n    if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {\n      return ref\n    }\n    // We need to alternate between the file system and the packed-refs\n    const packedMap = await GitRefManager.packedRefs({ fs, gitdir });\n    // Look in all the proper paths, in this order\n    const allpaths = refpaths(ref).filter(p => !GIT_FILES.includes(p)); // exclude git system files (#709)\n\n    for (const ref of allpaths) {\n      sha =\n        (await fs.read(`${gitdir}/${ref}`, { encoding: 'utf8' })) ||\n        packedMap.get(ref);\n      if (sha) {\n        return GitRefManager.resolve({ fs, gitdir, ref: sha.trim(), depth })\n      }\n    }\n    // Do we give up?\n    throw new NotFoundError(ref)\n  }\n\n  static async exists({ fs, gitdir, ref }) {\n    try {\n      await GitRefManager.expand({ fs, gitdir, ref });\n      return true\n    } catch (err) {\n      return false\n    }\n  }\n\n  static async expand({ fs, gitdir, ref }) {\n    // Is it a complete and valid SHA?\n    if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {\n      return ref\n    }\n    // We need to alternate between the file system and the packed-refs\n    const packedMap = await GitRefManager.packedRefs({ fs, gitdir });\n    // Look in all the proper paths, in this order\n    const allpaths = refpaths(ref);\n    for (const ref of allpaths) {\n      if (await fs.exists(`${gitdir}/${ref}`)) return ref\n      if (packedMap.has(ref)) return ref\n    }\n    // Do we give up?\n    throw new NotFoundError(ref)\n  }\n\n  static async expandAgainstMap({ ref, map }) {\n    // Look in all the proper paths, in this order\n    const allpaths = refpaths(ref);\n    for (const ref of allpaths) {\n      if (await map.has(ref)) return ref\n    }\n    // Do we give up?\n    throw new NotFoundError(ref)\n  }\n\n  static resolveAgainstMap({ ref, fullref = ref, depth = undefined, map }) {\n    if (depth !== undefined) {\n      depth--;\n      if (depth === -1) {\n        return { fullref, oid: ref }\n      }\n    }\n    // Is it a ref pointer?\n    if (ref.startsWith('ref: ')) {\n      ref = ref.slice('ref: '.length);\n      return GitRefManager.resolveAgainstMap({ ref, fullref, depth, map })\n    }\n    // Is it a complete and valid SHA?\n    if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {\n      return { fullref, oid: ref }\n    }\n    // Look in all the proper paths, in this order\n    const allpaths = refpaths(ref);\n    for (const ref of allpaths) {\n      const sha = map.get(ref);\n      if (sha) {\n        return GitRefManager.resolveAgainstMap({\n          ref: sha.trim(),\n          fullref: ref,\n          depth,\n          map,\n        })\n      }\n    }\n    // Do we give up?\n    throw new NotFoundError(ref)\n  }\n\n  static async packedRefs({ fs, gitdir }) {\n    const text = await fs.read(`${gitdir}/packed-refs`, { encoding: 'utf8' });\n    const packed = GitPackedRefs.from(text);\n    return packed.refs\n  }\n\n  // List all the refs that match the `filepath` prefix\n  static async listRefs({ fs, gitdir, filepath }) {\n    const packedMap = GitRefManager.packedRefs({ fs, gitdir });\n    let files = null;\n    try {\n      files = await fs.readdirDeep(`${gitdir}/${filepath}`);\n      files = files.map(x => x.replace(`${gitdir}/${filepath}/`, ''));\n    } catch (err) {\n      files = [];\n    }\n\n    for (let key of (await packedMap).keys()) {\n      // filter by prefix\n      if (key.startsWith(filepath)) {\n        // remove prefix\n        key = key.replace(filepath + '/', '');\n        // Don't include duplicates; the loose files have precedence anyway\n        if (!files.includes(key)) {\n          files.push(key);\n        }\n      }\n    }\n    // since we just appended things onto an array, we need to sort them now\n    files.sort(compareRefNames);\n    return files\n  }\n\n  static async listBranches({ fs, gitdir, remote }) {\n    if (remote) {\n      return GitRefManager.listRefs({\n        fs,\n        gitdir,\n        filepath: `refs/remotes/${remote}`,\n      })\n    } else {\n      return GitRefManager.listRefs({ fs, gitdir, filepath: `refs/heads` })\n    }\n  }\n\n  static async listTags({ fs, gitdir }) {\n    const tags = await GitRefManager.listRefs({\n      fs,\n      gitdir,\n      filepath: `refs/tags`,\n    });\n    return tags.filter(x => !x.endsWith('^{}'))\n  }\n}\n\nfunction compareTreeEntryPath(a, b) {\n  // Git sorts tree entries as if there is a trailing slash on directory names.\n  return compareStrings(appendSlashIfDir(a), appendSlashIfDir(b))\n}\n\nfunction appendSlashIfDir(entry) {\n  return entry.mode === '040000' ? entry.path + '/' : entry.path\n}\n\n/**\n *\n * @typedef {Object} TreeEntry\n * @property {string} mode - the 6 digit hexadecimal mode\n * @property {string} path - the name of the file or directory\n * @property {string} oid - the SHA-1 object id of the blob or tree\n * @property {'commit'|'blob'|'tree'} type - the type of object\n */\n\nfunction mode2type$1(mode) {\n  // prettier-ignore\n  switch (mode) {\n    case '040000': return 'tree'\n    case '100644': return 'blob'\n    case '100755': return 'blob'\n    case '120000': return 'blob'\n    case '160000': return 'commit'\n  }\n  throw new InternalError(`Unexpected GitTree entry mode: ${mode}`)\n}\n\nfunction parseBuffer(buffer) {\n  const _entries = [];\n  let cursor = 0;\n  while (cursor < buffer.length) {\n    const space = buffer.indexOf(32, cursor);\n    if (space === -1) {\n      throw new InternalError(\n        `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next space character.`\n      )\n    }\n    const nullchar = buffer.indexOf(0, cursor);\n    if (nullchar === -1) {\n      throw new InternalError(\n        `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next null character.`\n      )\n    }\n    let mode = buffer.slice(cursor, space).toString('utf8');\n    if (mode === '40000') mode = '040000'; // makes it line up neater in printed output\n    const type = mode2type$1(mode);\n    const path = buffer.slice(space + 1, nullchar).toString('utf8');\n\n    // Prevent malicious git repos from writing to \"..\\foo\" on clone etc\n    if (path.includes('\\\\') || path.includes('/')) {\n      throw new UnsafeFilepathError(path)\n    }\n\n    const oid = buffer.slice(nullchar + 1, nullchar + 21).toString('hex');\n    cursor = nullchar + 21;\n    _entries.push({ mode, path, oid, type });\n  }\n  return _entries\n}\n\nfunction limitModeToAllowed(mode) {\n  if (typeof mode === 'number') {\n    mode = mode.toString(8);\n  }\n  // tree\n  if (mode.match(/^0?4.*/)) return '040000' // Directory\n  if (mode.match(/^1006.*/)) return '100644' // Regular non-executable file\n  if (mode.match(/^1007.*/)) return '100755' // Regular executable file\n  if (mode.match(/^120.*/)) return '120000' // Symbolic link\n  if (mode.match(/^160.*/)) return '160000' // Commit (git submodule reference)\n  throw new InternalError(`Could not understand file mode: ${mode}`)\n}\n\nfunction nudgeIntoShape(entry) {\n  if (!entry.oid && entry.sha) {\n    entry.oid = entry.sha; // Github\n  }\n  entry.mode = limitModeToAllowed(entry.mode); // index\n  if (!entry.type) {\n    entry.type = mode2type$1(entry.mode); // index\n  }\n  return entry\n}\n\nclass GitTree {\n  constructor(entries) {\n    if (Buffer.isBuffer(entries)) {\n      this._entries = parseBuffer(entries);\n    } else if (Array.isArray(entries)) {\n      this._entries = entries.map(nudgeIntoShape);\n    } else {\n      throw new InternalError('invalid type passed to GitTree constructor')\n    }\n    // Tree entries are not sorted alphabetically in the usual sense (see `compareTreeEntryPath`)\n    // but it is important later on that these be sorted in the same order as they would be returned from readdir.\n    this._entries.sort(comparePath);\n  }\n\n  static from(tree) {\n    return new GitTree(tree)\n  }\n\n  render() {\n    return this._entries\n      .map(entry => `${entry.mode} ${entry.type} ${entry.oid}    ${entry.path}`)\n      .join('\\n')\n  }\n\n  toObject() {\n    // Adjust the sort order to match git's\n    const entries = [...this._entries];\n    entries.sort(compareTreeEntryPath);\n    return Buffer.concat(\n      entries.map(entry => {\n        const mode = Buffer.from(entry.mode.replace(/^0/, ''));\n        const space = Buffer.from(' ');\n        const path = Buffer.from(entry.path, 'utf8');\n        const nullchar = Buffer.from([0]);\n        const oid = Buffer.from(entry.oid, 'hex');\n        return Buffer.concat([mode, space, path, nullchar, oid])\n      })\n    )\n  }\n\n  /**\n   * @returns {TreeEntry[]}\n   */\n  entries() {\n    return this._entries\n  }\n\n  *[Symbol.iterator]() {\n    for (const entry of this._entries) {\n      yield entry;\n    }\n  }\n}\n\nclass GitObject {\n  static wrap({ type, object }) {\n    return Buffer.concat([\n      Buffer.from(`${type} ${object.byteLength.toString()}\\x00`),\n      Buffer.from(object),\n    ])\n  }\n\n  static unwrap(buffer) {\n    const s = buffer.indexOf(32); // first space\n    const i = buffer.indexOf(0); // first null value\n    const type = buffer.slice(0, s).toString('utf8'); // get type of object\n    const length = buffer.slice(s + 1, i).toString('utf8'); // get type of object\n    const actualLength = buffer.length - (i + 1);\n    // verify length\n    if (parseInt(length) !== actualLength) {\n      throw new InternalError(\n        `Length mismatch: expected ${length} bytes but got ${actualLength} instead.`\n      )\n    }\n    return {\n      type,\n      object: Buffer.from(buffer.slice(i + 1)),\n    }\n  }\n}\n\nasync function readObjectLoose({ fs, gitdir, oid }) {\n  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;\n  const file = await fs.read(`${gitdir}/${source}`);\n  if (!file) {\n    return null\n  }\n  return { object: file, format: 'deflated', source }\n}\n\n/**\n * @param {Buffer} delta\n * @param {Buffer} source\n * @returns {Buffer}\n */\nfunction applyDelta(delta, source) {\n  const reader = new BufferCursor(delta);\n  const sourceSize = readVarIntLE(reader);\n\n  if (sourceSize !== source.byteLength) {\n    throw new InternalError(\n      `applyDelta expected source buffer to be ${sourceSize} bytes but the provided buffer was ${source.length} bytes`\n    )\n  }\n  const targetSize = readVarIntLE(reader);\n  let target;\n\n  const firstOp = readOp(reader, source);\n  // Speed optimization - return raw buffer if it's just single simple copy\n  if (firstOp.byteLength === targetSize) {\n    target = firstOp;\n  } else {\n    // Otherwise, allocate a fresh buffer and slices\n    target = Buffer.alloc(targetSize);\n    const writer = new BufferCursor(target);\n    writer.copy(firstOp);\n\n    while (!reader.eof()) {\n      writer.copy(readOp(reader, source));\n    }\n\n    const tell = writer.tell();\n    if (targetSize !== tell) {\n      throw new InternalError(\n        `applyDelta expected target buffer to be ${targetSize} bytes but the resulting buffer was ${tell} bytes`\n      )\n    }\n  }\n  return target\n}\n\nfunction readVarIntLE(reader) {\n  let result = 0;\n  let shift = 0;\n  let byte = null;\n  do {\n    byte = reader.readUInt8();\n    result |= (byte & 0b01111111) << shift;\n    shift += 7;\n  } while (byte & 0b10000000)\n  return result\n}\n\nfunction readCompactLE(reader, flags, size) {\n  let result = 0;\n  let shift = 0;\n  while (size--) {\n    if (flags & 0b00000001) {\n      result |= reader.readUInt8() << shift;\n    }\n    flags >>= 1;\n    shift += 8;\n  }\n  return result\n}\n\nfunction readOp(reader, source) {\n  /** @type {number} */\n  const byte = reader.readUInt8();\n  const COPY = 0b10000000;\n  const OFFS = 0b00001111;\n  const SIZE = 0b01110000;\n  if (byte & COPY) {\n    // copy consists of 4 byte offset, 3 byte size (in LE order)\n    const offset = readCompactLE(reader, byte & OFFS, 4);\n    let size = readCompactLE(reader, (byte & SIZE) >> 4, 3);\n    // Yup. They really did this optimization.\n    if (size === 0) size = 0x10000;\n    return source.slice(offset, offset + size)\n  } else {\n    // insert\n    return reader.slice(byte)\n  }\n}\n\n// Convert a value to an Async Iterator\n// This will be easier with async generator functions.\nfunction fromValue(value) {\n  let queue = [value];\n  return {\n    next() {\n      return Promise.resolve({ done: queue.length === 0, value: queue.pop() })\n    },\n    return() {\n      queue = [];\n      return {}\n    },\n    [Symbol.asyncIterator]() {\n      return this\n    },\n  }\n}\n\nfunction getIterator(iterable) {\n  if (iterable[Symbol.asyncIterator]) {\n    return iterable[Symbol.asyncIterator]()\n  }\n  if (iterable[Symbol.iterator]) {\n    return iterable[Symbol.iterator]()\n  }\n  if (iterable.next) {\n    return iterable\n  }\n  return fromValue(iterable)\n}\n\n// inspired by 'gartal' but lighter-weight and more battle-tested.\nclass StreamReader {\n  constructor(stream) {\n    this.stream = getIterator(stream);\n    this.buffer = null;\n    this.cursor = 0;\n    this.undoCursor = 0;\n    this.started = false;\n    this._ended = false;\n    this._discardedBytes = 0;\n  }\n\n  eof() {\n    return this._ended && this.cursor === this.buffer.length\n  }\n\n  tell() {\n    return this._discardedBytes + this.cursor\n  }\n\n  async byte() {\n    if (this.eof()) return\n    if (!this.started) await this._init();\n    if (this.cursor === this.buffer.length) {\n      await this._loadnext();\n      if (this._ended) return\n    }\n    this._moveCursor(1);\n    return this.buffer[this.undoCursor]\n  }\n\n  async chunk() {\n    if (this.eof()) return\n    if (!this.started) await this._init();\n    if (this.cursor === this.buffer.length) {\n      await this._loadnext();\n      if (this._ended) return\n    }\n    this._moveCursor(this.buffer.length);\n    return this.buffer.slice(this.undoCursor, this.cursor)\n  }\n\n  async read(n) {\n    if (this.eof()) return\n    if (!this.started) await this._init();\n    if (this.cursor + n > this.buffer.length) {\n      this._trim();\n      await this._accumulate(n);\n    }\n    this._moveCursor(n);\n    return this.buffer.slice(this.undoCursor, this.cursor)\n  }\n\n  async skip(n) {\n    if (this.eof()) return\n    if (!this.started) await this._init();\n    if (this.cursor + n > this.buffer.length) {\n      this._trim();\n      await this._accumulate(n);\n    }\n    this._moveCursor(n);\n  }\n\n  async undo() {\n    this.cursor = this.undoCursor;\n  }\n\n  async _next() {\n    this.started = true;\n    let { done, value } = await this.stream.next();\n    if (done) {\n      this._ended = true;\n    }\n    if (value) {\n      value = Buffer.from(value);\n    }\n    return value\n  }\n\n  _trim() {\n    // Throw away parts of the buffer we don't need anymore\n    // assert(this.cursor <= this.buffer.length)\n    this.buffer = this.buffer.slice(this.undoCursor);\n    this.cursor -= this.undoCursor;\n    this._discardedBytes += this.undoCursor;\n    this.undoCursor = 0;\n  }\n\n  _moveCursor(n) {\n    this.undoCursor = this.cursor;\n    this.cursor += n;\n    if (this.cursor > this.buffer.length) {\n      this.cursor = this.buffer.length;\n    }\n  }\n\n  async _accumulate(n) {\n    if (this._ended) return\n    // Expand the buffer until we have N bytes of data\n    // or we've reached the end of the stream\n    const buffers = [this.buffer];\n    while (this.cursor + n > lengthBuffers(buffers)) {\n      const nextbuffer = await this._next();\n      if (this._ended) break\n      buffers.push(nextbuffer);\n    }\n    this.buffer = Buffer.concat(buffers);\n  }\n\n  async _loadnext() {\n    this._discardedBytes += this.buffer.length;\n    this.undoCursor = 0;\n    this.cursor = 0;\n    this.buffer = await this._next();\n  }\n\n  async _init() {\n    this.buffer = await this._next();\n  }\n}\n\n// This helper function helps us postpone concatenating buffers, which\n// would create intermediate buffer objects,\nfunction lengthBuffers(buffers) {\n  return buffers.reduce((acc, buffer) => acc + buffer.length, 0)\n}\n\n// My version of git-list-pack - roughly 15x faster than the original\n\nasync function listpack(stream, onData) {\n  const reader = new StreamReader(stream);\n  let PACK = await reader.read(4);\n  PACK = PACK.toString('utf8');\n  if (PACK !== 'PACK') {\n    throw new InternalError(`Invalid PACK header '${PACK}'`)\n  }\n\n  let version = await reader.read(4);\n  version = version.readUInt32BE(0);\n  if (version !== 2) {\n    throw new InternalError(`Invalid packfile version: ${version}`)\n  }\n\n  let numObjects = await reader.read(4);\n  numObjects = numObjects.readUInt32BE(0);\n  // If (for some godforsaken reason) this is an empty packfile, abort now.\n  if (numObjects < 1) return\n\n  while (!reader.eof() && numObjects--) {\n    const offset = reader.tell();\n    const { type, length, ofs, reference } = await parseHeader(reader);\n    const inflator = new pako.Inflate();\n    while (!inflator.result) {\n      const chunk = await reader.chunk();\n      if (!chunk) break\n      inflator.push(chunk, false);\n      if (inflator.err) {\n        throw new InternalError(`Pako error: ${inflator.msg}`)\n      }\n      if (inflator.result) {\n        if (inflator.result.length !== length) {\n          throw new InternalError(\n            `Inflated object size is different from that stated in packfile.`\n          )\n        }\n\n        // Backtrack parser to where deflated data ends\n        await reader.undo();\n        await reader.read(chunk.length - inflator.strm.avail_in);\n        const end = reader.tell();\n        await onData({\n          data: inflator.result,\n          type,\n          num: numObjects,\n          offset,\n          end,\n          reference,\n          ofs,\n        });\n      }\n    }\n  }\n}\n\nasync function parseHeader(reader) {\n  // Object type is encoded in bits 654\n  let byte = await reader.byte();\n  const type = (byte >> 4) & 0b111;\n  // The length encoding get complicated.\n  // Last four bits of length is encoded in bits 3210\n  let length = byte & 0b1111;\n  // Whether the next byte is part of the variable-length encoded number\n  // is encoded in bit 7\n  if (byte & 0b10000000) {\n    let shift = 4;\n    do {\n      byte = await reader.byte();\n      length |= (byte & 0b01111111) << shift;\n      shift += 7;\n    } while (byte & 0b10000000)\n  }\n  // Handle deltified objects\n  let ofs;\n  let reference;\n  if (type === 6) {\n    let shift = 0;\n    ofs = 0;\n    const bytes = [];\n    do {\n      byte = await reader.byte();\n      ofs |= (byte & 0b01111111) << shift;\n      shift += 7;\n      bytes.push(byte);\n    } while (byte & 0b10000000)\n    reference = Buffer.from(bytes);\n  }\n  if (type === 7) {\n    const buf = await reader.read(20);\n    reference = buf;\n  }\n  return { type, length, ofs, reference }\n}\n\n/* eslint-env node, browser */\n\nlet supportsDecompressionStream = false;\n\nasync function inflate(buffer) {\n  if (supportsDecompressionStream === null) {\n    supportsDecompressionStream = testDecompressionStream();\n  }\n  return supportsDecompressionStream\n    ? browserInflate(buffer)\n    : pako.inflate(buffer)\n}\n\nasync function browserInflate(buffer) {\n  const ds = new DecompressionStream('deflate');\n  const d = new Blob([buffer]).stream().pipeThrough(ds);\n  return new Uint8Array(await new Response(d).arrayBuffer())\n}\n\nfunction testDecompressionStream() {\n  try {\n    const ds = new DecompressionStream('deflate');\n    if (ds) return true\n  } catch (_) {\n    // no bother\n  }\n  return false\n}\n\nfunction decodeVarInt(reader) {\n  const bytes = [];\n  let byte = 0;\n  let multibyte = 0;\n  do {\n    byte = reader.readUInt8();\n    // We keep bits 6543210\n    const lastSeven = byte & 0b01111111;\n    bytes.push(lastSeven);\n    // Whether the next byte is part of the variable-length encoded number\n    // is encoded in bit 7\n    multibyte = byte & 0b10000000;\n  } while (multibyte)\n  // Now that all the bytes are in big-endian order,\n  // alternate shifting the bits left by 7 and OR-ing the next byte.\n  // And... do a weird increment-by-one thing that I don't quite understand.\n  return bytes.reduce((a, b) => ((a + 1) << 7) | b, -1)\n}\n\n// I'm pretty much copying this one from the git C source code,\n// because it makes no sense.\nfunction otherVarIntDecode(reader, startWith) {\n  let result = startWith;\n  let shift = 4;\n  let byte = null;\n  do {\n    byte = reader.readUInt8();\n    result |= (byte & 0b01111111) << shift;\n    shift += 7;\n  } while (byte & 0b10000000)\n  return result\n}\n\nclass GitPackIndex {\n  constructor(stuff) {\n    Object.assign(this, stuff);\n    this.offsetCache = {};\n  }\n\n  static async fromIdx({ idx, getExternalRefDelta }) {\n    const reader = new BufferCursor(idx);\n    const magic = reader.slice(4).toString('hex');\n    // Check for IDX v2 magic number\n    if (magic !== 'ff744f63') {\n      return // undefined\n    }\n    const version = reader.readUInt32BE();\n    if (version !== 2) {\n      throw new InternalError(\n        `Unable to read version ${version} packfile IDX. (Only version 2 supported)`\n      )\n    }\n    if (idx.byteLength > 2048 * 1024 * 1024) {\n      throw new InternalError(\n        `To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.`\n      )\n    }\n    // Skip over fanout table\n    reader.seek(reader.tell() + 4 * 255);\n    // Get hashes\n    const size = reader.readUInt32BE();\n    const hashes = [];\n    for (let i = 0; i < size; i++) {\n      const hash = reader.slice(20).toString('hex');\n      hashes[i] = hash;\n    }\n    reader.seek(reader.tell() + 4 * size);\n    // Skip over CRCs\n    // Get offsets\n    const offsets = new Map();\n    for (let i = 0; i < size; i++) {\n      offsets.set(hashes[i], reader.readUInt32BE());\n    }\n    const packfileSha = reader.slice(20).toString('hex');\n    return new GitPackIndex({\n      hashes,\n      crcs: {},\n      offsets,\n      packfileSha,\n      getExternalRefDelta,\n    })\n  }\n\n  static async fromPack({ pack, getExternalRefDelta, onProgress }) {\n    const listpackTypes = {\n      1: 'commit',\n      2: 'tree',\n      3: 'blob',\n      4: 'tag',\n      6: 'ofs-delta',\n      7: 'ref-delta',\n    };\n    const offsetToObject = {};\n\n    // Older packfiles do NOT use the shasum of the pack itself,\n    // so it is recommended to just use whatever bytes are in the trailer.\n    // Source: https://github.com/git/git/commit/1190a1acf800acdcfd7569f87ac1560e2d077414\n    const packfileSha = pack.slice(-20).toString('hex');\n\n    const hashes = [];\n    const crcs = {};\n    const offsets = new Map();\n    let totalObjectCount = null;\n    let lastPercent = null;\n\n    await listpack([pack], async ({ data, type, reference, offset, num }) => {\n      if (totalObjectCount === null) totalObjectCount = num;\n      const percent = Math.floor(\n        ((totalObjectCount - num) * 100) / totalObjectCount\n      );\n      if (percent !== lastPercent) {\n        if (onProgress) {\n          await onProgress({\n            phase: 'Receiving objects',\n            loaded: totalObjectCount - num,\n            total: totalObjectCount,\n          });\n        }\n      }\n      lastPercent = percent;\n      // Change type from a number to a meaningful string\n      type = listpackTypes[type];\n\n      if (['commit', 'tree', 'blob', 'tag'].includes(type)) {\n        offsetToObject[offset] = {\n          type,\n          offset,\n        };\n      } else if (type === 'ofs-delta') {\n        offsetToObject[offset] = {\n          type,\n          offset,\n        };\n      } else if (type === 'ref-delta') {\n        offsetToObject[offset] = {\n          type,\n          offset,\n        };\n      }\n    });\n\n    // We need to know the lengths of the slices to compute the CRCs.\n    const offsetArray = Object.keys(offsetToObject).map(Number);\n    for (const [i, start] of offsetArray.entries()) {\n      const end =\n        i + 1 === offsetArray.length ? pack.byteLength - 20 : offsetArray[i + 1];\n      const o = offsetToObject[start];\n      const crc = crc32.buf(pack.slice(start, end)) >>> 0;\n      o.end = end;\n      o.crc = crc;\n    }\n\n    // We don't have the hashes yet. But we can generate them using the .readSlice function!\n    const p = new GitPackIndex({\n      pack: Promise.resolve(pack),\n      packfileSha,\n      crcs,\n      hashes,\n      offsets,\n      getExternalRefDelta,\n    });\n\n    // Resolve deltas and compute the oids\n    lastPercent = null;\n    let count = 0;\n    const objectsByDepth = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    for (let offset in offsetToObject) {\n      offset = Number(offset);\n      const percent = Math.floor((count * 100) / totalObjectCount);\n      if (percent !== lastPercent) {\n        if (onProgress) {\n          await onProgress({\n            phase: 'Resolving deltas',\n            loaded: count,\n            total: totalObjectCount,\n          });\n        }\n      }\n      count++;\n      lastPercent = percent;\n\n      const o = offsetToObject[offset];\n      if (o.oid) continue\n      try {\n        p.readDepth = 0;\n        p.externalReadDepth = 0;\n        const { type, object } = await p.readSlice({ start: offset });\n        objectsByDepth[p.readDepth] += 1;\n        const oid = await shasum(GitObject.wrap({ type, object }));\n        o.oid = oid;\n        hashes.push(oid);\n        offsets.set(oid, offset);\n        crcs[oid] = o.crc;\n      } catch (err) {\n        continue\n      }\n    }\n\n    hashes.sort();\n    return p\n  }\n\n  async toBuffer() {\n    const buffers = [];\n    const write = (str, encoding) => {\n      buffers.push(Buffer.from(str, encoding));\n    };\n    // Write out IDX v2 magic number\n    write('ff744f63', 'hex');\n    // Write out version number 2\n    write('00000002', 'hex');\n    // Write fanout table\n    const fanoutBuffer = new BufferCursor(Buffer.alloc(256 * 4));\n    for (let i = 0; i < 256; i++) {\n      let count = 0;\n      for (const hash of this.hashes) {\n        if (parseInt(hash.slice(0, 2), 16) <= i) count++;\n      }\n      fanoutBuffer.writeUInt32BE(count);\n    }\n    buffers.push(fanoutBuffer.buffer);\n    // Write out hashes\n    for (const hash of this.hashes) {\n      write(hash, 'hex');\n    }\n    // Write out crcs\n    const crcsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length * 4));\n    for (const hash of this.hashes) {\n      crcsBuffer.writeUInt32BE(this.crcs[hash]);\n    }\n    buffers.push(crcsBuffer.buffer);\n    // Write out offsets\n    const offsetsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length * 4));\n    for (const hash of this.hashes) {\n      offsetsBuffer.writeUInt32BE(this.offsets.get(hash));\n    }\n    buffers.push(offsetsBuffer.buffer);\n    // Write out packfile checksum\n    write(this.packfileSha, 'hex');\n    // Write out shasum\n    const totalBuffer = Buffer.concat(buffers);\n    const sha = await shasum(totalBuffer);\n    const shaBuffer = Buffer.alloc(20);\n    shaBuffer.write(sha, 'hex');\n    return Buffer.concat([totalBuffer, shaBuffer])\n  }\n\n  async load({ pack }) {\n    this.pack = pack;\n  }\n\n  async unload() {\n    this.pack = null;\n  }\n\n  async read({ oid }) {\n    if (!this.offsets.get(oid)) {\n      if (this.getExternalRefDelta) {\n        this.externalReadDepth++;\n        return this.getExternalRefDelta(oid)\n      } else {\n        throw new InternalError(`Could not read object ${oid} from packfile`)\n      }\n    }\n    const start = this.offsets.get(oid);\n    return this.readSlice({ start })\n  }\n\n  async readSlice({ start }) {\n    if (this.offsetCache[start]) {\n      return Object.assign({}, this.offsetCache[start])\n    }\n    this.readDepth++;\n    const types = {\n      0b0010000: 'commit',\n      0b0100000: 'tree',\n      0b0110000: 'blob',\n      0b1000000: 'tag',\n      0b1100000: 'ofs_delta',\n      0b1110000: 'ref_delta',\n    };\n    if (!this.pack) {\n      throw new InternalError(\n        'Tried to read from a GitPackIndex with no packfile loaded into memory'\n      )\n    }\n    const raw = (await this.pack).slice(start);\n    const reader = new BufferCursor(raw);\n    const byte = reader.readUInt8();\n    // Object type is encoded in bits 654\n    const btype = byte & 0b1110000;\n    let type = types[btype];\n    if (type === undefined) {\n      throw new InternalError('Unrecognized type: 0b' + btype.toString(2))\n    }\n    // The length encoding get complicated.\n    // Last four bits of length is encoded in bits 3210\n    const lastFour = byte & 0b1111;\n    let length = lastFour;\n    // Whether the next byte is part of the variable-length encoded number\n    // is encoded in bit 7\n    const multibyte = byte & 0b10000000;\n    if (multibyte) {\n      length = otherVarIntDecode(reader, lastFour);\n    }\n    let base = null;\n    let object = null;\n    // Handle deltified objects\n    if (type === 'ofs_delta') {\n      const offset = decodeVarInt(reader);\n      const baseOffset = start - offset\n      ;({ object: base, type } = await this.readSlice({ start: baseOffset }));\n    }\n    if (type === 'ref_delta') {\n      const oid = reader.slice(20).toString('hex')\n      ;({ object: base, type } = await this.read({ oid }));\n    }\n    // Handle undeltified objects\n    const buffer = raw.slice(reader.tell());\n    object = Buffer.from(await inflate(buffer));\n    // Assert that the object length is as expected.\n    if (object.byteLength !== length) {\n      throw new InternalError(\n        `Packfile told us object would have length ${length} but it had length ${object.byteLength}`\n      )\n    }\n    if (base) {\n      object = Buffer.from(applyDelta(object, base));\n    }\n    // Cache the result based on depth.\n    if (this.readDepth > 3) {\n      // hand tuned for speed / memory usage tradeoff\n      this.offsetCache[start] = { type, object };\n    }\n    return { type, format: 'content', object }\n  }\n}\n\nconst PackfileCache = Symbol('PackfileCache');\n\nasync function loadPackIndex({\n  fs,\n  filename,\n  getExternalRefDelta,\n  emitter,\n  emitterPrefix,\n}) {\n  const idx = await fs.read(filename);\n  return GitPackIndex.fromIdx({ idx, getExternalRefDelta })\n}\n\nfunction readPackIndex({\n  fs,\n  cache,\n  filename,\n  getExternalRefDelta,\n  emitter,\n  emitterPrefix,\n}) {\n  // Try to get the packfile index from the in-memory cache\n  if (!cache[PackfileCache]) cache[PackfileCache] = new Map();\n  let p = cache[PackfileCache].get(filename);\n  if (!p) {\n    p = loadPackIndex({\n      fs,\n      filename,\n      getExternalRefDelta,\n      emitter,\n      emitterPrefix,\n    });\n    cache[PackfileCache].set(filename, p);\n  }\n  return p\n}\n\nasync function readObjectPacked({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  format = 'content',\n  getExternalRefDelta,\n}) {\n  // Check to see if it's in a packfile.\n  // Iterate through all the .idx files\n  let list = await fs.readdir(join(gitdir, 'objects/pack'));\n  list = list.filter(x => x.endsWith('.idx'));\n  for (const filename of list) {\n    const indexFile = `${gitdir}/objects/pack/${filename}`;\n    const p = await readPackIndex({\n      fs,\n      cache,\n      filename: indexFile,\n      getExternalRefDelta,\n    });\n    if (p.error) throw new InternalError(p.error)\n    // If the packfile DOES have the oid we're looking for...\n    if (p.offsets.has(oid)) {\n      // Get the resolved git object from the packfile\n      if (!p.pack) {\n        const packFile = indexFile.replace(/idx$/, 'pack');\n        p.pack = fs.read(packFile);\n      }\n      const result = await p.read({ oid, getExternalRefDelta });\n      result.format = 'content';\n      result.source = `objects/pack/${filename.replace(/idx$/, 'pack')}`;\n      return result\n    }\n  }\n  // Failed to find it\n  return null\n}\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} args.oid\n * @param {string} [args.format]\n */\nasync function _readObject({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  format = 'content',\n}) {\n  // Curry the current read method so that the packfile un-deltification\n  // process can acquire external ref-deltas.\n  const getExternalRefDelta = oid => _readObject({ fs, cache, gitdir, oid });\n\n  let result;\n  // Empty tree - hard-coded so we can use it as a shorthand.\n  // Note: I think the canonical git implementation must do this too because\n  // `git cat-file -t 4b825dc642cb6eb9a060e54bf8d69288fbee4904` prints \"tree\" even in empty repos.\n  if (oid === '4b825dc642cb6eb9a060e54bf8d69288fbee4904') {\n    result = { format: 'wrapped', object: Buffer.from(`tree 0\\x00`) };\n  }\n  // Look for it in the loose object directory.\n  if (!result) {\n    result = await readObjectLoose({ fs, gitdir, oid });\n  }\n  // Check to see if it's in a packfile.\n  if (!result) {\n    result = await readObjectPacked({\n      fs,\n      cache,\n      gitdir,\n      oid,\n      getExternalRefDelta,\n    });\n  }\n  // Finally\n  if (!result) {\n    throw new NotFoundError(oid)\n  }\n\n  if (format === 'deflated') {\n    return result\n  }\n\n  if (result.format === 'deflated') {\n    result.object = Buffer.from(await inflate(result.object));\n    result.format = 'wrapped';\n  }\n\n  if (result.format === 'wrapped') {\n    if (format === 'wrapped' && result.format === 'wrapped') {\n      return result\n    }\n    const sha = await shasum(result.object);\n    if (sha !== oid) {\n      throw new InternalError(\n        `SHA check failed! Expected ${oid}, computed ${sha}`\n      )\n    }\n    const { object, type } = GitObject.unwrap(result.object);\n    result.type = type;\n    result.object = object;\n    result.format = 'content';\n  }\n\n  if (result.format === 'content') {\n    if (format === 'content') return result\n    return\n  }\n\n  throw new InternalError(`invalid format \"${result.format}\"`)\n}\n\nclass AlreadyExistsError extends BaseError {\n  /**\n   * @param {'note'|'remote'|'tag'|'branch'} noun\n   * @param {string} where\n   * @param {boolean} canForce\n   */\n  constructor(noun, where, canForce = true) {\n    super(\n      `Failed to create ${noun} at ${where} because it already exists.${\n        canForce\n          ? ` (Hint: use 'force: true' parameter to overwrite existing ${noun}.)`\n          : ''\n      }`\n    );\n    this.code = this.name = AlreadyExistsError.code;\n    this.data = { noun, where, canForce };\n  }\n}\n/** @type {'AlreadyExistsError'} */\nAlreadyExistsError.code = 'AlreadyExistsError';\n\nclass AmbiguousError extends BaseError {\n  /**\n   * @param {'oids'|'refs'} nouns\n   * @param {string} short\n   * @param {string[]} matches\n   */\n  constructor(nouns, short, matches) {\n    super(\n      `Found multiple ${nouns} matching \"${short}\" (${matches.join(\n        ', '\n      )}). Use a longer abbreviation length to disambiguate them.`\n    );\n    this.code = this.name = AmbiguousError.code;\n    this.data = { nouns, short, matches };\n  }\n}\n/** @type {'AmbiguousError'} */\nAmbiguousError.code = 'AmbiguousError';\n\nclass CheckoutConflictError extends BaseError {\n  /**\n   * @param {string[]} filepaths\n   */\n  constructor(filepaths) {\n    super(\n      `Your local changes to the following files would be overwritten by checkout: ${filepaths.join(\n        ', '\n      )}`\n    );\n    this.code = this.name = CheckoutConflictError.code;\n    this.data = { filepaths };\n  }\n}\n/** @type {'CheckoutConflictError'} */\nCheckoutConflictError.code = 'CheckoutConflictError';\n\nclass CommitNotFetchedError extends BaseError {\n  /**\n   * @param {string} ref\n   * @param {string} oid\n   */\n  constructor(ref, oid) {\n    super(\n      `Failed to checkout \"${ref}\" because commit ${oid} is not available locally. Do a git fetch to make the branch available locally.`\n    );\n    this.code = this.name = CommitNotFetchedError.code;\n    this.data = { ref, oid };\n  }\n}\n/** @type {'CommitNotFetchedError'} */\nCommitNotFetchedError.code = 'CommitNotFetchedError';\n\nclass EmptyServerResponseError extends BaseError {\n  constructor() {\n    super(`Empty response from git server.`);\n    this.code = this.name = EmptyServerResponseError.code;\n    this.data = {};\n  }\n}\n/** @type {'EmptyServerResponseError'} */\nEmptyServerResponseError.code = 'EmptyServerResponseError';\n\nclass FastForwardError extends BaseError {\n  constructor() {\n    super(`A simple fast-forward merge was not possible.`);\n    this.code = this.name = FastForwardError.code;\n    this.data = {};\n  }\n}\n/** @type {'FastForwardError'} */\nFastForwardError.code = 'FastForwardError';\n\nclass GitPushError extends BaseError {\n  /**\n   * @param {string} prettyDetails\n   * @param {PushResult} result\n   */\n  constructor(prettyDetails, result) {\n    super(`One or more branches were not updated: ${prettyDetails}`);\n    this.code = this.name = GitPushError.code;\n    this.data = { prettyDetails, result };\n  }\n}\n/** @type {'GitPushError'} */\nGitPushError.code = 'GitPushError';\n\nclass HttpError extends BaseError {\n  /**\n   * @param {number} statusCode\n   * @param {string} statusMessage\n   * @param {string} response\n   */\n  constructor(statusCode, statusMessage, response) {\n    super(`HTTP Error: ${statusCode} ${statusMessage}`);\n    this.code = this.name = HttpError.code;\n    this.data = { statusCode, statusMessage, response };\n  }\n}\n/** @type {'HttpError'} */\nHttpError.code = 'HttpError';\n\nclass InvalidFilepathError extends BaseError {\n  /**\n   * @param {'leading-slash'|'trailing-slash'|'directory'} [reason]\n   */\n  constructor(reason) {\n    let message = 'invalid filepath';\n    if (reason === 'leading-slash' || reason === 'trailing-slash') {\n      message = `\"filepath\" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.`;\n    } else if (reason === 'directory') {\n      message = `\"filepath\" should not be a directory.`;\n    }\n    super(message);\n    this.code = this.name = InvalidFilepathError.code;\n    this.data = { reason };\n  }\n}\n/** @type {'InvalidFilepathError'} */\nInvalidFilepathError.code = 'InvalidFilepathError';\n\nclass InvalidRefNameError extends BaseError {\n  /**\n   * @param {string} ref\n   * @param {string} suggestion\n   * @param {boolean} canForce\n   */\n  constructor(ref, suggestion) {\n    super(\n      `\"${ref}\" would be an invalid git reference. (Hint: a valid alternative would be \"${suggestion}\".)`\n    );\n    this.code = this.name = InvalidRefNameError.code;\n    this.data = { ref, suggestion };\n  }\n}\n/** @type {'InvalidRefNameError'} */\nInvalidRefNameError.code = 'InvalidRefNameError';\n\nclass MaxDepthError extends BaseError {\n  /**\n   * @param {number} depth\n   */\n  constructor(depth) {\n    super(`Maximum search depth of ${depth} exceeded.`);\n    this.code = this.name = MaxDepthError.code;\n    this.data = { depth };\n  }\n}\n/** @type {'MaxDepthError'} */\nMaxDepthError.code = 'MaxDepthError';\n\nclass MergeNotSupportedError extends BaseError {\n  constructor() {\n    super(`Merges with conflicts are not supported yet.`);\n    this.code = this.name = MergeNotSupportedError.code;\n    this.data = {};\n  }\n}\n/** @type {'MergeNotSupportedError'} */\nMergeNotSupportedError.code = 'MergeNotSupportedError';\n\nclass MergeConflictError extends BaseError {\n  /**\n   * @param {Array<string>} filepaths\n   * @param {Array<string>} bothModified\n   * @param {Array<string>} deleteByUs\n   * @param {Array<string>} deleteByTheirs\n   */\n  constructor(filepaths, bothModified, deleteByUs, deleteByTheirs) {\n    super(\n      `Automatic merge failed with one or more merge conflicts in the following files: ${filepaths.toString()}. Fix conflicts then commit the result.`\n    );\n    this.code = this.name = MergeConflictError.code;\n    this.data = { filepaths, bothModified, deleteByUs, deleteByTheirs };\n  }\n}\n/** @type {'MergeConflictError'} */\nMergeConflictError.code = 'MergeConflictError';\n\nclass MissingNameError extends BaseError {\n  /**\n   * @param {'author'|'committer'|'tagger'} role\n   */\n  constructor(role) {\n    super(\n      `No name was provided for ${role} in the argument or in the .git/config file.`\n    );\n    this.code = this.name = MissingNameError.code;\n    this.data = { role };\n  }\n}\n/** @type {'MissingNameError'} */\nMissingNameError.code = 'MissingNameError';\n\nclass MissingParameterError extends BaseError {\n  /**\n   * @param {string} parameter\n   */\n  constructor(parameter) {\n    super(\n      `The function requires a \"${parameter}\" parameter but none was provided.`\n    );\n    this.code = this.name = MissingParameterError.code;\n    this.data = { parameter };\n  }\n}\n/** @type {'MissingParameterError'} */\nMissingParameterError.code = 'MissingParameterError';\n\nclass MultipleGitError extends BaseError {\n  /**\n   * @param {Error[]} errors\n   * @param {string} message\n   */\n  constructor(errors) {\n    super(\n      `There are multiple errors that were thrown by the method. Please refer to the \"errors\" property to see more`\n    );\n    this.code = this.name = MultipleGitError.code;\n    this.data = { errors };\n    this.errors = errors;\n  }\n}\n/** @type {'MultipleGitError'} */\nMultipleGitError.code = 'MultipleGitError';\n\nclass ParseError extends BaseError {\n  /**\n   * @param {string} expected\n   * @param {string} actual\n   */\n  constructor(expected, actual) {\n    super(`Expected \"${expected}\" but received \"${actual}\".`);\n    this.code = this.name = ParseError.code;\n    this.data = { expected, actual };\n  }\n}\n/** @type {'ParseError'} */\nParseError.code = 'ParseError';\n\nclass PushRejectedError extends BaseError {\n  /**\n   * @param {'not-fast-forward'|'tag-exists'} reason\n   */\n  constructor(reason) {\n    let message = '';\n    if (reason === 'not-fast-forward') {\n      message = ' because it was not a simple fast-forward';\n    } else if (reason === 'tag-exists') {\n      message = ' because tag already exists';\n    }\n    super(`Push rejected${message}. Use \"force: true\" to override.`);\n    this.code = this.name = PushRejectedError.code;\n    this.data = { reason };\n  }\n}\n/** @type {'PushRejectedError'} */\nPushRejectedError.code = 'PushRejectedError';\n\nclass RemoteCapabilityError extends BaseError {\n  /**\n   * @param {'shallow'|'deepen-since'|'deepen-not'|'deepen-relative'} capability\n   * @param {'depth'|'since'|'exclude'|'relative'} parameter\n   */\n  constructor(capability, parameter) {\n    super(\n      `Remote does not support the \"${capability}\" so the \"${parameter}\" parameter cannot be used.`\n    );\n    this.code = this.name = RemoteCapabilityError.code;\n    this.data = { capability, parameter };\n  }\n}\n/** @type {'RemoteCapabilityError'} */\nRemoteCapabilityError.code = 'RemoteCapabilityError';\n\nclass SmartHttpError extends BaseError {\n  /**\n   * @param {string} preview\n   * @param {string} response\n   */\n  constructor(preview, response) {\n    super(\n      `Remote did not reply using the \"smart\" HTTP protocol. Expected \"001e# service=git-upload-pack\" but received: ${preview}`\n    );\n    this.code = this.name = SmartHttpError.code;\n    this.data = { preview, response };\n  }\n}\n/** @type {'SmartHttpError'} */\nSmartHttpError.code = 'SmartHttpError';\n\nclass UnknownTransportError extends BaseError {\n  /**\n   * @param {string} url\n   * @param {string} transport\n   * @param {string} [suggestion]\n   */\n  constructor(url, transport, suggestion) {\n    super(\n      `Git remote \"${url}\" uses an unrecognized transport protocol: \"${transport}\"`\n    );\n    this.code = this.name = UnknownTransportError.code;\n    this.data = { url, transport, suggestion };\n  }\n}\n/** @type {'UnknownTransportError'} */\nUnknownTransportError.code = 'UnknownTransportError';\n\nclass UrlParseError extends BaseError {\n  /**\n   * @param {string} url\n   */\n  constructor(url) {\n    super(`Cannot parse remote URL: \"${url}\"`);\n    this.code = this.name = UrlParseError.code;\n    this.data = { url };\n  }\n}\n/** @type {'UrlParseError'} */\nUrlParseError.code = 'UrlParseError';\n\nclass UserCanceledError extends BaseError {\n  constructor() {\n    super(`The operation was canceled.`);\n    this.code = this.name = UserCanceledError.code;\n    this.data = {};\n  }\n}\n/** @type {'UserCanceledError'} */\nUserCanceledError.code = 'UserCanceledError';\n\nclass IndexResetError extends BaseError {\n  /**\n   * @param {Array<string>} filepaths\n   */\n  constructor(filepath) {\n    super(\n      `Could not merge index: Entry for '${filepath}' is not up to date. Either reset the index entry to HEAD, or stage your unstaged chages.`\n    );\n    this.code = this.name = IndexResetError.code;\n    this.data = { filepath };\n  }\n}\n/** @type {'IndexResetError'} */\nIndexResetError.code = 'IndexResetError';\n\n\n\nvar Errors = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  AlreadyExistsError: AlreadyExistsError,\n  AmbiguousError: AmbiguousError,\n  CheckoutConflictError: CheckoutConflictError,\n  CommitNotFetchedError: CommitNotFetchedError,\n  EmptyServerResponseError: EmptyServerResponseError,\n  FastForwardError: FastForwardError,\n  GitPushError: GitPushError,\n  HttpError: HttpError,\n  InternalError: InternalError,\n  InvalidFilepathError: InvalidFilepathError,\n  InvalidOidError: InvalidOidError,\n  InvalidRefNameError: InvalidRefNameError,\n  MaxDepthError: MaxDepthError,\n  MergeNotSupportedError: MergeNotSupportedError,\n  MergeConflictError: MergeConflictError,\n  MissingNameError: MissingNameError,\n  MissingParameterError: MissingParameterError,\n  MultipleGitError: MultipleGitError,\n  NoRefspecError: NoRefspecError,\n  NotFoundError: NotFoundError,\n  ObjectTypeError: ObjectTypeError,\n  ParseError: ParseError,\n  PushRejectedError: PushRejectedError,\n  RemoteCapabilityError: RemoteCapabilityError,\n  SmartHttpError: SmartHttpError,\n  UnknownTransportError: UnknownTransportError,\n  UnsafeFilepathError: UnsafeFilepathError,\n  UrlParseError: UrlParseError,\n  UserCanceledError: UserCanceledError,\n  UnmergedPathsError: UnmergedPathsError,\n  IndexResetError: IndexResetError\n});\n\nfunction formatAuthor({ name, email, timestamp, timezoneOffset }) {\n  timezoneOffset = formatTimezoneOffset(timezoneOffset);\n  return `${name} <${email}> ${timestamp} ${timezoneOffset}`\n}\n\n// The amount of effort that went into crafting these cases to handle\n// -0 (just so we don't lose that information when parsing and reconstructing)\n// but can also default to +0 was extraordinary.\n\nfunction formatTimezoneOffset(minutes) {\n  const sign = simpleSign(negateExceptForZero(minutes));\n  minutes = Math.abs(minutes);\n  const hours = Math.floor(minutes / 60);\n  minutes -= hours * 60;\n  let strHours = String(hours);\n  let strMinutes = String(minutes);\n  if (strHours.length < 2) strHours = '0' + strHours;\n  if (strMinutes.length < 2) strMinutes = '0' + strMinutes;\n  return (sign === -1 ? '-' : '+') + strHours + strMinutes\n}\n\nfunction simpleSign(n) {\n  return Math.sign(n) || (Object.is(n, -0) ? -1 : 1)\n}\n\nfunction negateExceptForZero(n) {\n  return n === 0 ? n : -n\n}\n\nfunction normalizeNewlines(str) {\n  // remove all <CR>\n  str = str.replace(/\\r/g, '');\n  // no extra newlines up front\n  str = str.replace(/^\\n+/, '');\n  // and a single newline at the end\n  str = str.replace(/\\n+$/, '') + '\\n';\n  return str\n}\n\nfunction parseAuthor(author) {\n  const [, name, email, timestamp, offset] = author.match(\n    /^(.*) <(.*)> (.*) (.*)$/\n  );\n  return {\n    name: name,\n    email: email,\n    timestamp: Number(timestamp),\n    timezoneOffset: parseTimezoneOffset(offset),\n  }\n}\n\n// The amount of effort that went into crafting these cases to handle\n// -0 (just so we don't lose that information when parsing and reconstructing)\n// but can also default to +0 was extraordinary.\n\nfunction parseTimezoneOffset(offset) {\n  let [, sign, hours, minutes] = offset.match(/(\\+|-)(\\d\\d)(\\d\\d)/);\n  minutes = (sign === '+' ? 1 : -1) * (Number(hours) * 60 + Number(minutes));\n  return negateExceptForZero$1(minutes)\n}\n\nfunction negateExceptForZero$1(n) {\n  return n === 0 ? n : -n\n}\n\nclass GitAnnotatedTag {\n  constructor(tag) {\n    if (typeof tag === 'string') {\n      this._tag = tag;\n    } else if (Buffer.isBuffer(tag)) {\n      this._tag = tag.toString('utf8');\n    } else if (typeof tag === 'object') {\n      this._tag = GitAnnotatedTag.render(tag);\n    } else {\n      throw new InternalError(\n        'invalid type passed to GitAnnotatedTag constructor'\n      )\n    }\n  }\n\n  static from(tag) {\n    return new GitAnnotatedTag(tag)\n  }\n\n  static render(obj) {\n    return `object ${obj.object}\ntype ${obj.type}\ntag ${obj.tag}\ntagger ${formatAuthor(obj.tagger)}\n\n${obj.message}\n${obj.gpgsig ? obj.gpgsig : ''}`\n  }\n\n  justHeaders() {\n    return this._tag.slice(0, this._tag.indexOf('\\n\\n'))\n  }\n\n  message() {\n    const tag = this.withoutSignature();\n    return tag.slice(tag.indexOf('\\n\\n') + 2)\n  }\n\n  parse() {\n    return Object.assign(this.headers(), {\n      message: this.message(),\n      gpgsig: this.gpgsig(),\n    })\n  }\n\n  render() {\n    return this._tag\n  }\n\n  headers() {\n    const headers = this.justHeaders().split('\\n');\n    const hs = [];\n    for (const h of headers) {\n      if (h[0] === ' ') {\n        // combine with previous header (without space indent)\n        hs[hs.length - 1] += '\\n' + h.slice(1);\n      } else {\n        hs.push(h);\n      }\n    }\n    const obj = {};\n    for (const h of hs) {\n      const key = h.slice(0, h.indexOf(' '));\n      const value = h.slice(h.indexOf(' ') + 1);\n      if (Array.isArray(obj[key])) {\n        obj[key].push(value);\n      } else {\n        obj[key] = value;\n      }\n    }\n    if (obj.tagger) {\n      obj.tagger = parseAuthor(obj.tagger);\n    }\n    if (obj.committer) {\n      obj.committer = parseAuthor(obj.committer);\n    }\n    return obj\n  }\n\n  withoutSignature() {\n    const tag = normalizeNewlines(this._tag);\n    if (tag.indexOf('\\n-----BEGIN PGP SIGNATURE-----') === -1) return tag\n    return tag.slice(0, tag.lastIndexOf('\\n-----BEGIN PGP SIGNATURE-----'))\n  }\n\n  gpgsig() {\n    if (this._tag.indexOf('\\n-----BEGIN PGP SIGNATURE-----') === -1) return\n    const signature = this._tag.slice(\n      this._tag.indexOf('-----BEGIN PGP SIGNATURE-----'),\n      this._tag.indexOf('-----END PGP SIGNATURE-----') +\n        '-----END PGP SIGNATURE-----'.length\n    );\n    return normalizeNewlines(signature)\n  }\n\n  payload() {\n    return this.withoutSignature() + '\\n'\n  }\n\n  toObject() {\n    return Buffer.from(this._tag, 'utf8')\n  }\n\n  static async sign(tag, sign, secretKey) {\n    const payload = tag.payload();\n    let { signature } = await sign({ payload, secretKey });\n    // renormalize the line endings to the one true line-ending\n    signature = normalizeNewlines(signature);\n    const signedTag = payload + signature;\n    // return a new tag object\n    return GitAnnotatedTag.from(signedTag)\n  }\n}\n\nfunction indent(str) {\n  return (\n    str\n      .trim()\n      .split('\\n')\n      .map(x => ' ' + x)\n      .join('\\n') + '\\n'\n  )\n}\n\nfunction outdent(str) {\n  return str\n    .split('\\n')\n    .map(x => x.replace(/^ /, ''))\n    .join('\\n')\n}\n\nclass GitCommit {\n  constructor(commit) {\n    if (typeof commit === 'string') {\n      this._commit = commit;\n    } else if (Buffer.isBuffer(commit)) {\n      this._commit = commit.toString('utf8');\n    } else if (typeof commit === 'object') {\n      this._commit = GitCommit.render(commit);\n    } else {\n      throw new InternalError('invalid type passed to GitCommit constructor')\n    }\n  }\n\n  static fromPayloadSignature({ payload, signature }) {\n    const headers = GitCommit.justHeaders(payload);\n    const message = GitCommit.justMessage(payload);\n    const commit = normalizeNewlines(\n      headers + '\\ngpgsig' + indent(signature) + '\\n' + message\n    );\n    return new GitCommit(commit)\n  }\n\n  static from(commit) {\n    return new GitCommit(commit)\n  }\n\n  toObject() {\n    return Buffer.from(this._commit, 'utf8')\n  }\n\n  // Todo: allow setting the headers and message\n  headers() {\n    return this.parseHeaders()\n  }\n\n  // Todo: allow setting the headers and message\n  message() {\n    return GitCommit.justMessage(this._commit)\n  }\n\n  parse() {\n    return Object.assign({ message: this.message() }, this.headers())\n  }\n\n  static justMessage(commit) {\n    return normalizeNewlines(commit.slice(commit.indexOf('\\n\\n') + 2))\n  }\n\n  static justHeaders(commit) {\n    return commit.slice(0, commit.indexOf('\\n\\n'))\n  }\n\n  parseHeaders() {\n    const headers = GitCommit.justHeaders(this._commit).split('\\n');\n    const hs = [];\n    for (const h of headers) {\n      if (h[0] === ' ') {\n        // combine with previous header (without space indent)\n        hs[hs.length - 1] += '\\n' + h.slice(1);\n      } else {\n        hs.push(h);\n      }\n    }\n    const obj = {\n      parent: [],\n    };\n    for (const h of hs) {\n      const key = h.slice(0, h.indexOf(' '));\n      const value = h.slice(h.indexOf(' ') + 1);\n      if (Array.isArray(obj[key])) {\n        obj[key].push(value);\n      } else {\n        obj[key] = value;\n      }\n    }\n    if (obj.author) {\n      obj.author = parseAuthor(obj.author);\n    }\n    if (obj.committer) {\n      obj.committer = parseAuthor(obj.committer);\n    }\n    return obj\n  }\n\n  static renderHeaders(obj) {\n    let headers = '';\n    if (obj.tree) {\n      headers += `tree ${obj.tree}\\n`;\n    } else {\n      headers += `tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904\\n`; // the null tree\n    }\n    if (obj.parent) {\n      if (obj.parent.length === undefined) {\n        throw new InternalError(`commit 'parent' property should be an array`)\n      }\n      for (const p of obj.parent) {\n        headers += `parent ${p}\\n`;\n      }\n    }\n    const author = obj.author;\n    headers += `author ${formatAuthor(author)}\\n`;\n    const committer = obj.committer || obj.author;\n    headers += `committer ${formatAuthor(committer)}\\n`;\n    if (obj.gpgsig) {\n      headers += 'gpgsig' + indent(obj.gpgsig);\n    }\n    return headers\n  }\n\n  static render(obj) {\n    return GitCommit.renderHeaders(obj) + '\\n' + normalizeNewlines(obj.message)\n  }\n\n  render() {\n    return this._commit\n  }\n\n  withoutSignature() {\n    const commit = normalizeNewlines(this._commit);\n    if (commit.indexOf('\\ngpgsig') === -1) return commit\n    const headers = commit.slice(0, commit.indexOf('\\ngpgsig'));\n    const message = commit.slice(\n      commit.indexOf('-----END PGP SIGNATURE-----\\n') +\n        '-----END PGP SIGNATURE-----\\n'.length\n    );\n    return normalizeNewlines(headers + '\\n' + message)\n  }\n\n  isolateSignature() {\n    const signature = this._commit.slice(\n      this._commit.indexOf('-----BEGIN PGP SIGNATURE-----'),\n      this._commit.indexOf('-----END PGP SIGNATURE-----') +\n        '-----END PGP SIGNATURE-----'.length\n    );\n    return outdent(signature)\n  }\n\n  static async sign(commit, sign, secretKey) {\n    const payload = commit.withoutSignature();\n    const message = GitCommit.justMessage(commit._commit);\n    let { signature } = await sign({ payload, secretKey });\n    // renormalize the line endings to the one true line-ending\n    signature = normalizeNewlines(signature);\n    const headers = GitCommit.justHeaders(commit._commit);\n    const signedCommit =\n      headers + '\\n' + 'gpgsig' + indent(signature) + '\\n' + message;\n    // return a new commit object\n    return GitCommit.from(signedCommit)\n  }\n}\n\nasync function resolveTree({ fs, cache, gitdir, oid }) {\n  // Empty tree - bypass `readObject`\n  if (oid === '4b825dc642cb6eb9a060e54bf8d69288fbee4904') {\n    return { tree: GitTree.from([]), oid }\n  }\n  const { type, object } = await _readObject({ fs, cache, gitdir, oid });\n  // Resolve annotated tag objects to whatever\n  if (type === 'tag') {\n    oid = GitAnnotatedTag.from(object).parse().object;\n    return resolveTree({ fs, cache, gitdir, oid })\n  }\n  // Resolve commits to trees\n  if (type === 'commit') {\n    oid = GitCommit.from(object).parse().tree;\n    return resolveTree({ fs, cache, gitdir, oid })\n  }\n  if (type !== 'tree') {\n    throw new ObjectTypeError(oid, type, 'tree')\n  }\n  return { tree: GitTree.from(object), oid }\n}\n\nclass GitWalkerRepo {\n  constructor({ fs, gitdir, ref, cache }) {\n    this.fs = fs;\n    this.cache = cache;\n    this.gitdir = gitdir;\n    this.mapPromise = (async () => {\n      const map = new Map();\n      let oid;\n      try {\n        oid = await GitRefManager.resolve({ fs, gitdir, ref });\n      } catch (e) {\n        if (e instanceof NotFoundError) {\n          // Handle fresh branches with no commits\n          oid = '4b825dc642cb6eb9a060e54bf8d69288fbee4904';\n        }\n      }\n      const tree = await resolveTree({ fs, cache: this.cache, gitdir, oid });\n      tree.type = 'tree';\n      tree.mode = '40000';\n      map.set('.', tree);\n      return map\n    })();\n    const walker = this;\n    this.ConstructEntry = class TreeEntry {\n      constructor(fullpath) {\n        this._fullpath = fullpath;\n        this._type = false;\n        this._mode = false;\n        this._stat = false;\n        this._content = false;\n        this._oid = false;\n      }\n\n      async type() {\n        return walker.type(this)\n      }\n\n      async mode() {\n        return walker.mode(this)\n      }\n\n      async stat() {\n        return walker.stat(this)\n      }\n\n      async content() {\n        return walker.content(this)\n      }\n\n      async oid() {\n        return walker.oid(this)\n      }\n    };\n  }\n\n  async readdir(entry) {\n    const filepath = entry._fullpath;\n    const { fs, cache, gitdir } = this;\n    const map = await this.mapPromise;\n    const obj = map.get(filepath);\n    if (!obj) throw new Error(`No obj for ${filepath}`)\n    const oid = obj.oid;\n    if (!oid) throw new Error(`No oid for obj ${JSON.stringify(obj)}`)\n    if (obj.type !== 'tree') {\n      // TODO: support submodules (type === 'commit')\n      return null\n    }\n    const { type, object } = await _readObject({ fs, cache, gitdir, oid });\n    if (type !== obj.type) {\n      throw new ObjectTypeError(oid, type, obj.type)\n    }\n    const tree = GitTree.from(object);\n    // cache all entries\n    for (const entry of tree) {\n      map.set(join(filepath, entry.path), entry);\n    }\n    return tree.entries().map(entry => join(filepath, entry.path))\n  }\n\n  async type(entry) {\n    if (entry._type === false) {\n      const map = await this.mapPromise;\n      const { type } = map.get(entry._fullpath);\n      entry._type = type;\n    }\n    return entry._type\n  }\n\n  async mode(entry) {\n    if (entry._mode === false) {\n      const map = await this.mapPromise;\n      const { mode } = map.get(entry._fullpath);\n      entry._mode = normalizeMode(parseInt(mode, 8));\n    }\n    return entry._mode\n  }\n\n  async stat(_entry) {}\n\n  async content(entry) {\n    if (entry._content === false) {\n      const map = await this.mapPromise;\n      const { fs, cache, gitdir } = this;\n      const obj = map.get(entry._fullpath);\n      const oid = obj.oid;\n      const { type, object } = await _readObject({ fs, cache, gitdir, oid });\n      if (type !== 'blob') {\n        entry._content = undefined;\n      } else {\n        entry._content = new Uint8Array(object);\n      }\n    }\n    return entry._content\n  }\n\n  async oid(entry) {\n    if (entry._oid === false) {\n      const map = await this.mapPromise;\n      const obj = map.get(entry._fullpath);\n      entry._oid = obj.oid;\n    }\n    return entry._oid\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {string} [args.ref='HEAD']\n * @returns {Walker}\n */\nfunction TREE({ ref = 'HEAD' } = {}) {\n  const o = Object.create(null);\n  Object.defineProperty(o, GitWalkSymbol, {\n    value: function({ fs, gitdir, cache }) {\n      return new GitWalkerRepo({ fs, gitdir, ref, cache })\n    },\n  });\n  Object.freeze(o);\n  return o\n}\n\n// @ts-check\n\nclass GitWalkerFs {\n  constructor({ fs, dir, gitdir, cache }) {\n    this.fs = fs;\n    this.cache = cache;\n    this.dir = dir;\n    this.gitdir = gitdir;\n    const walker = this;\n    this.ConstructEntry = class WorkdirEntry {\n      constructor(fullpath) {\n        this._fullpath = fullpath;\n        this._type = false;\n        this._mode = false;\n        this._stat = false;\n        this._content = false;\n        this._oid = false;\n      }\n\n      async type() {\n        return walker.type(this)\n      }\n\n      async mode() {\n        return walker.mode(this)\n      }\n\n      async stat() {\n        return walker.stat(this)\n      }\n\n      async content() {\n        return walker.content(this)\n      }\n\n      async oid() {\n        return walker.oid(this)\n      }\n    };\n  }\n\n  async readdir(entry) {\n    const filepath = entry._fullpath;\n    const { fs, dir } = this;\n    const names = await fs.readdir(join(dir, filepath));\n    if (names === null) return null\n    return names.map(name => join(filepath, name))\n  }\n\n  async type(entry) {\n    if (entry._type === false) {\n      await entry.stat();\n    }\n    return entry._type\n  }\n\n  async mode(entry) {\n    if (entry._mode === false) {\n      await entry.stat();\n    }\n    return entry._mode\n  }\n\n  async stat(entry) {\n    if (entry._stat === false) {\n      const { fs, dir } = this;\n      let stat = await fs.lstat(`${dir}/${entry._fullpath}`);\n      if (!stat) {\n        throw new Error(\n          `ENOENT: no such file or directory, lstat '${entry._fullpath}'`\n        )\n      }\n      let type = stat.isDirectory() ? 'tree' : 'blob';\n      if (type === 'blob' && !stat.isFile() && !stat.isSymbolicLink()) {\n        type = 'special';\n      }\n      entry._type = type;\n      stat = normalizeStats(stat);\n      entry._mode = stat.mode;\n      // workaround for a BrowserFS edge case\n      if (stat.size === -1 && entry._actualSize) {\n        stat.size = entry._actualSize;\n      }\n      entry._stat = stat;\n    }\n    return entry._stat\n  }\n\n  async content(entry) {\n    if (entry._content === false) {\n      const { fs, dir } = this;\n      if ((await entry.type()) === 'tree') {\n        entry._content = undefined;\n      } else {\n        const content = await fs.read(`${dir}/${entry._fullpath}`);\n        // workaround for a BrowserFS edge case\n        entry._actualSize = content.length;\n        if (entry._stat && entry._stat.size === -1) {\n          entry._stat.size = entry._actualSize;\n        }\n        entry._content = new Uint8Array(content);\n      }\n    }\n    return entry._content\n  }\n\n  async oid(entry) {\n    if (entry._oid === false) {\n      const { fs, gitdir, cache } = this;\n      let oid;\n      // See if we can use the SHA1 hash in the index.\n      await GitIndexManager.acquire({ fs, gitdir, cache }, async function(\n        index\n      ) {\n        const stage = index.entriesMap.get(entry._fullpath);\n        const stats = await entry.stat();\n        if (!stage || compareStats(stats, stage)) {\n          const content = await entry.content();\n          if (content === undefined) {\n            oid = undefined;\n          } else {\n            oid = await shasum(\n              GitObject.wrap({ type: 'blob', object: await entry.content() })\n            );\n            // Update the stats in the index so we will get a \"cache hit\" next time\n            // 1) if we can (because the oid and mode are the same)\n            // 2) and only if we need to (because other stats differ)\n            if (\n              stage &&\n              oid === stage.oid &&\n              stats.mode === stage.mode &&\n              compareStats(stats, stage)\n            ) {\n              index.insert({\n                filepath: entry._fullpath,\n                stats,\n                oid: oid,\n              });\n            }\n          }\n        } else {\n          // Use the index SHA1 rather than compute it\n          oid = stage.oid;\n        }\n      });\n      entry._oid = oid;\n    }\n    return entry._oid\n  }\n}\n\n// @ts-check\n\n/**\n * @returns {Walker}\n */\nfunction WORKDIR() {\n  const o = Object.create(null);\n  Object.defineProperty(o, GitWalkSymbol, {\n    value: function({ fs, dir, gitdir, cache }) {\n      return new GitWalkerFs({ fs, dir, gitdir, cache })\n    },\n  });\n  Object.freeze(o);\n  return o\n}\n\n// @ts-check\n\n// https://dev.to/namirsab/comment/2050\nfunction arrayRange(start, end) {\n  const length = end - start;\n  return Array.from({ length }, (_, i) => start + i)\n}\n\n// TODO: Should I just polyfill Array.flat?\nconst flat =\n  typeof Array.prototype.flat === 'undefined'\n    ? entries => entries.reduce((acc, x) => acc.concat(x), [])\n    : entries => entries.flat();\n\n// This is convenient for computing unions/joins of sorted lists.\nclass RunningMinimum {\n  constructor() {\n    // Using a getter for 'value' would just bloat the code.\n    // You know better than to set it directly right?\n    this.value = null;\n  }\n\n  consider(value) {\n    if (value === null || value === undefined) return\n    if (this.value === null) {\n      this.value = value;\n    } else if (value < this.value) {\n      this.value = value;\n    }\n  }\n\n  reset() {\n    this.value = null;\n  }\n}\n\n// Take an array of length N of\n//   iterators of length Q_n\n//     of strings\n// and return an iterator of length max(Q_n) for all n\n//   of arrays of length N\n//     of string|null who all have the same string value\nfunction* unionOfIterators(sets) {\n  /* NOTE: We can assume all arrays are sorted.\n   * Indexes are sorted because they are defined that way:\n   *\n   * > Index entries are sorted in ascending order on the name field,\n   * > interpreted as a string of unsigned bytes (i.e. memcmp() order, no\n   * > localization, no special casing of directory separator '/'). Entries\n   * > with the same name are sorted by their stage field.\n   *\n   * Trees should be sorted because they are created directly from indexes.\n   * They definitely should be sorted, or else they wouldn't have a unique SHA1.\n   * So that would be very naughty on the part of the tree-creator.\n   *\n   * Lastly, the working dir entries are sorted because I choose to sort them\n   * in my FileSystem.readdir() implementation.\n   */\n\n  // Init\n  const min = new RunningMinimum();\n  let minimum;\n  const heads = [];\n  const numsets = sets.length;\n  for (let i = 0; i < numsets; i++) {\n    // Abuse the fact that iterators continue to return 'undefined' for value\n    // once they are done\n    heads[i] = sets[i].next().value;\n    if (heads[i] !== undefined) {\n      min.consider(heads[i]);\n    }\n  }\n  if (min.value === null) return\n  // Iterate\n  while (true) {\n    const result = [];\n    minimum = min.value;\n    min.reset();\n    for (let i = 0; i < numsets; i++) {\n      if (heads[i] !== undefined && heads[i] === minimum) {\n        result[i] = heads[i];\n        heads[i] = sets[i].next().value;\n      } else {\n        // A little hacky, but eh\n        result[i] = null;\n      }\n      if (heads[i] !== undefined) {\n        min.consider(heads[i]);\n      }\n    }\n    yield result;\n    if (min.value === null) return\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {string} [args.dir]\n * @param {string} [args.gitdir=join(dir,'.git')]\n * @param {Walker[]} args.trees\n * @param {WalkerMap} [args.map]\n * @param {WalkerReduce} [args.reduce]\n * @param {WalkerIterate} [args.iterate]\n *\n * @returns {Promise<any>} The finished tree-walking result\n *\n * @see {WalkerMap}\n *\n */\nasync function _walk({\n  fs,\n  cache,\n  dir,\n  gitdir,\n  trees,\n  // @ts-ignore\n  map = async (_, entry) => entry,\n  // The default reducer is a flatmap that filters out undefineds.\n  reduce = async (parent, children) => {\n    const flatten = flat(children);\n    if (parent !== undefined) flatten.unshift(parent);\n    return flatten\n  },\n  // The default iterate function walks all children concurrently\n  iterate = (walk, children) => Promise.all([...children].map(walk)),\n}) {\n  const walkers = trees.map(proxy =>\n    proxy[GitWalkSymbol]({ fs, dir, gitdir, cache })\n  );\n\n  const root = new Array(walkers.length).fill('.');\n  const range = arrayRange(0, walkers.length);\n  const unionWalkerFromReaddir = async entries => {\n    range.map(i => {\n      entries[i] = entries[i] && new walkers[i].ConstructEntry(entries[i]);\n    });\n    const subdirs = await Promise.all(\n      range.map(i => (entries[i] ? walkers[i].readdir(entries[i]) : []))\n    );\n    // Now process child directories\n    const iterators = subdirs\n      .map(array => (array === null ? [] : array))\n      .map(array => array[Symbol.iterator]());\n    return {\n      entries,\n      children: unionOfIterators(iterators),\n    }\n  };\n\n  const walk = async root => {\n    const { entries, children } = await unionWalkerFromReaddir(root);\n    const fullpath = entries.find(entry => entry && entry._fullpath)._fullpath;\n    const parent = await map(fullpath, entries);\n    if (parent !== null) {\n      let walkedChildren = await iterate(walk, children);\n      walkedChildren = walkedChildren.filter(x => x !== undefined);\n      return reduce(parent, walkedChildren)\n    }\n  };\n  return walk(root)\n}\n\n/**\n * Removes the directory at the specified filepath recursively. Used internally to replicate the behavior of\n * fs.promises.rm({ recursive: true, force: true }) from Node.js 14 and above when not available. If the provided\n * filepath resolves to a file, it will be removed.\n *\n * @param {import('../models/FileSystem.js').FileSystem} fs\n * @param {string} filepath - The file or directory to remove.\n */\nasync function rmRecursive(fs, filepath) {\n  const entries = await fs.readdir(filepath);\n  if (entries == null) {\n    await fs.rm(filepath);\n  } else if (entries.length) {\n    await Promise.all(\n      entries.map(entry => {\n        const subpath = join(filepath, entry);\n        return fs.lstat(subpath).then(stat => {\n          if (!stat) return\n          return stat.isDirectory() ? rmRecursive(fs, subpath) : fs.rm(subpath)\n        })\n      })\n    ).then(() => fs.rmdir(filepath));\n  } else {\n    await fs.rmdir(filepath);\n  }\n}\n\nfunction isPromiseLike(obj) {\n  return isObject(obj) && isFunction(obj.then) && isFunction(obj.catch)\n}\n\nfunction isObject(obj) {\n  return obj && typeof obj === 'object'\n}\n\nfunction isFunction(obj) {\n  return typeof obj === 'function'\n}\n\nfunction isPromiseFs(fs) {\n  const test = targetFs => {\n    try {\n      // If readFile returns a promise then we can probably assume the other\n      // commands do as well\n      return targetFs.readFile().catch(e => e)\n    } catch (e) {\n      return e\n    }\n  };\n  return isPromiseLike(test(fs))\n}\n\n// List of commands all filesystems are expected to provide. `rm` is not\n// included since it may not exist and must be handled as a special case\nconst commands = [\n  'readFile',\n  'writeFile',\n  'mkdir',\n  'rmdir',\n  'unlink',\n  'stat',\n  'lstat',\n  'readdir',\n  'readlink',\n  'symlink',\n];\n\nfunction bindFs(target, fs) {\n  if (isPromiseFs(fs)) {\n    for (const command of commands) {\n      target[`_${command}`] = fs[command].bind(fs);\n    }\n  } else {\n    for (const command of commands) {\n      target[`_${command}`] = pify(fs[command].bind(fs));\n    }\n  }\n\n  // Handle the special case of `rm`\n  if (isPromiseFs(fs)) {\n    if (fs.rm) target._rm = fs.rm.bind(fs);\n    else if (fs.rmdir.length > 1) target._rm = fs.rmdir.bind(fs);\n    else target._rm = rmRecursive.bind(null, target);\n  } else {\n    if (fs.rm) target._rm = pify(fs.rm.bind(fs));\n    else if (fs.rmdir.length > 2) target._rm = pify(fs.rmdir.bind(fs));\n    else target._rm = rmRecursive.bind(null, target);\n  }\n}\n\n/**\n * This is just a collection of helper functions really. At least that's how it started.\n */\nclass FileSystem {\n  constructor(fs) {\n    if (typeof fs._original_unwrapped_fs !== 'undefined') return fs\n\n    const promises = Object.getOwnPropertyDescriptor(fs, 'promises');\n    if (promises && promises.enumerable) {\n      bindFs(this, fs.promises);\n    } else {\n      bindFs(this, fs);\n    }\n    this._original_unwrapped_fs = fs;\n  }\n\n  /**\n   * Return true if a file exists, false if it doesn't exist.\n   * Rethrows errors that aren't related to file existance.\n   */\n  async exists(filepath, options = {}) {\n    try {\n      await this._stat(filepath);\n      return true\n    } catch (err) {\n      if (err.code === 'ENOENT' || err.code === 'ENOTDIR') {\n        return false\n      } else {\n        console.log('Unhandled error in \"FileSystem.exists()\" function', err);\n        throw err\n      }\n    }\n  }\n\n  /**\n   * Return the contents of a file if it exists, otherwise returns null.\n   *\n   * @param {string} filepath\n   * @param {object} [options]\n   *\n   * @returns {Promise<Buffer|string|null>}\n   */\n  async read(filepath, options = {}) {\n    try {\n      let buffer = await this._readFile(filepath, options);\n      // Convert plain ArrayBuffers to Buffers\n      if (typeof buffer !== 'string') {\n        buffer = Buffer.from(buffer);\n      }\n      return buffer\n    } catch (err) {\n      return null\n    }\n  }\n\n  /**\n   * Write a file (creating missing directories if need be) without throwing errors.\n   *\n   * @param {string} filepath\n   * @param {Buffer|Uint8Array|string} contents\n   * @param {object|string} [options]\n   */\n  async write(filepath, contents, options = {}) {\n    try {\n      await this._writeFile(filepath, contents, options);\n      return\n    } catch (err) {\n      // Hmm. Let's try mkdirp and try again.\n      await this.mkdir(dirname(filepath));\n      await this._writeFile(filepath, contents, options);\n    }\n  }\n\n  /**\n   * Make a directory (or series of nested directories) without throwing an error if it already exists.\n   */\n  async mkdir(filepath, _selfCall = false) {\n    try {\n      await this._mkdir(filepath);\n      return\n    } catch (err) {\n      // If err is null then operation succeeded!\n      if (err === null) return\n      // If the directory already exists, that's OK!\n      if (err.code === 'EEXIST') return\n      // Avoid infinite loops of failure\n      if (_selfCall) throw err\n      // If we got a \"no such file or directory error\" backup and try again.\n      if (err.code === 'ENOENT') {\n        const parent = dirname(filepath);\n        // Check to see if we've gone too far\n        if (parent === '.' || parent === '/' || parent === filepath) throw err\n        // Infinite recursion, what could go wrong?\n        await this.mkdir(parent);\n        await this.mkdir(filepath, true);\n      }\n    }\n  }\n\n  /**\n   * Delete a file without throwing an error if it is already deleted.\n   */\n  async rm(filepath) {\n    try {\n      await this._unlink(filepath);\n    } catch (err) {\n      if (err.code !== 'ENOENT') throw err\n    }\n  }\n\n  /**\n   * Delete a directory without throwing an error if it is already deleted.\n   */\n  async rmdir(filepath, opts) {\n    try {\n      if (opts && opts.recursive) {\n        await this._rm(filepath, opts);\n      } else {\n        await this._rmdir(filepath);\n      }\n    } catch (err) {\n      if (err.code !== 'ENOENT') throw err\n    }\n  }\n\n  /**\n   * Read a directory without throwing an error is the directory doesn't exist\n   */\n  async readdir(filepath) {\n    try {\n      const names = await this._readdir(filepath);\n      // Ordering is not guaranteed, and system specific (Windows vs Unix)\n      // so we must sort them ourselves.\n      names.sort(compareStrings);\n      return names\n    } catch (err) {\n      if (err.code === 'ENOTDIR') return null\n      return []\n    }\n  }\n\n  /**\n   * Return a flast list of all the files nested inside a directory\n   *\n   * Based on an elegant concurrent recursive solution from SO\n   * https://stackoverflow.com/a/45130990/2168416\n   */\n  async readdirDeep(dir) {\n    const subdirs = await this._readdir(dir);\n    const files = await Promise.all(\n      subdirs.map(async subdir => {\n        const res = dir + '/' + subdir;\n        return (await this._stat(res)).isDirectory()\n          ? this.readdirDeep(res)\n          : res\n      })\n    );\n    return files.reduce((a, f) => a.concat(f), [])\n  }\n\n  /**\n   * Return the Stats of a file/symlink if it exists, otherwise returns null.\n   * Rethrows errors that aren't related to file existance.\n   */\n  async lstat(filename) {\n    try {\n      const stats = await this._lstat(filename);\n      return stats\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        return null\n      }\n      throw err\n    }\n  }\n\n  /**\n   * Reads the contents of a symlink if it exists, otherwise returns null.\n   * Rethrows errors that aren't related to file existance.\n   */\n  async readlink(filename, opts = { encoding: 'buffer' }) {\n    // Note: FileSystem.readlink returns a buffer by default\n    // so we can dump it into GitObject.write just like any other file.\n    try {\n      const link = await this._readlink(filename, opts);\n      return Buffer.isBuffer(link) ? link : Buffer.from(link)\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        return null\n      }\n      throw err\n    }\n  }\n\n  /**\n   * Write the contents of buffer to a symlink.\n   */\n  async writelink(filename, buffer) {\n    return this._symlink(buffer.toString('utf8'), filename)\n  }\n}\n\nfunction assertParameter(name, value) {\n  if (value === undefined) {\n    throw new MissingParameterError(name)\n  }\n}\n\n// @ts-check\n/**\n *\n * @param {WalkerEntry} entry\n * @param {WalkerEntry} base\n *\n */\nasync function modified(entry, base) {\n  if (!entry && !base) return false\n  if (entry && !base) return true\n  if (!entry && base) return true\n  if ((await entry.type()) === 'tree' && (await base.type()) === 'tree') {\n    return false\n  }\n  if (\n    (await entry.type()) === (await base.type()) &&\n    (await entry.mode()) === (await base.mode()) &&\n    (await entry.oid()) === (await base.oid())\n  ) {\n    return false\n  }\n  return true\n}\n\n// @ts-check\n\n/**\n * Abort a merge in progress.\n *\n * Based on the behavior of git reset --merge, i.e.  \"Resets the index and updates the files in the working tree that are different between <commit> and HEAD, but keeps those which are different between the index and working tree (i.e. which have changes which have not been added). If a file that is different between <commit> and the index has unstaged changes, reset is aborted.\"\n *\n * Essentially, abortMerge will reset any files affected by merge conflicts to their last known good version at HEAD.\n * Any unstaged changes are saved and any staged changes are reset as well.\n *\n * NOTE: The behavior of this command differs slightly from canonical git in that an error will be thrown if a file exists in the index and nowhere else.\n * Canonical git will reset the file and continue aborting the merge in this case.\n *\n * **WARNING:** Running git merge with non-trivial uncommitted changes is discouraged: while possible, it may leave you in a state that is hard to back out of in the case of a conflict.\n * If there were uncommitted changes when the merge started (and especially if those changes were further modified after the merge was started), `git.abortMerge` will in some cases be unable to reconstruct the original (pre-merge) changes.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.commit='HEAD'] - commit to reset the index and worktree to, defaults to HEAD\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully once the git index has been updated\n *\n */\nasync function abortMerge({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  commit = 'HEAD',\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('dir', dir);\n    assertParameter('gitdir', gitdir);\n\n    const fs = new FileSystem(_fs);\n    const trees = [TREE({ ref: commit }), WORKDIR(), STAGE()];\n    let unmergedPaths = [];\n\n    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {\n      unmergedPaths = index.unmergedPaths;\n    });\n\n    const results = await _walk({\n      fs,\n      cache,\n      dir,\n      gitdir,\n      trees,\n      map: async function(path, [head, workdir, index]) {\n        const staged = !(await modified(workdir, index));\n        const unmerged = unmergedPaths.includes(path);\n        const unmodified = !(await modified(index, head));\n\n        if (staged || unmerged) {\n          return head\n            ? {\n                path,\n                mode: await head.mode(),\n                oid: await head.oid(),\n                type: await head.type(),\n                content: await head.content(),\n              }\n            : undefined\n        }\n\n        if (unmodified) return false\n        else throw new IndexResetError(path)\n      },\n    });\n\n    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {\n      // Reset paths in index and worktree, this can't be done in _walk because the\n      // STAGE walker acquires its own index lock.\n\n      for (const entry of results) {\n        if (entry === false) continue\n\n        // entry is not false, so from here we can assume index = workdir\n        if (!entry) {\n          await fs.rmdir(`${dir}/${entry.path}`, { recursive: true });\n          index.delete({ filepath: entry.path });\n          continue\n        }\n\n        if (entry.type === 'blob') {\n          const content = new TextDecoder().decode(entry.content);\n          await fs.write(`${dir}/${entry.path}`, content, { mode: entry.mode });\n          index.insert({\n            filepath: entry.path,\n            oid: entry.oid,\n            stage: 0,\n          });\n        }\n      }\n    });\n  } catch (err) {\n    err.caller = 'git.abortMerge';\n    throw err\n  }\n}\n\n// I'm putting this in a Manager because I reckon it could benefit\n// from a LOT of cacheing.\nclass GitIgnoreManager {\n  static async isIgnored({ fs, dir, gitdir = join(dir, '.git'), filepath }) {\n    // ALWAYS ignore \".git\" folders.\n    if (basename(filepath) === '.git') return true\n    // '.' is not a valid gitignore entry, so '.' is never ignored\n    if (filepath === '.') return false\n    // Check and load exclusion rules from project exclude file (.git/info/exclude)\n    let excludes = '';\n    const excludesFile = join(gitdir, 'info', 'exclude');\n    if (await fs.exists(excludesFile)) {\n      excludes = await fs.read(excludesFile, 'utf8');\n    }\n    // Find all the .gitignore files that could affect this file\n    const pairs = [\n      {\n        gitignore: join(dir, '.gitignore'),\n        filepath,\n      },\n    ];\n    const pieces = filepath.split('/').filter(Boolean);\n    for (let i = 1; i < pieces.length; i++) {\n      const folder = pieces.slice(0, i).join('/');\n      const file = pieces.slice(i).join('/');\n      pairs.push({\n        gitignore: join(dir, folder, '.gitignore'),\n        filepath: file,\n      });\n    }\n    let ignoredStatus = false;\n    for (const p of pairs) {\n      let file;\n      try {\n        file = await fs.read(p.gitignore, 'utf8');\n      } catch (err) {\n        if (err.code === 'NOENT') continue\n      }\n      const ign = ignore().add(excludes);\n      ign.add(file);\n      // If the parent directory is excluded, we are done.\n      // \"It is not possible to re-include a file if a parent directory of that file is excluded. Git doesnt list excluded directories for performance reasons, so any patterns on contained files have no effect, no matter where they are defined.\"\n      // source: https://git-scm.com/docs/gitignore\n      const parentdir = dirname(p.filepath);\n      if (parentdir !== '.' && ign.ignores(parentdir)) return true\n      // If the file is currently ignored, test for UNignoring.\n      if (ignoredStatus) {\n        ignoredStatus = !ign.test(p.filepath).unignored;\n      } else {\n        ignoredStatus = ign.test(p.filepath).ignored;\n      }\n    }\n    return ignoredStatus\n  }\n}\n\nasync function writeObjectLoose({ fs, gitdir, object, format, oid }) {\n  if (format !== 'deflated') {\n    throw new InternalError(\n      'GitObjectStoreLoose expects objects to write to be in deflated format'\n    )\n  }\n  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;\n  const filepath = `${gitdir}/${source}`;\n  // Don't overwrite existing git objects - this helps avoid EPERM errors.\n  // Although I don't know how we'd fix corrupted objects then. Perhaps delete them\n  // on read?\n  if (!(await fs.exists(filepath))) await fs.write(filepath, object);\n}\n\n/* eslint-env node, browser */\n\nlet supportsCompressionStream = null;\n\nasync function deflate(buffer) {\n  if (supportsCompressionStream === null) {\n    supportsCompressionStream = testCompressionStream();\n  }\n  return supportsCompressionStream\n    ? browserDeflate(buffer)\n    : pako.deflate(buffer)\n}\n\nasync function browserDeflate(buffer) {\n  const cs = new CompressionStream('deflate');\n  const c = new Blob([buffer]).stream().pipeThrough(cs);\n  return new Uint8Array(await new Response(c).arrayBuffer())\n}\n\nfunction testCompressionStream() {\n  try {\n    const cs = new CompressionStream('deflate');\n    // Test if `Blob.stream` is present. React Native does not have the `stream` method\n    new Blob([]).stream();\n    if (cs) return true\n  } catch (_) {\n    // no bother\n  }\n  return false\n}\n\nasync function _writeObject({\n  fs,\n  gitdir,\n  type,\n  object,\n  format = 'content',\n  oid = undefined,\n  dryRun = false,\n}) {\n  if (format !== 'deflated') {\n    if (format !== 'wrapped') {\n      object = GitObject.wrap({ type, object });\n    }\n    oid = await shasum(object);\n    object = Buffer.from(await deflate(object));\n  }\n  if (!dryRun) {\n    await writeObjectLoose({ fs, gitdir, object, format: 'deflated', oid });\n  }\n  return oid\n}\n\nfunction posixifyPathBuffer(buffer) {\n  let idx;\n  while (~(idx = buffer.indexOf(92))) buffer[idx] = 47;\n  return buffer\n}\n\n// @ts-check\n\n/**\n * Add a file to the git index (aka staging area)\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string|string[]} args.filepath - The path to the file to add to the index\n * @param {object} [args.cache] - a [cache](cache.md) object\n * @param {boolean} [args.force=false] - add to index even if matches gitignore. Think `git add --force`\n * @param {boolean} [args.parallel=false] - process each input file in parallel. Parallel processing will result in more memory consumption but less process time\n *\n * @returns {Promise<void>} Resolves successfully once the git index has been updated\n *\n * @example\n * await fs.promises.writeFile('/tutorial/README.md', `# TEST`)\n * await git.add({ fs, dir: '/tutorial', filepath: 'README.md' })\n * console.log('done')\n *\n */\nasync function add({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath,\n  cache = {},\n  force = false,\n  parallel = true,\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('dir', dir);\n    assertParameter('gitdir', gitdir);\n    assertParameter('filepath', filepath);\n\n    const fs = new FileSystem(_fs);\n    await GitIndexManager.acquire({ fs, gitdir, cache }, async index => {\n      return addToIndex({\n        dir,\n        gitdir,\n        fs,\n        filepath,\n        index,\n        force,\n        parallel,\n      })\n    });\n  } catch (err) {\n    err.caller = 'git.add';\n    throw err\n  }\n}\n\nasync function addToIndex({\n  dir,\n  gitdir,\n  fs,\n  filepath,\n  index,\n  force,\n  parallel,\n}) {\n  // TODO: Should ignore UNLESS it's already in the index.\n  filepath = Array.isArray(filepath) ? filepath : [filepath];\n  const promises = filepath.map(async currentFilepath => {\n    if (!force) {\n      const ignored = await GitIgnoreManager.isIgnored({\n        fs,\n        dir,\n        gitdir,\n        filepath: currentFilepath,\n      });\n      if (ignored) return\n    }\n    const stats = await fs.lstat(join(dir, currentFilepath));\n    if (!stats) throw new NotFoundError(currentFilepath)\n\n    if (stats.isDirectory()) {\n      const children = await fs.readdir(join(dir, currentFilepath));\n      if (parallel) {\n        const promises = children.map(child =>\n          addToIndex({\n            dir,\n            gitdir,\n            fs,\n            filepath: [join(currentFilepath, child)],\n            index,\n            force,\n            parallel,\n          })\n        );\n        await Promise.all(promises);\n      } else {\n        for (const child of children) {\n          await addToIndex({\n            dir,\n            gitdir,\n            fs,\n            filepath: [join(currentFilepath, child)],\n            index,\n            force,\n            parallel,\n          });\n        }\n      }\n    } else {\n      const object = stats.isSymbolicLink()\n        ? await fs.readlink(join(dir, currentFilepath)).then(posixifyPathBuffer)\n        : await fs.read(join(dir, currentFilepath));\n      if (object === null) throw new NotFoundError(currentFilepath)\n      const oid = await _writeObject({ fs, gitdir, type: 'blob', object });\n      index.insert({ filepath: currentFilepath, stats, oid });\n    }\n  });\n\n  const settledPromises = await Promise.allSettled(promises);\n  const rejectedPromises = settledPromises\n    .filter(settle => settle.status === 'rejected')\n    .map(settle => settle.reason);\n  if (rejectedPromises.length > 1) {\n    throw new MultipleGitError(rejectedPromises)\n  }\n  if (rejectedPromises.length === 1) {\n    throw rejectedPromises[0]\n  }\n\n  const fulfilledPromises = settledPromises\n    .filter(settle => settle.status === 'fulfilled' && settle.value)\n    .map(settle => settle.value);\n\n  return fulfilledPromises\n}\n\n// @ts-check\n\n/**\n *\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {SignCallback} [args.onSign]\n * @param {string} args.gitdir\n * @param {string} args.message\n * @param {Object} args.author\n * @param {string} args.author.name\n * @param {string} args.author.email\n * @param {number} args.author.timestamp\n * @param {number} args.author.timezoneOffset\n * @param {Object} args.committer\n * @param {string} args.committer.name\n * @param {string} args.committer.email\n * @param {number} args.committer.timestamp\n * @param {number} args.committer.timezoneOffset\n * @param {string} [args.signingKey]\n * @param {boolean} [args.dryRun = false]\n * @param {boolean} [args.noUpdateBranch = false]\n * @param {string} [args.ref]\n * @param {string[]} [args.parent]\n * @param {string} [args.tree]\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly created commit.\n */\nasync function _commit({\n  fs,\n  cache,\n  onSign,\n  gitdir,\n  message,\n  author,\n  committer,\n  signingKey,\n  dryRun = false,\n  noUpdateBranch = false,\n  ref,\n  parent,\n  tree,\n}) {\n  if (!ref) {\n    ref = await GitRefManager.resolve({\n      fs,\n      gitdir,\n      ref: 'HEAD',\n      depth: 2,\n    });\n  }\n\n  return GitIndexManager.acquire(\n    { fs, gitdir, cache, allowUnmerged: false },\n    async function(index) {\n      const inodes = flatFileListToDirectoryStructure(index.entries);\n      const inode = inodes.get('.');\n      if (!tree) {\n        tree = await constructTree({ fs, gitdir, inode, dryRun });\n      }\n      if (!parent) {\n        try {\n          parent = [\n            await GitRefManager.resolve({\n              fs,\n              gitdir,\n              ref,\n            }),\n          ];\n        } catch (err) {\n          // Probably an initial commit\n          parent = [];\n        }\n      } else {\n        // ensure that the parents are oids, not refs\n        parent = await Promise.all(\n          parent.map(p => {\n            return GitRefManager.resolve({ fs, gitdir, ref: p })\n          })\n        );\n      }\n\n      let comm = GitCommit.from({\n        tree,\n        parent,\n        author,\n        committer,\n        message,\n      });\n      if (signingKey) {\n        comm = await GitCommit.sign(comm, onSign, signingKey);\n      }\n      const oid = await _writeObject({\n        fs,\n        gitdir,\n        type: 'commit',\n        object: comm.toObject(),\n        dryRun,\n      });\n      if (!noUpdateBranch && !dryRun) {\n        // Update branch pointer\n        await GitRefManager.writeRef({\n          fs,\n          gitdir,\n          ref,\n          value: oid,\n        });\n      }\n      return oid\n    }\n  )\n}\n\nasync function constructTree({ fs, gitdir, inode, dryRun }) {\n  // use depth first traversal\n  const children = inode.children;\n  for (const inode of children) {\n    if (inode.type === 'tree') {\n      inode.metadata.mode = '040000';\n      inode.metadata.oid = await constructTree({ fs, gitdir, inode, dryRun });\n    }\n  }\n  const entries = children.map(inode => ({\n    mode: inode.metadata.mode,\n    path: inode.basename,\n    oid: inode.metadata.oid,\n    type: inode.type,\n  }));\n  const tree = GitTree.from(entries);\n  const oid = await _writeObject({\n    fs,\n    gitdir,\n    type: 'tree',\n    object: tree.toObject(),\n    dryRun,\n  });\n  return oid\n}\n\n// @ts-check\n\nasync function resolveFilepath({ fs, cache, gitdir, oid, filepath }) {\n  // Ensure there are no leading or trailing directory separators.\n  // I was going to do this automatically, but then found that the Git Terminal for Windows\n  // auto-expands --filepath=/src/utils to --filepath=C:/Users/Will/AppData/Local/Programs/Git/src/utils\n  // so I figured it would be wise to promote the behavior in the application layer not just the library layer.\n  if (filepath.startsWith('/')) {\n    throw new InvalidFilepathError('leading-slash')\n  } else if (filepath.endsWith('/')) {\n    throw new InvalidFilepathError('trailing-slash')\n  }\n  const _oid = oid;\n  const result = await resolveTree({ fs, cache, gitdir, oid });\n  const tree = result.tree;\n  if (filepath === '') {\n    oid = result.oid;\n  } else {\n    const pathArray = filepath.split('/');\n    oid = await _resolveFilepath({\n      fs,\n      cache,\n      gitdir,\n      tree,\n      pathArray,\n      oid: _oid,\n      filepath,\n    });\n  }\n  return oid\n}\n\nasync function _resolveFilepath({\n  fs,\n  cache,\n  gitdir,\n  tree,\n  pathArray,\n  oid,\n  filepath,\n}) {\n  const name = pathArray.shift();\n  for (const entry of tree) {\n    if (entry.path === name) {\n      if (pathArray.length === 0) {\n        return entry.oid\n      } else {\n        const { type, object } = await _readObject({\n          fs,\n          cache,\n          gitdir,\n          oid: entry.oid,\n        });\n        if (type !== 'tree') {\n          throw new ObjectTypeError(oid, type, 'tree', filepath)\n        }\n        tree = GitTree.from(object);\n        return _resolveFilepath({\n          fs,\n          cache,\n          gitdir,\n          tree,\n          pathArray,\n          oid,\n          filepath,\n        })\n      }\n    }\n  }\n  throw new NotFoundError(`file or directory found at \"${oid}:${filepath}\"`)\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} ReadTreeResult - The object returned has the following schema:\n * @property {string} oid - SHA-1 object id of this tree\n * @property {TreeObject} tree - the parsed tree object\n */\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} args.oid\n * @param {string} [args.filepath]\n *\n * @returns {Promise<ReadTreeResult>}\n */\nasync function _readTree({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  filepath = undefined,\n}) {\n  if (filepath !== undefined) {\n    oid = await resolveFilepath({ fs, cache, gitdir, oid, filepath });\n  }\n  const { tree, oid: treeOid } = await resolveTree({ fs, cache, gitdir, oid });\n  const result = {\n    oid: treeOid,\n    tree: tree.entries(),\n  };\n  return result\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {TreeObject} args.tree\n *\n * @returns {Promise<string>}\n */\nasync function _writeTree({ fs, gitdir, tree }) {\n  // Convert object to buffer\n  const object = GitTree.from(tree).toObject();\n  const oid = await _writeObject({\n    fs,\n    gitdir,\n    type: 'tree',\n    object,\n    format: 'content',\n  });\n  return oid\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {SignCallback} [args.onSign]\n * @param {string} args.gitdir\n * @param {string} args.ref\n * @param {string} args.oid\n * @param {string|Uint8Array} args.note\n * @param {boolean} [args.force]\n * @param {Object} args.author\n * @param {string} args.author.name\n * @param {string} args.author.email\n * @param {number} args.author.timestamp\n * @param {number} args.author.timezoneOffset\n * @param {Object} args.committer\n * @param {string} args.committer.name\n * @param {string} args.committer.email\n * @param {number} args.committer.timestamp\n * @param {number} args.committer.timezoneOffset\n * @param {string} [args.signingKey]\n *\n * @returns {Promise<string>}\n */\n\nasync function _addNote({\n  fs,\n  cache,\n  onSign,\n  gitdir,\n  ref,\n  oid,\n  note,\n  force,\n  author,\n  committer,\n  signingKey,\n}) {\n  // Get the current note commit\n  let parent;\n  try {\n    parent = await GitRefManager.resolve({ gitdir, fs, ref });\n  } catch (err) {\n    if (!(err instanceof NotFoundError)) {\n      throw err\n    }\n  }\n\n  // I'm using the \"empty tree\" magic number here for brevity\n  const result = await _readTree({\n    fs,\n    cache,\n    gitdir,\n    oid: parent || '4b825dc642cb6eb9a060e54bf8d69288fbee4904',\n  });\n  let tree = result.tree;\n\n  // Handle the case where a note already exists\n  if (force) {\n    tree = tree.filter(entry => entry.path !== oid);\n  } else {\n    for (const entry of tree) {\n      if (entry.path === oid) {\n        throw new AlreadyExistsError('note', oid)\n      }\n    }\n  }\n\n  // Create the note blob\n  if (typeof note === 'string') {\n    note = Buffer.from(note, 'utf8');\n  }\n  const noteOid = await _writeObject({\n    fs,\n    gitdir,\n    type: 'blob',\n    object: note,\n    format: 'content',\n  });\n\n  // Create the new note tree\n  tree.push({ mode: '100644', path: oid, oid: noteOid, type: 'blob' });\n  const treeOid = await _writeTree({\n    fs,\n    gitdir,\n    tree,\n  });\n\n  // Create the new note commit\n  const commitOid = await _commit({\n    fs,\n    cache,\n    onSign,\n    gitdir,\n    ref,\n    tree: treeOid,\n    parent: parent && [parent],\n    message: `Note added by 'isomorphic-git addNote'\\n`,\n    author,\n    committer,\n    signingKey,\n  });\n\n  return commitOid\n}\n\n// @ts-check\n\n/**\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.path\n *\n * @returns {Promise<any>} Resolves with the config value\n *\n * @example\n * // Read config value\n * let value = await git.getConfig({\n *   dir: '$input((/))',\n *   path: '$input((user.name))'\n * })\n * console.log(value)\n *\n */\nasync function _getConfig({ fs, gitdir, path }) {\n  const config = await GitConfigManager.get({ fs, gitdir });\n  return config.get(path)\n}\n\n/**\n *\n * @returns {Promise<void | {name: string, email: string, date: Date, timestamp: number, timezoneOffset: number }>}\n */\nasync function normalizeAuthorObject({ fs, gitdir, author = {} }) {\n  let { name, email, timestamp, timezoneOffset } = author;\n  name = name || (await _getConfig({ fs, gitdir, path: 'user.name' }));\n  email = email || (await _getConfig({ fs, gitdir, path: 'user.email' })) || '';\n\n  if (name === undefined) {\n    return undefined\n  }\n\n  timestamp = timestamp != null ? timestamp : Math.floor(Date.now() / 1000);\n  timezoneOffset =\n    timezoneOffset != null\n      ? timezoneOffset\n      : new Date(timestamp * 1000).getTimezoneOffset();\n\n  return { name, email, timestamp, timezoneOffset }\n}\n\n/**\n *\n * @returns {Promise<void | {name: string, email: string, timestamp: number, timezoneOffset: number }>}\n */\nasync function normalizeCommitterObject({\n  fs,\n  gitdir,\n  author,\n  committer,\n}) {\n  committer = Object.assign({}, committer || author);\n  // Match committer's date to author's one, if omitted\n  if (author) {\n    committer.timestamp = committer.timestamp || author.timestamp;\n    committer.timezoneOffset = committer.timezoneOffset || author.timezoneOffset;\n  }\n  committer = await normalizeAuthorObject({ fs, gitdir, author: committer });\n  return committer\n}\n\n// @ts-check\n\n/**\n * Add or update an object note\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {SignCallback} [args.onSign] - a PGP signing implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - The notes ref to look under\n * @param {string} args.oid - The SHA-1 object id of the object to add the note to.\n * @param {string|Uint8Array} args.note - The note to add\n * @param {boolean} [args.force] - Over-write note if it already exists.\n * @param {Object} [args.author] - The details about the author.\n * @param {string} [args.author.name] - Default is `user.name` config.\n * @param {string} [args.author.email] - Default is `user.email` config.\n * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {Object} [args.committer = author] - The details about the note committer, in the same format as the author parameter. If not specified, the author details are used.\n * @param {string} [args.committer.name] - Default is `user.name` config.\n * @param {string} [args.committer.email] - Default is `user.email` config.\n * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {string} [args.signingKey] - Sign the note commit using this private PGP key.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the commit object for the added note.\n */\n\nasync function addNote({\n  fs: _fs,\n  onSign,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref = 'refs/notes/commits',\n  oid,\n  note,\n  force,\n  author: _author,\n  committer: _committer,\n  signingKey,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n    assertParameter('note', note);\n    if (signingKey) {\n      assertParameter('onSign', onSign);\n    }\n    const fs = new FileSystem(_fs);\n\n    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });\n    if (!author) throw new MissingNameError('author')\n\n    const committer = await normalizeCommitterObject({\n      fs,\n      gitdir,\n      author,\n      committer: _committer,\n    });\n    if (!committer) throw new MissingNameError('committer')\n\n    return await _addNote({\n      fs: new FileSystem(fs),\n      cache,\n      onSign,\n      gitdir,\n      ref,\n      oid,\n      note,\n      force,\n      author,\n      committer,\n      signingKey,\n    })\n  } catch (err) {\n    err.caller = 'git.addNote';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.remote\n * @param {string} args.url\n * @param {boolean} args.force\n *\n * @returns {Promise<void>}\n *\n */\nasync function _addRemote({ fs, gitdir, remote, url, force }) {\n  if (remote !== cleanGitRef.clean(remote)) {\n    throw new InvalidRefNameError(remote, cleanGitRef.clean(remote))\n  }\n  const config = await GitConfigManager.get({ fs, gitdir });\n  if (!force) {\n    // Check that setting it wouldn't overwrite.\n    const remoteNames = await config.getSubsections('remote');\n    if (remoteNames.includes(remote)) {\n      // Throw an error if it would overwrite an existing remote,\n      // but not if it's simply setting the same value again.\n      if (url !== (await config.get(`remote.${remote}.url`))) {\n        throw new AlreadyExistsError('remote', remote)\n      }\n    }\n  }\n  await config.set(`remote.${remote}.url`, url);\n  await config.set(\n    `remote.${remote}.fetch`,\n    `+refs/heads/*:refs/remotes/${remote}/*`\n  );\n  await GitConfigManager.save({ fs, gitdir, config });\n}\n\n// @ts-check\n\n/**\n * Add or update a remote\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.remote - The name of the remote\n * @param {string} args.url - The URL of the remote\n * @param {boolean} [args.force = false] - Instead of throwing an error if a remote named `remote` already exists, overwrite the existing remote.\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.addRemote({\n *   fs,\n *   dir: '/tutorial',\n *   remote: 'upstream',\n *   url: 'https://github.com/isomorphic-git/isomorphic-git'\n * })\n * console.log('done')\n *\n */\nasync function addRemote({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  remote,\n  url,\n  force = false,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('remote', remote);\n    assertParameter('url', url);\n    return await _addRemote({\n      fs: new FileSystem(fs),\n      gitdir,\n      remote,\n      url,\n      force,\n    })\n  } catch (err) {\n    err.caller = 'git.addRemote';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Create an annotated tag.\n *\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {SignCallback} [args.onSign]\n * @param {string} args.gitdir\n * @param {string} args.ref\n * @param {string} [args.message = ref]\n * @param {string} [args.object = 'HEAD']\n * @param {object} [args.tagger]\n * @param {string} args.tagger.name\n * @param {string} args.tagger.email\n * @param {number} args.tagger.timestamp\n * @param {number} args.tagger.timezoneOffset\n * @param {string} [args.gpgsig]\n * @param {string} [args.signingKey]\n * @param {boolean} [args.force = false]\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.annotatedTag({\n *   dir: '$input((/))',\n *   ref: '$input((test-tag))',\n *   message: '$input((This commit is awesome))',\n *   tagger: {\n *     name: '$input((Mr. Test))',\n *     email: '$input((mrtest@example.com))'\n *   }\n * })\n * console.log('done')\n *\n */\nasync function _annotatedTag({\n  fs,\n  cache,\n  onSign,\n  gitdir,\n  ref,\n  tagger,\n  message = ref,\n  gpgsig,\n  object,\n  signingKey,\n  force = false,\n}) {\n  ref = ref.startsWith('refs/tags/') ? ref : `refs/tags/${ref}`;\n\n  if (!force && (await GitRefManager.exists({ fs, gitdir, ref }))) {\n    throw new AlreadyExistsError('tag', ref)\n  }\n\n  // Resolve passed value\n  const oid = await GitRefManager.resolve({\n    fs,\n    gitdir,\n    ref: object || 'HEAD',\n  });\n\n  const { type } = await _readObject({ fs, cache, gitdir, oid });\n  let tagObject = GitAnnotatedTag.from({\n    object: oid,\n    type,\n    tag: ref.replace('refs/tags/', ''),\n    tagger,\n    message,\n    gpgsig,\n  });\n  if (signingKey) {\n    tagObject = await GitAnnotatedTag.sign(tagObject, onSign, signingKey);\n  }\n  const value = await _writeObject({\n    fs,\n    gitdir,\n    type: 'tag',\n    object: tagObject.toObject(),\n  });\n\n  await GitRefManager.writeRef({ fs, gitdir, ref, value });\n}\n\n// @ts-check\n\n/**\n * Create an annotated tag.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {SignCallback} [args.onSign] - a PGP signing implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - What to name the tag\n * @param {string} [args.message = ref] - The tag message to use.\n * @param {string} [args.object = 'HEAD'] - The SHA-1 object id the tag points to. (Will resolve to a SHA-1 object id if value is a ref.) By default, the commit object which is referred by the current `HEAD` is used.\n * @param {object} [args.tagger] - The details about the tagger.\n * @param {string} [args.tagger.name] - Default is `user.name` config.\n * @param {string} [args.tagger.email] - Default is `user.email` config.\n * @param {number} [args.tagger.timestamp=Math.floor(Date.now()/1000)] - Set the tagger timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.tagger.timezoneOffset] - Set the tagger timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {string} [args.gpgsig] - The gpgsig attatched to the tag object. (Mutually exclusive with the `signingKey` option.)\n * @param {string} [args.signingKey] - Sign the tag object using this private PGP key. (Mutually exclusive with the `gpgsig` option.)\n * @param {boolean} [args.force = false] - Instead of throwing an error if a tag named `ref` already exists, overwrite the existing tag. Note that this option does not modify the original tag object itself.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.annotatedTag({\n *   fs,\n *   dir: '/tutorial',\n *   ref: 'test-tag',\n *   message: 'This commit is awesome',\n *   tagger: {\n *     name: 'Mr. Test',\n *     email: 'mrtest@example.com'\n *   }\n * })\n * console.log('done')\n *\n */\nasync function annotatedTag({\n  fs: _fs,\n  onSign,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  tagger: _tagger,\n  message = ref,\n  gpgsig,\n  object,\n  signingKey,\n  force = false,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    if (signingKey) {\n      assertParameter('onSign', onSign);\n    }\n    const fs = new FileSystem(_fs);\n\n    // Fill in missing arguments with default values\n    const tagger = await normalizeAuthorObject({ fs, gitdir, author: _tagger });\n    if (!tagger) throw new MissingNameError('tagger')\n\n    return await _annotatedTag({\n      fs,\n      cache,\n      onSign,\n      gitdir,\n      ref,\n      tagger,\n      message,\n      gpgsig,\n      object,\n      signingKey,\n      force,\n    })\n  } catch (err) {\n    err.caller = 'git.annotatedTag';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Create a branch\n *\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.ref\n * @param {string} [args.object = 'HEAD']\n * @param {boolean} [args.checkout = false]\n * @param {boolean} [args.force = false]\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.branch({ dir: '$input((/))', ref: '$input((develop))' })\n * console.log('done')\n *\n */\nasync function _branch({\n  fs,\n  gitdir,\n  ref,\n  object,\n  checkout = false,\n  force = false,\n}) {\n  if (ref !== cleanGitRef.clean(ref)) {\n    throw new InvalidRefNameError(ref, cleanGitRef.clean(ref))\n  }\n\n  const fullref = `refs/heads/${ref}`;\n\n  if (!force) {\n    const exist = await GitRefManager.exists({ fs, gitdir, ref: fullref });\n    if (exist) {\n      throw new AlreadyExistsError('branch', ref, false)\n    }\n  }\n\n  // Get current HEAD tree oid\n  let oid;\n  try {\n    oid = await GitRefManager.resolve({ fs, gitdir, ref: object || 'HEAD' });\n  } catch (e) {\n    // Probably an empty repo\n  }\n\n  // Create a new ref that points at the current commit\n  if (oid) {\n    await GitRefManager.writeRef({ fs, gitdir, ref: fullref, value: oid });\n  }\n\n  if (checkout) {\n    // Update HEAD\n    await GitRefManager.writeSymbolicRef({\n      fs,\n      gitdir,\n      ref: 'HEAD',\n      value: fullref,\n    });\n  }\n}\n\n// @ts-check\n\n/**\n * Create a branch\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - What to name the branch\n * @param {string} [args.object = 'HEAD'] - What oid to use as the start point. Accepts a symbolic ref.\n * @param {boolean} [args.checkout = false] - Update `HEAD` to point at the newly created branch\n * @param {boolean} [args.force = false] - Instead of throwing an error if a branched named `ref` already exists, overwrite the existing branch.\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.branch({ fs, dir: '/tutorial', ref: 'develop' })\n * console.log('done')\n *\n */\nasync function branch({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  object,\n  checkout = false,\n  force = false,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    return await _branch({\n      fs: new FileSystem(fs),\n      gitdir,\n      ref,\n      object,\n      checkout,\n      force,\n    })\n  } catch (err) {\n    err.caller = 'git.branch';\n    throw err\n  }\n}\n\nconst worthWalking = (filepath, root) => {\n  if (filepath === '.' || root == null || root.length === 0 || root === '.') {\n    return true\n  }\n  if (root.length >= filepath.length) {\n    return root.startsWith(filepath)\n  } else {\n    return filepath.startsWith(root)\n  }\n};\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {ProgressCallback} [args.onProgress]\n * @param {string} args.dir\n * @param {string} args.gitdir\n * @param {string} args.ref\n * @param {string[]} [args.filepaths]\n * @param {string} args.remote\n * @param {boolean} args.noCheckout\n * @param {boolean} [args.noUpdateHead]\n * @param {boolean} [args.dryRun]\n * @param {boolean} [args.force]\n * @param {boolean} [args.track]\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n */\nasync function _checkout({\n  fs,\n  cache,\n  onProgress,\n  dir,\n  gitdir,\n  remote,\n  ref,\n  filepaths,\n  noCheckout,\n  noUpdateHead,\n  dryRun,\n  force,\n  track = true,\n}) {\n  // Get tree oid\n  let oid;\n  try {\n    oid = await GitRefManager.resolve({ fs, gitdir, ref });\n    // TODO: Figure out what to do if both 'ref' and 'remote' are specified, ref already exists,\n    // and is configured to track a different remote.\n  } catch (err) {\n    if (ref === 'HEAD') throw err\n    // If `ref` doesn't exist, create a new remote tracking branch\n    // Figure out the commit to checkout\n    const remoteRef = `${remote}/${ref}`;\n    oid = await GitRefManager.resolve({\n      fs,\n      gitdir,\n      ref: remoteRef,\n    });\n    if (track) {\n      // Set up remote tracking branch\n      const config = await GitConfigManager.get({ fs, gitdir });\n      await config.set(`branch.${ref}.remote`, remote);\n      await config.set(`branch.${ref}.merge`, `refs/heads/${ref}`);\n      await GitConfigManager.save({ fs, gitdir, config });\n    }\n    // Create a new branch that points at that same commit\n    await GitRefManager.writeRef({\n      fs,\n      gitdir,\n      ref: `refs/heads/${ref}`,\n      value: oid,\n    });\n  }\n\n  // Update working dir\n  if (!noCheckout) {\n    let ops;\n    // First pass - just analyze files (not directories) and figure out what needs to be done\n    try {\n      ops = await analyze({\n        fs,\n        cache,\n        onProgress,\n        dir,\n        gitdir,\n        ref,\n        force,\n        filepaths,\n      });\n    } catch (err) {\n      // Throw a more helpful error message for this common mistake.\n      if (err instanceof NotFoundError && err.data.what === oid) {\n        throw new CommitNotFetchedError(ref, oid)\n      } else {\n        throw err\n      }\n    }\n\n    // Report conflicts\n    const conflicts = ops\n      .filter(([method]) => method === 'conflict')\n      .map(([method, fullpath]) => fullpath);\n    if (conflicts.length > 0) {\n      throw new CheckoutConflictError(conflicts)\n    }\n\n    // Collect errors\n    const errors = ops\n      .filter(([method]) => method === 'error')\n      .map(([method, fullpath]) => fullpath);\n    if (errors.length > 0) {\n      throw new InternalError(errors.join(', '))\n    }\n\n    if (dryRun) {\n      // Since the format of 'ops' is in flux, I really would rather folk besides myself not start relying on it\n      // return ops\n      return\n    }\n\n    // Second pass - execute planned changes\n    // The cheapest semi-parallel solution without computing a full dependency graph will be\n    // to just do ops in 4 dumb phases: delete files, delete dirs, create dirs, write files\n\n    let count = 0;\n    const total = ops.length;\n    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {\n      await Promise.all(\n        ops\n          .filter(\n            ([method]) => method === 'delete' || method === 'delete-index'\n          )\n          .map(async function([method, fullpath]) {\n            const filepath = `${dir}/${fullpath}`;\n            if (method === 'delete') {\n              await fs.rm(filepath);\n            }\n            index.delete({ filepath: fullpath });\n            if (onProgress) {\n              await onProgress({\n                phase: 'Updating workdir',\n                loaded: ++count,\n                total,\n              });\n            }\n          })\n      );\n    });\n\n    // Note: this is cannot be done naively in parallel\n    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {\n      for (const [method, fullpath] of ops) {\n        if (method === 'rmdir' || method === 'rmdir-index') {\n          const filepath = `${dir}/${fullpath}`;\n          try {\n            if (method === 'rmdir-index') {\n              index.delete({ filepath: fullpath });\n            }\n            await fs.rmdir(filepath);\n            if (onProgress) {\n              await onProgress({\n                phase: 'Updating workdir',\n                loaded: ++count,\n                total,\n              });\n            }\n          } catch (e) {\n            if (e.code === 'ENOTEMPTY') {\n              console.log(\n                `Did not delete ${fullpath} because directory is not empty`\n              );\n            } else {\n              throw e\n            }\n          }\n        }\n      }\n    });\n\n    await Promise.all(\n      ops\n        .filter(([method]) => method === 'mkdir' || method === 'mkdir-index')\n        .map(async function([_, fullpath]) {\n          const filepath = `${dir}/${fullpath}`;\n          await fs.mkdir(filepath);\n          if (onProgress) {\n            await onProgress({\n              phase: 'Updating workdir',\n              loaded: ++count,\n              total,\n            });\n          }\n        })\n    );\n\n    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {\n      await Promise.all(\n        ops\n          .filter(\n            ([method]) =>\n              method === 'create' ||\n              method === 'create-index' ||\n              method === 'update' ||\n              method === 'mkdir-index'\n          )\n          .map(async function([method, fullpath, oid, mode, chmod]) {\n            const filepath = `${dir}/${fullpath}`;\n            try {\n              if (method !== 'create-index' && method !== 'mkdir-index') {\n                const { object } = await _readObject({ fs, cache, gitdir, oid });\n                if (chmod) {\n                  // Note: the mode option of fs.write only works when creating files,\n                  // not updating them. Since the `fs` plugin doesn't expose `chmod` this\n                  // is our only option.\n                  await fs.rm(filepath);\n                }\n                if (mode === 0o100644) {\n                  // regular file\n                  await fs.write(filepath, object);\n                } else if (mode === 0o100755) {\n                  // executable file\n                  await fs.write(filepath, object, { mode: 0o777 });\n                } else if (mode === 0o120000) {\n                  // symlink\n                  await fs.writelink(filepath, object);\n                } else {\n                  throw new InternalError(\n                    `Invalid mode 0o${mode.toString(8)} detected in blob ${oid}`\n                  )\n                }\n              }\n\n              const stats = await fs.lstat(filepath);\n              // We can't trust the executable bit returned by lstat on Windows,\n              // so we need to preserve this value from the TREE.\n              // TODO: Figure out how git handles this internally.\n              if (mode === 0o100755) {\n                stats.mode = 0o755;\n              }\n              // Submodules are present in the git index but use a unique mode different from trees\n              if (method === 'mkdir-index') {\n                stats.mode = 0o160000;\n              }\n              index.insert({\n                filepath: fullpath,\n                stats,\n                oid,\n              });\n              if (onProgress) {\n                await onProgress({\n                  phase: 'Updating workdir',\n                  loaded: ++count,\n                  total,\n                });\n              }\n            } catch (e) {\n              console.log(e);\n            }\n          })\n      );\n    });\n  }\n\n  // Update HEAD\n  if (!noUpdateHead) {\n    const fullRef = await GitRefManager.expand({ fs, gitdir, ref });\n    if (fullRef.startsWith('refs/heads')) {\n      await GitRefManager.writeSymbolicRef({\n        fs,\n        gitdir,\n        ref: 'HEAD',\n        value: fullRef,\n      });\n    } else {\n      // detached head\n      await GitRefManager.writeRef({ fs, gitdir, ref: 'HEAD', value: oid });\n    }\n  }\n}\n\nasync function analyze({\n  fs,\n  cache,\n  onProgress,\n  dir,\n  gitdir,\n  ref,\n  force,\n  filepaths,\n}) {\n  let count = 0;\n  return _walk({\n    fs,\n    cache,\n    dir,\n    gitdir,\n    trees: [TREE({ ref }), WORKDIR(), STAGE()],\n    map: async function(fullpath, [commit, workdir, stage]) {\n      if (fullpath === '.') return\n      // match against base paths\n      if (filepaths && !filepaths.some(base => worthWalking(fullpath, base))) {\n        return null\n      }\n      // Emit progress event\n      if (onProgress) {\n        await onProgress({ phase: 'Analyzing workdir', loaded: ++count });\n      }\n\n      // This is a kind of silly pattern but it worked so well for me in the past\n      // and it makes intuitively demonstrating exhaustiveness so *easy*.\n      // This checks for the presense and/or absence of each of the 3 entries,\n      // converts that to a 3-bit binary representation, and then handles\n      // every possible combination (2^3 or 8 cases) with a lookup table.\n      const key = [!!stage, !!commit, !!workdir].map(Number).join('');\n      switch (key) {\n        // Impossible case.\n        case '000':\n          return\n        // Ignore workdir files that are not tracked and not part of the new commit.\n        case '001':\n          // OK, make an exception for explicitly named files.\n          if (force && filepaths && filepaths.includes(fullpath)) {\n            return ['delete', fullpath]\n          }\n          return\n        // New entries\n        case '010': {\n          switch (await commit.type()) {\n            case 'tree': {\n              return ['mkdir', fullpath]\n            }\n            case 'blob': {\n              return [\n                'create',\n                fullpath,\n                await commit.oid(),\n                await commit.mode(),\n              ]\n            }\n            case 'commit': {\n              return [\n                'mkdir-index',\n                fullpath,\n                await commit.oid(),\n                await commit.mode(),\n              ]\n            }\n            default: {\n              return [\n                'error',\n                `new entry Unhandled type ${await commit.type()}`,\n              ]\n            }\n          }\n        }\n        // New entries but there is already something in the workdir there.\n        case '011': {\n          switch (`${await commit.type()}-${await workdir.type()}`) {\n            case 'tree-tree': {\n              return // noop\n            }\n            case 'tree-blob':\n            case 'blob-tree': {\n              return ['conflict', fullpath]\n            }\n            case 'blob-blob': {\n              // Is the incoming file different?\n              if ((await commit.oid()) !== (await workdir.oid())) {\n                if (force) {\n                  return [\n                    'update',\n                    fullpath,\n                    await commit.oid(),\n                    await commit.mode(),\n                    (await commit.mode()) !== (await workdir.mode()),\n                  ]\n                } else {\n                  return ['conflict', fullpath]\n                }\n              } else {\n                // Is the incoming file a different mode?\n                if ((await commit.mode()) !== (await workdir.mode())) {\n                  if (force) {\n                    return [\n                      'update',\n                      fullpath,\n                      await commit.oid(),\n                      await commit.mode(),\n                      true,\n                    ]\n                  } else {\n                    return ['conflict', fullpath]\n                  }\n                } else {\n                  return [\n                    'create-index',\n                    fullpath,\n                    await commit.oid(),\n                    await commit.mode(),\n                  ]\n                }\n              }\n            }\n            case 'commit-tree': {\n              // TODO: submodule\n              // We'll ignore submodule directories for now.\n              // Users prefer we not throw an error for lack of submodule support.\n              // gitlinks\n              return\n            }\n            case 'commit-blob': {\n              // TODO: submodule\n              // But... we'll complain if there is a *file* where we would\n              // put a submodule if we had submodule support.\n              return ['conflict', fullpath]\n            }\n            default: {\n              return ['error', `new entry Unhandled type ${commit.type}`]\n            }\n          }\n        }\n        // Something in stage but not in the commit OR the workdir.\n        // Note: I verified this behavior against canonical git.\n        case '100': {\n          return ['delete-index', fullpath]\n        }\n        // Deleted entries\n        // TODO: How to handle if stage type and workdir type mismatch?\n        case '101': {\n          switch (await stage.type()) {\n            case 'tree': {\n              return ['rmdir', fullpath]\n            }\n            case 'blob': {\n              // Git checks that the workdir.oid === stage.oid before deleting file\n              if ((await stage.oid()) !== (await workdir.oid())) {\n                if (force) {\n                  return ['delete', fullpath]\n                } else {\n                  return ['conflict', fullpath]\n                }\n              } else {\n                return ['delete', fullpath]\n              }\n            }\n            case 'commit': {\n              return ['rmdir-index', fullpath]\n            }\n            default: {\n              return [\n                'error',\n                `delete entry Unhandled type ${await stage.type()}`,\n              ]\n            }\n          }\n        }\n        /* eslint-disable no-fallthrough */\n        // File missing from workdir\n        case '110':\n        // Possibly modified entries\n        case '111': {\n          /* eslint-enable no-fallthrough */\n          switch (`${await stage.type()}-${await commit.type()}`) {\n            case 'tree-tree': {\n              return\n            }\n            case 'blob-blob': {\n              // If the file hasn't changed, there is no need to do anything.\n              // Existing file modifications in the workdir can be be left as is.\n              if (\n                (await stage.oid()) === (await commit.oid()) &&\n                (await stage.mode()) === (await commit.mode()) &&\n                !force\n              ) {\n                return\n              }\n\n              // Check for local changes that would be lost\n              if (workdir) {\n                // Note: canonical git only compares with the stage. But we're smart enough\n                // to compare to the stage AND the incoming commit.\n                if (\n                  (await workdir.oid()) !== (await stage.oid()) &&\n                  (await workdir.oid()) !== (await commit.oid())\n                ) {\n                  if (force) {\n                    return [\n                      'update',\n                      fullpath,\n                      await commit.oid(),\n                      await commit.mode(),\n                      (await commit.mode()) !== (await workdir.mode()),\n                    ]\n                  } else {\n                    return ['conflict', fullpath]\n                  }\n                }\n              } else if (force) {\n                return [\n                  'update',\n                  fullpath,\n                  await commit.oid(),\n                  await commit.mode(),\n                  (await commit.mode()) !== (await stage.mode()),\n                ]\n              }\n              // Has file mode changed?\n              if ((await commit.mode()) !== (await stage.mode())) {\n                return [\n                  'update',\n                  fullpath,\n                  await commit.oid(),\n                  await commit.mode(),\n                  true,\n                ]\n              }\n              // TODO: HANDLE SYMLINKS\n              // Has the file content changed?\n              if ((await commit.oid()) !== (await stage.oid())) {\n                return [\n                  'update',\n                  fullpath,\n                  await commit.oid(),\n                  await commit.mode(),\n                  false,\n                ]\n              } else {\n                return\n              }\n            }\n            case 'tree-blob': {\n              return ['update-dir-to-blob', fullpath, await commit.oid()]\n            }\n            case 'blob-tree': {\n              return ['update-blob-to-tree', fullpath]\n            }\n            case 'commit-commit': {\n              return [\n                'mkdir-index',\n                fullpath,\n                await commit.oid(),\n                await commit.mode(),\n              ]\n            }\n            default: {\n              return [\n                'error',\n                `update entry Unhandled type ${await stage.type()}-${await commit.type()}`,\n              ]\n            }\n          }\n        }\n      }\n    },\n    // Modify the default flat mapping\n    reduce: async function(parent, children) {\n      children = flat(children);\n      if (!parent) {\n        return children\n      } else if (parent && parent[0] === 'rmdir') {\n        children.push(parent);\n        return children\n      } else {\n        children.unshift(parent);\n        return children\n      }\n    },\n  })\n}\n\n// @ts-check\n\n/**\n * Checkout a branch\n *\n * If the branch already exists it will check out that branch. Otherwise, it will create a new remote tracking branch set to track the remote branch of that name.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {ProgressCallback} [args.onProgress] - optional progress event callback\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref = 'HEAD'] - Source to checkout files from\n * @param {string[]} [args.filepaths] - Limit the checkout to the given files and directories\n * @param {string} [args.remote = 'origin'] - Which remote repository to use\n * @param {boolean} [args.noCheckout = false] - If true, will update HEAD but won't update the working directory\n * @param {boolean} [args.noUpdateHead] - If true, will update the working directory but won't update HEAD. Defaults to `false` when `ref` is provided, and `true` if `ref` is not provided.\n * @param {boolean} [args.dryRun = false] - If true, simulates a checkout so you can test whether it would succeed.\n * @param {boolean} [args.force = false] - If true, conflicts will be ignored and files will be overwritten regardless of local changes.\n * @param {boolean} [args.track = true] - If false, will not set the remote branch tracking information. Defaults to true.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * // switch to the main branch\n * await git.checkout({\n *   fs,\n *   dir: '/tutorial',\n *   ref: 'main'\n * })\n * console.log('done')\n *\n * @example\n * // restore the 'docs' and 'src/docs' folders to the way they were, overwriting any changes\n * await git.checkout({\n *   fs,\n *   dir: '/tutorial',\n *   force: true,\n *   filepaths: ['docs', 'src/docs']\n * })\n * console.log('done')\n *\n * @example\n * // restore the 'docs' and 'src/docs' folders to the way they are in the 'develop' branch, overwriting any changes\n * await git.checkout({\n *   fs,\n *   dir: '/tutorial',\n *   ref: 'develop',\n *   noUpdateHead: true,\n *   force: true,\n *   filepaths: ['docs', 'src/docs']\n * })\n * console.log('done')\n */\nasync function checkout({\n  fs,\n  onProgress,\n  dir,\n  gitdir = join(dir, '.git'),\n  remote = 'origin',\n  ref: _ref,\n  filepaths,\n  noCheckout = false,\n  noUpdateHead = _ref === undefined,\n  dryRun = false,\n  force = false,\n  track = true,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('dir', dir);\n    assertParameter('gitdir', gitdir);\n\n    const ref = _ref || 'HEAD';\n    return await _checkout({\n      fs: new FileSystem(fs),\n      cache,\n      onProgress,\n      dir,\n      gitdir,\n      remote,\n      ref,\n      filepaths,\n      noCheckout,\n      noUpdateHead,\n      dryRun,\n      force,\n      track,\n    })\n  } catch (err) {\n    err.caller = 'git.checkout';\n    throw err\n  }\n}\n\n// @see https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions\nconst abbreviateRx = new RegExp('^refs/(heads/|tags/|remotes/)?(.*)');\n\nfunction abbreviateRef(ref) {\n  const match = abbreviateRx.exec(ref);\n  if (match) {\n    if (match[1] === 'remotes/' && ref.endsWith('/HEAD')) {\n      return match[2].slice(0, -5)\n    } else {\n      return match[2]\n    }\n  }\n  return ref\n}\n\n// @ts-check\n\n/**\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {boolean} [args.fullname = false] - Return the full path (e.g. \"refs/heads/main\") instead of the abbreviated form.\n * @param {boolean} [args.test = false] - If the current branch doesn't actually exist (such as right after git init) then return `undefined`.\n *\n * @returns {Promise<string|void>} The name of the current branch or undefined if the HEAD is detached.\n *\n */\nasync function _currentBranch({\n  fs,\n  gitdir,\n  fullname = false,\n  test = false,\n}) {\n  const ref = await GitRefManager.resolve({\n    fs,\n    gitdir,\n    ref: 'HEAD',\n    depth: 2,\n  });\n  if (test) {\n    try {\n      await GitRefManager.resolve({ fs, gitdir, ref });\n    } catch (_) {\n      return\n    }\n  }\n  // Return `undefined` for detached HEAD\n  if (!ref.startsWith('refs/')) return\n  return fullname ? ref : abbreviateRef(ref)\n}\n\nfunction translateSSHtoHTTP(url) {\n  // handle \"shorter scp-like syntax\"\n  url = url.replace(/^git@([^:]+):/, 'https://$1/');\n  // handle proper SSH URLs\n  url = url.replace(/^ssh:\\/\\//, 'https://');\n  return url\n}\n\nfunction calculateBasicAuthHeader({ username = '', password = '' }) {\n  return `Basic ${Buffer.from(`${username}:${password}`).toString('base64')}`\n}\n\n// Currently 'for await' upsets my linters.\nasync function forAwait(iterable, cb) {\n  const iter = getIterator(iterable);\n  while (true) {\n    const { value, done } = await iter.next();\n    if (value) await cb(value);\n    if (done) break\n  }\n  if (iter.return) iter.return();\n}\n\nasync function collect(iterable) {\n  let size = 0;\n  const buffers = [];\n  // This will be easier once `for await ... of` loops are available.\n  await forAwait(iterable, value => {\n    buffers.push(value);\n    size += value.byteLength;\n  });\n  const result = new Uint8Array(size);\n  let nextIndex = 0;\n  for (const buffer of buffers) {\n    result.set(buffer, nextIndex);\n    nextIndex += buffer.byteLength;\n  }\n  return result\n}\n\nfunction extractAuthFromUrl(url) {\n  // For whatever reason, the `fetch` API does not convert credentials embedded in the URL\n  // into Basic Authentication headers automatically. Instead it throws an error!\n  // So we must manually parse the URL, rip out the user:password portion if it is present\n  // and compute the Authorization header.\n  // Note: I tried using new URL(url) but that throws a security exception in Edge. :rolleyes:\n  let userpass = url.match(/^https?:\\/\\/([^/]+)@/);\n  // No credentials, return the url unmodified and an empty auth object\n  if (userpass == null) return { url, auth: {} }\n  userpass = userpass[1];\n  const [username, password] = userpass.split(':');\n  // Remove credentials from URL\n  url = url.replace(`${userpass}@`, '');\n  // Has credentials, return the fetch-safe URL and the parsed credentials\n  return { url, auth: { username, password } }\n}\n\nfunction padHex(b, n) {\n  const s = n.toString(16);\n  return '0'.repeat(b - s.length) + s\n}\n\n/**\npkt-line Format\n---------------\n\nMuch (but not all) of the payload is described around pkt-lines.\n\nA pkt-line is a variable length binary string.  The first four bytes\nof the line, the pkt-len, indicates the total length of the line,\nin hexadecimal.  The pkt-len includes the 4 bytes used to contain\nthe length's hexadecimal representation.\n\nA pkt-line MAY contain binary data, so implementors MUST ensure\npkt-line parsing/formatting routines are 8-bit clean.\n\nA non-binary line SHOULD BE terminated by an LF, which if present\nMUST be included in the total length. Receivers MUST treat pkt-lines\nwith non-binary data the same whether or not they contain the trailing\nLF (stripping the LF if present, and not complaining when it is\nmissing).\n\nThe maximum length of a pkt-line's data component is 65516 bytes.\nImplementations MUST NOT send pkt-line whose length exceeds 65520\n(65516 bytes of payload + 4 bytes of length data).\n\nImplementations SHOULD NOT send an empty pkt-line (\"0004\").\n\nA pkt-line with a length field of 0 (\"0000\"), called a flush-pkt,\nis a special case and MUST be handled differently than an empty\npkt-line (\"0004\").\n\n----\n  pkt-line     =  data-pkt / flush-pkt\n\n  data-pkt     =  pkt-len pkt-payload\n  pkt-len      =  4*(HEXDIG)\n  pkt-payload  =  (pkt-len - 4)*(OCTET)\n\n  flush-pkt    = \"0000\"\n----\n\nExamples (as C-style strings):\n\n----\n  pkt-line          actual value\n  ---------------------------------\n  \"0006a\\n\"         \"a\\n\"\n  \"0005a\"           \"a\"\n  \"000bfoobar\\n\"    \"foobar\\n\"\n  \"0004\"            \"\"\n----\n*/\n\n// I'm really using this more as a namespace.\n// There's not a lot of \"state\" in a pkt-line\n\nclass GitPktLine {\n  static flush() {\n    return Buffer.from('0000', 'utf8')\n  }\n\n  static delim() {\n    return Buffer.from('0001', 'utf8')\n  }\n\n  static encode(line) {\n    if (typeof line === 'string') {\n      line = Buffer.from(line);\n    }\n    const length = line.length + 4;\n    const hexlength = padHex(4, length);\n    return Buffer.concat([Buffer.from(hexlength, 'utf8'), line])\n  }\n\n  static streamReader(stream) {\n    const reader = new StreamReader(stream);\n    return async function read() {\n      try {\n        let length = await reader.read(4);\n        if (length == null) return true\n        length = parseInt(length.toString('utf8'), 16);\n        if (length === 0) return null\n        if (length === 1) return null // delim packets\n        const buffer = await reader.read(length - 4);\n        if (buffer == null) return true\n        return buffer\n      } catch (err) {\n        console.log('error', err);\n        return true\n      }\n    }\n  }\n}\n\n// @ts-check\n\n/**\n * @param {function} read\n */\nasync function parseCapabilitiesV2(read) {\n  /** @type {Object<string, string | true>} */\n  const capabilities2 = {};\n\n  let line;\n  while (true) {\n    line = await read();\n    if (line === true) break\n    if (line === null) continue\n    line = line.toString('utf8').replace(/\\n$/, '');\n    const i = line.indexOf('=');\n    if (i > -1) {\n      const key = line.slice(0, i);\n      const value = line.slice(i + 1);\n      capabilities2[key] = value;\n    } else {\n      capabilities2[line] = true;\n    }\n  }\n  return { protocolVersion: 2, capabilities2 }\n}\n\nasync function parseRefsAdResponse(stream, { service }) {\n  const capabilities = new Set();\n  const refs = new Map();\n  const symrefs = new Map();\n\n  // There is probably a better way to do this, but for now\n  // let's just throw the result parser inline here.\n  const read = GitPktLine.streamReader(stream);\n  let lineOne = await read();\n  // skip past any flushes\n  while (lineOne === null) lineOne = await read();\n\n  if (lineOne === true) throw new EmptyServerResponseError()\n\n  // Handle protocol v2 responses (Bitbucket Server doesn't include a `# service=` line)\n  if (lineOne.includes('version 2')) {\n    return parseCapabilitiesV2(read)\n  }\n\n  // Clients MUST ignore an LF at the end of the line.\n  if (lineOne.toString('utf8').replace(/\\n$/, '') !== `# service=${service}`) {\n    throw new ParseError(`# service=${service}\\\\n`, lineOne.toString('utf8'))\n  }\n  let lineTwo = await read();\n  // skip past any flushes\n  while (lineTwo === null) lineTwo = await read();\n  // In the edge case of a brand new repo, zero refs (and zero capabilities)\n  // are returned.\n  if (lineTwo === true) return { capabilities, refs, symrefs }\n  lineTwo = lineTwo.toString('utf8');\n\n  // Handle protocol v2 responses\n  if (lineTwo.includes('version 2')) {\n    return parseCapabilitiesV2(read)\n  }\n\n  const [firstRef, capabilitiesLine] = splitAndAssert(lineTwo, '\\x00', '\\\\x00');\n  capabilitiesLine.split(' ').map(x => capabilities.add(x));\n  const [ref, name] = splitAndAssert(firstRef, ' ', ' ');\n  refs.set(name, ref);\n  while (true) {\n    const line = await read();\n    if (line === true) break\n    if (line !== null) {\n      const [ref, name] = splitAndAssert(line.toString('utf8'), ' ', ' ');\n      refs.set(name, ref);\n    }\n  }\n  // Symrefs are thrown into the \"capabilities\" unfortunately.\n  for (const cap of capabilities) {\n    if (cap.startsWith('symref=')) {\n      const m = cap.match(/symref=([^:]+):(.*)/);\n      if (m.length === 3) {\n        symrefs.set(m[1], m[2]);\n      }\n    }\n  }\n  return { protocolVersion: 1, capabilities, refs, symrefs }\n}\n\nfunction splitAndAssert(line, sep, expected) {\n  const split = line.trim().split(sep);\n  if (split.length !== 2) {\n    throw new ParseError(\n      `Two strings separated by '${expected}'`,\n      line.toString('utf8')\n    )\n  }\n  return split\n}\n\n// Try to accomodate known CORS proxy implementations:\n// - https://jcubic.pl/proxy.php?  <-- uses query string\n// - https://cors.isomorphic-git.org  <-- uses path\nconst corsProxify = (corsProxy, url) =>\n  corsProxy.endsWith('?')\n    ? `${corsProxy}${url}`\n    : `${corsProxy}/${url.replace(/^https?:\\/\\//, '')}`;\n\nconst updateHeaders = (headers, auth) => {\n  // Update the basic auth header\n  if (auth.username || auth.password) {\n    headers.Authorization = calculateBasicAuthHeader(auth);\n  }\n  // but any manually provided headers take precedence\n  if (auth.headers) {\n    Object.assign(headers, auth.headers);\n  }\n};\n\n/**\n * @param {GitHttpResponse} res\n *\n * @returns {{ preview: string, response: string, data: Buffer }}\n */\nconst stringifyBody = async res => {\n  try {\n    // Some services provide a meaningful error message in the body of 403s like \"token lacks the scopes necessary to perform this action\"\n    const data = Buffer.from(await collect(res.body));\n    const response = data.toString('utf8');\n    const preview =\n      response.length < 256 ? response : response.slice(0, 256) + '...';\n    return { preview, response, data }\n  } catch (e) {\n    return {}\n  }\n};\n\nclass GitRemoteHTTP {\n  static async capabilities() {\n    return ['discover', 'connect']\n  }\n\n  /**\n   * @param {Object} args\n   * @param {HttpClient} args.http\n   * @param {ProgressCallback} [args.onProgress]\n   * @param {AuthCallback} [args.onAuth]\n   * @param {AuthFailureCallback} [args.onAuthFailure]\n   * @param {AuthSuccessCallback} [args.onAuthSuccess]\n   * @param {string} [args.corsProxy]\n   * @param {string} args.service\n   * @param {string} args.url\n   * @param {Object<string, string>} args.headers\n   * @param {1 | 2} args.protocolVersion - Git Protocol Version\n   */\n  static async discover({\n    http,\n    onProgress,\n    onAuth,\n    onAuthSuccess,\n    onAuthFailure,\n    corsProxy,\n    service,\n    url: _origUrl,\n    headers,\n    protocolVersion,\n  }) {\n    let { url, auth } = extractAuthFromUrl(_origUrl);\n    const proxifiedURL = corsProxy ? corsProxify(corsProxy, url) : url;\n    if (auth.username || auth.password) {\n      headers.Authorization = calculateBasicAuthHeader(auth);\n    }\n    if (protocolVersion === 2) {\n      headers['Git-Protocol'] = 'version=2';\n    }\n\n    let res;\n    let tryAgain;\n    let providedAuthBefore = false;\n    do {\n      res = await http.request({\n        onProgress,\n        method: 'GET',\n        url: `${proxifiedURL}/info/refs?service=${service}`,\n        headers,\n      });\n\n      // the default loop behavior\n      tryAgain = false;\n\n      // 401 is the \"correct\" response for access denied. 203 is Non-Authoritative Information and comes from Azure DevOps, which\n      // apparently doesn't realize this is a git request and is returning the HTML for the \"Azure DevOps Services | Sign In\" page.\n      if (res.statusCode === 401 || res.statusCode === 203) {\n        // On subsequent 401s, call `onAuthFailure` instead of `onAuth`.\n        // This is so that naive `onAuth` callbacks that return a fixed value don't create an infinite loop of retrying.\n        const getAuth = providedAuthBefore ? onAuthFailure : onAuth;\n        if (getAuth) {\n          // Acquire credentials and try again\n          // TODO: read `useHttpPath` value from git config and pass along?\n          auth = await getAuth(url, {\n            ...auth,\n            headers: { ...headers },\n          });\n          if (auth && auth.cancel) {\n            throw new UserCanceledError()\n          } else if (auth) {\n            updateHeaders(headers, auth);\n            providedAuthBefore = true;\n            tryAgain = true;\n          }\n        }\n      } else if (\n        res.statusCode === 200 &&\n        providedAuthBefore &&\n        onAuthSuccess\n      ) {\n        await onAuthSuccess(url, auth);\n      }\n    } while (tryAgain)\n\n    if (res.statusCode !== 200) {\n      const { response } = await stringifyBody(res);\n      throw new HttpError(res.statusCode, res.statusMessage, response)\n    }\n    // Git \"smart\" HTTP servers should respond with the correct Content-Type header.\n    if (\n      res.headers['content-type'] === `application/x-${service}-advertisement`\n    ) {\n      const remoteHTTP = await parseRefsAdResponse(res.body, { service });\n      remoteHTTP.auth = auth;\n      return remoteHTTP\n    } else {\n      // If they don't send the correct content-type header, that's a good indicator it is either a \"dumb\" HTTP\n      // server, or the user specified an incorrect remote URL and the response is actually an HTML page.\n      // In this case, we save the response as plain text so we can generate a better error message if needed.\n      const { preview, response, data } = await stringifyBody(res);\n      // For backwards compatibility, try to parse it anyway.\n      // TODO: maybe just throw instead of trying?\n      try {\n        const remoteHTTP = await parseRefsAdResponse([data], { service });\n        remoteHTTP.auth = auth;\n        return remoteHTTP\n      } catch (e) {\n        throw new SmartHttpError(preview, response)\n      }\n    }\n  }\n\n  /**\n   * @param {Object} args\n   * @param {HttpClient} args.http\n   * @param {ProgressCallback} [args.onProgress]\n   * @param {string} [args.corsProxy]\n   * @param {string} args.service\n   * @param {string} args.url\n   * @param {Object<string, string>} [args.headers]\n   * @param {any} args.body\n   * @param {any} args.auth\n   */\n  static async connect({\n    http,\n    onProgress,\n    corsProxy,\n    service,\n    url,\n    auth,\n    body,\n    headers,\n  }) {\n    // We already have the \"correct\" auth value at this point, but\n    // we need to strip out the username/password from the URL yet again.\n    const urlAuth = extractAuthFromUrl(url);\n    if (urlAuth) url = urlAuth.url;\n\n    if (corsProxy) url = corsProxify(corsProxy, url);\n\n    headers['content-type'] = `application/x-${service}-request`;\n    headers.accept = `application/x-${service}-result`;\n    updateHeaders(headers, auth);\n\n    const res = await http.request({\n      onProgress,\n      method: 'POST',\n      url: `${url}/${service}`,\n      body,\n      headers,\n    });\n    if (res.statusCode !== 200) {\n      const { response } = stringifyBody(res);\n      throw new HttpError(res.statusCode, res.statusMessage, response)\n    }\n    return res\n  }\n}\n\nfunction parseRemoteUrl({ url }) {\n  // the stupid \"shorter scp-like syntax\"\n  if (url.startsWith('git@')) {\n    return {\n      transport: 'ssh',\n      address: url,\n    }\n  }\n  const matches = url.match(/(\\w+)(:\\/\\/|::)(.*)/);\n  if (matches === null) return\n  /*\n   * When git encounters a URL of the form <transport>://<address>, where <transport> is\n   * a protocol that it cannot handle natively, it automatically invokes git remote-<transport>\n   * with the full URL as the second argument.\n   *\n   * @see https://git-scm.com/docs/git-remote-helpers\n   */\n  if (matches[2] === '://') {\n    return {\n      transport: matches[1],\n      address: matches[0],\n    }\n  }\n  /*\n   * A URL of the form <transport>::<address> explicitly instructs git to invoke\n   * git remote-<transport> with <address> as the second argument.\n   *\n   * @see https://git-scm.com/docs/git-remote-helpers\n   */\n  if (matches[2] === '::') {\n    return {\n      transport: matches[1],\n      address: matches[3],\n    }\n  }\n}\n\nclass GitRemoteManager {\n  static getRemoteHelperFor({ url }) {\n    // TODO: clean up the remoteHelper API and move into PluginCore\n    const remoteHelpers = new Map();\n    remoteHelpers.set('http', GitRemoteHTTP);\n    remoteHelpers.set('https', GitRemoteHTTP);\n\n    const parts = parseRemoteUrl({ url });\n    if (!parts) {\n      throw new UrlParseError(url)\n    }\n    if (remoteHelpers.has(parts.transport)) {\n      return remoteHelpers.get(parts.transport)\n    }\n    throw new UnknownTransportError(\n      url,\n      parts.transport,\n      parts.transport === 'ssh' ? translateSSHtoHTTP(url) : undefined\n    )\n  }\n}\n\nlet lock$1 = null;\n\nclass GitShallowManager {\n  static async read({ fs, gitdir }) {\n    if (lock$1 === null) lock$1 = new AsyncLock();\n    const filepath = join(gitdir, 'shallow');\n    const oids = new Set();\n    await lock$1.acquire(filepath, async function() {\n      const text = await fs.read(filepath, { encoding: 'utf8' });\n      if (text === null) return oids // no file\n      if (text.trim() === '') return oids // empty file\n      text\n        .trim()\n        .split('\\n')\n        .map(oid => oids.add(oid));\n    });\n    return oids\n  }\n\n  static async write({ fs, gitdir, oids }) {\n    if (lock$1 === null) lock$1 = new AsyncLock();\n    const filepath = join(gitdir, 'shallow');\n    if (oids.size > 0) {\n      const text = [...oids].join('\\n') + '\\n';\n      await lock$1.acquire(filepath, async function() {\n        await fs.write(filepath, text, {\n          encoding: 'utf8',\n        });\n      });\n    } else {\n      // No shallows\n      await lock$1.acquire(filepath, async function() {\n        await fs.rm(filepath);\n      });\n    }\n  }\n}\n\nasync function hasObjectLoose({ fs, gitdir, oid }) {\n  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;\n  return fs.exists(`${gitdir}/${source}`)\n}\n\nasync function hasObjectPacked({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  getExternalRefDelta,\n}) {\n  // Check to see if it's in a packfile.\n  // Iterate through all the .idx files\n  let list = await fs.readdir(join(gitdir, 'objects/pack'));\n  list = list.filter(x => x.endsWith('.idx'));\n  for (const filename of list) {\n    const indexFile = `${gitdir}/objects/pack/${filename}`;\n    const p = await readPackIndex({\n      fs,\n      cache,\n      filename: indexFile,\n      getExternalRefDelta,\n    });\n    if (p.error) throw new InternalError(p.error)\n    // If the packfile DOES have the oid we're looking for...\n    if (p.offsets.has(oid)) {\n      return true\n    }\n  }\n  // Failed to find it\n  return false\n}\n\nasync function hasObject({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  format = 'content',\n}) {\n  // Curry the current read method so that the packfile un-deltification\n  // process can acquire external ref-deltas.\n  const getExternalRefDelta = oid => _readObject({ fs, cache, gitdir, oid });\n\n  // Look for it in the loose object directory.\n  let result = await hasObjectLoose({ fs, gitdir, oid });\n  // Check to see if it's in a packfile.\n  if (!result) {\n    result = await hasObjectPacked({\n      fs,\n      cache,\n      gitdir,\n      oid,\n      getExternalRefDelta,\n    });\n  }\n  // Finally\n  return result\n}\n\n// TODO: make a function that just returns obCount. then emptyPackfile = () => sizePack(pack) === 0\nfunction emptyPackfile(pack) {\n  const pheader = '5041434b';\n  const version = '00000002';\n  const obCount = '00000000';\n  const header = pheader + version + obCount;\n  return pack.slice(0, 12).toString('hex') === header\n}\n\nfunction filterCapabilities(server, client) {\n  const serverNames = server.map(cap => cap.split('=', 1)[0]);\n  return client.filter(cap => {\n    const name = cap.split('=', 1)[0];\n    return serverNames.includes(name)\n  })\n}\n\nconst pkg = {\n  name: 'isomorphic-git',\n  version: '1.25.1',\n  agent: 'git/isomorphic-git@1.25.1',\n};\n\nclass FIFO {\n  constructor() {\n    this._queue = [];\n  }\n\n  write(chunk) {\n    if (this._ended) {\n      throw Error('You cannot write to a FIFO that has already been ended!')\n    }\n    if (this._waiting) {\n      const resolve = this._waiting;\n      this._waiting = null;\n      resolve({ value: chunk });\n    } else {\n      this._queue.push(chunk);\n    }\n  }\n\n  end() {\n    this._ended = true;\n    if (this._waiting) {\n      const resolve = this._waiting;\n      this._waiting = null;\n      resolve({ done: true });\n    }\n  }\n\n  destroy(err) {\n    this._ended = true;\n    this.error = err;\n  }\n\n  async next() {\n    if (this._queue.length > 0) {\n      return { value: this._queue.shift() }\n    }\n    if (this._ended) {\n      return { done: true }\n    }\n    if (this._waiting) {\n      throw Error(\n        'You cannot call read until the previous call to read has returned!'\n      )\n    }\n    return new Promise(resolve => {\n      this._waiting = resolve;\n    })\n  }\n}\n\n// Note: progress messages are designed to be written directly to the terminal,\n// so they are often sent with just a carriage return to overwrite the last line of output.\n// But there are also messages delimited with newlines.\n// I also include CRLF just in case.\nfunction findSplit(str) {\n  const r = str.indexOf('\\r');\n  const n = str.indexOf('\\n');\n  if (r === -1 && n === -1) return -1\n  if (r === -1) return n + 1 // \\n\n  if (n === -1) return r + 1 // \\r\n  if (n === r + 1) return n + 1 // \\r\\n\n  return Math.min(r, n) + 1 // \\r or \\n\n}\n\nfunction splitLines(input) {\n  const output = new FIFO();\n  let tmp = ''\n  ;(async () => {\n    await forAwait(input, chunk => {\n      chunk = chunk.toString('utf8');\n      tmp += chunk;\n      while (true) {\n        const i = findSplit(tmp);\n        if (i === -1) break\n        output.write(tmp.slice(0, i));\n        tmp = tmp.slice(i);\n      }\n    });\n    if (tmp.length > 0) {\n      output.write(tmp);\n    }\n    output.end();\n  })();\n  return output\n}\n\n/*\nIf 'side-band' or 'side-band-64k' capabilities have been specified by\nthe client, the server will send the packfile data multiplexed.\n\nEach packet starting with the packet-line length of the amount of data\nthat follows, followed by a single byte specifying the sideband the\nfollowing data is coming in on.\n\nIn 'side-band' mode, it will send up to 999 data bytes plus 1 control\ncode, for a total of up to 1000 bytes in a pkt-line.  In 'side-band-64k'\nmode it will send up to 65519 data bytes plus 1 control code, for a\ntotal of up to 65520 bytes in a pkt-line.\n\nThe sideband byte will be a '1', '2' or a '3'. Sideband '1' will contain\npackfile data, sideband '2' will be used for progress information that the\nclient will generally print to stderr and sideband '3' is used for error\ninformation.\n\nIf no 'side-band' capability was specified, the server will stream the\nentire packfile without multiplexing.\n*/\n\nclass GitSideBand {\n  static demux(input) {\n    const read = GitPktLine.streamReader(input);\n    // And now for the ridiculous side-band or side-band-64k protocol\n    const packetlines = new FIFO();\n    const packfile = new FIFO();\n    const progress = new FIFO();\n    // TODO: Use a proper through stream?\n    const nextBit = async function() {\n      const line = await read();\n      // Skip over flush packets\n      if (line === null) return nextBit()\n      // A made up convention to signal there's no more to read.\n      if (line === true) {\n        packetlines.end();\n        progress.end();\n        packfile.end();\n        return\n      }\n      // Examine first byte to determine which output \"stream\" to use\n      switch (line[0]) {\n        case 1: {\n          // pack data\n          packfile.write(line.slice(1));\n          break\n        }\n        case 2: {\n          // progress message\n          progress.write(line.slice(1));\n          break\n        }\n        case 3: {\n          // fatal error message just before stream aborts\n          const error = line.slice(1);\n          progress.write(error);\n          packfile.destroy(new Error(error.toString('utf8')));\n          return\n        }\n        default: {\n          // Not part of the side-band-64k protocol\n          packetlines.write(line.slice(0));\n        }\n      }\n      // Careful not to blow up the stack.\n      // I think Promises in a tail-call position should be OK.\n      nextBit();\n    };\n    nextBit();\n    return {\n      packetlines,\n      packfile,\n      progress,\n    }\n  }\n  // static mux ({\n  //   protocol, // 'side-band' or 'side-band-64k'\n  //   packetlines,\n  //   packfile,\n  //   progress,\n  //   error\n  // }) {\n  //   const MAX_PACKET_LENGTH = protocol === 'side-band-64k' ? 999 : 65519\n  //   let output = new PassThrough()\n  //   packetlines.on('data', data => {\n  //     if (data === null) {\n  //       output.write(GitPktLine.flush())\n  //     } else {\n  //       output.write(GitPktLine.encode(data))\n  //     }\n  //   })\n  //   let packfileWasEmpty = true\n  //   let packfileEnded = false\n  //   let progressEnded = false\n  //   let errorEnded = false\n  //   let goodbye = Buffer.concat([\n  //     GitPktLine.encode(Buffer.from('010A', 'hex')),\n  //     GitPktLine.flush()\n  //   ])\n  //   packfile\n  //     .on('data', data => {\n  //       packfileWasEmpty = false\n  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)\n  //       for (const buffer of buffers) {\n  //         output.write(\n  //           GitPktLine.encode(Buffer.concat([Buffer.from('01', 'hex'), buffer]))\n  //         )\n  //       }\n  //     })\n  //     .on('end', () => {\n  //       packfileEnded = true\n  //       if (!packfileWasEmpty) output.write(goodbye)\n  //       if (progressEnded && errorEnded) output.end()\n  //     })\n  //   progress\n  //     .on('data', data => {\n  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)\n  //       for (const buffer of buffers) {\n  //         output.write(\n  //           GitPktLine.encode(Buffer.concat([Buffer.from('02', 'hex'), buffer]))\n  //         )\n  //       }\n  //     })\n  //     .on('end', () => {\n  //       progressEnded = true\n  //       if (packfileEnded && errorEnded) output.end()\n  //     })\n  //   error\n  //     .on('data', data => {\n  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)\n  //       for (const buffer of buffers) {\n  //         output.write(\n  //           GitPktLine.encode(Buffer.concat([Buffer.from('03', 'hex'), buffer]))\n  //         )\n  //       }\n  //     })\n  //     .on('end', () => {\n  //       errorEnded = true\n  //       if (progressEnded && packfileEnded) output.end()\n  //     })\n  //   return output\n  // }\n}\n\nasync function parseUploadPackResponse(stream) {\n  const { packetlines, packfile, progress } = GitSideBand.demux(stream);\n  const shallows = [];\n  const unshallows = [];\n  const acks = [];\n  let nak = false;\n  let done = false;\n  return new Promise((resolve, reject) => {\n    // Parse the response\n    forAwait(packetlines, data => {\n      const line = data.toString('utf8').trim();\n      if (line.startsWith('shallow')) {\n        const oid = line.slice(-41).trim();\n        if (oid.length !== 40) {\n          reject(new InvalidOidError(oid));\n        }\n        shallows.push(oid);\n      } else if (line.startsWith('unshallow')) {\n        const oid = line.slice(-41).trim();\n        if (oid.length !== 40) {\n          reject(new InvalidOidError(oid));\n        }\n        unshallows.push(oid);\n      } else if (line.startsWith('ACK')) {\n        const [, oid, status] = line.split(' ');\n        acks.push({ oid, status });\n        if (!status) done = true;\n      } else if (line.startsWith('NAK')) {\n        nak = true;\n        done = true;\n      } else {\n        done = true;\n        nak = true;\n      }\n      if (done) {\n        resolve({ shallows, unshallows, acks, nak, packfile, progress });\n      }\n    });\n  })\n}\n\nfunction writeUploadPackRequest({\n  capabilities = [],\n  wants = [],\n  haves = [],\n  shallows = [],\n  depth = null,\n  since = null,\n  exclude = [],\n}) {\n  const packstream = [];\n  wants = [...new Set(wants)]; // remove duplicates\n  let firstLineCapabilities = ` ${capabilities.join(' ')}`;\n  for (const oid of wants) {\n    packstream.push(GitPktLine.encode(`want ${oid}${firstLineCapabilities}\\n`));\n    firstLineCapabilities = '';\n  }\n  for (const oid of shallows) {\n    packstream.push(GitPktLine.encode(`shallow ${oid}\\n`));\n  }\n  if (depth !== null) {\n    packstream.push(GitPktLine.encode(`deepen ${depth}\\n`));\n  }\n  if (since !== null) {\n    packstream.push(\n      GitPktLine.encode(`deepen-since ${Math.floor(since.valueOf() / 1000)}\\n`)\n    );\n  }\n  for (const oid of exclude) {\n    packstream.push(GitPktLine.encode(`deepen-not ${oid}\\n`));\n  }\n  packstream.push(GitPktLine.flush());\n  for (const oid of haves) {\n    packstream.push(GitPktLine.encode(`have ${oid}\\n`));\n  }\n  packstream.push(GitPktLine.encode(`done\\n`));\n  return packstream\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {object} FetchResult - The object returned has the following schema:\n * @property {string | null} defaultBranch - The branch that is cloned if no branch is specified\n * @property {string | null} fetchHead - The SHA-1 object id of the fetched head commit\n * @property {string | null} fetchHeadDescription - a textual description of the branch that was fetched\n * @property {Object<string, string>} [headers] - The HTTP response headers returned by the git server\n * @property {string[]} [pruned] - A list of branches that were pruned, if you provided the `prune` parameter\n *\n */\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {HttpClient} args.http\n * @param {ProgressCallback} [args.onProgress]\n * @param {MessageCallback} [args.onMessage]\n * @param {AuthCallback} [args.onAuth]\n * @param {AuthFailureCallback} [args.onAuthFailure]\n * @param {AuthSuccessCallback} [args.onAuthSuccess]\n * @param {string} args.gitdir\n * @param {string|void} [args.url]\n * @param {string} [args.corsProxy]\n * @param {string} [args.ref]\n * @param {string} [args.remoteRef]\n * @param {string} [args.remote]\n * @param {boolean} [args.singleBranch = false]\n * @param {boolean} [args.tags = false]\n * @param {number} [args.depth]\n * @param {Date} [args.since]\n * @param {string[]} [args.exclude = []]\n * @param {boolean} [args.relative = false]\n * @param {Object<string, string>} [args.headers]\n * @param {boolean} [args.prune]\n * @param {boolean} [args.pruneTags]\n *\n * @returns {Promise<FetchResult>}\n * @see FetchResult\n */\nasync function _fetch({\n  fs,\n  cache,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  gitdir,\n  ref: _ref,\n  remoteRef: _remoteRef,\n  remote: _remote,\n  url: _url,\n  corsProxy,\n  depth = null,\n  since = null,\n  exclude = [],\n  relative = false,\n  tags = false,\n  singleBranch = false,\n  headers = {},\n  prune = false,\n  pruneTags = false,\n}) {\n  const ref = _ref || (await _currentBranch({ fs, gitdir, test: true }));\n  const config = await GitConfigManager.get({ fs, gitdir });\n  // Figure out what remote to use.\n  const remote =\n    _remote || (ref && (await config.get(`branch.${ref}.remote`))) || 'origin';\n  // Lookup the URL for the given remote.\n  const url = _url || (await config.get(`remote.${remote}.url`));\n  if (typeof url === 'undefined') {\n    throw new MissingParameterError('remote OR url')\n  }\n  // Figure out what remote ref to use.\n  const remoteRef =\n    _remoteRef ||\n    (ref && (await config.get(`branch.${ref}.merge`))) ||\n    _ref ||\n    'HEAD';\n\n  if (corsProxy === undefined) {\n    corsProxy = await config.get('http.corsProxy');\n  }\n\n  const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({ url });\n  const remoteHTTP = await GitRemoteHTTP.discover({\n    http,\n    onAuth,\n    onAuthSuccess,\n    onAuthFailure,\n    corsProxy,\n    service: 'git-upload-pack',\n    url,\n    headers,\n    protocolVersion: 1,\n  });\n  const auth = remoteHTTP.auth; // hack to get new credentials from CredentialManager API\n  const remoteRefs = remoteHTTP.refs;\n  // For the special case of an empty repository with no refs, return null.\n  if (remoteRefs.size === 0) {\n    return {\n      defaultBranch: null,\n      fetchHead: null,\n      fetchHeadDescription: null,\n    }\n  }\n  // Check that the remote supports the requested features\n  if (depth !== null && !remoteHTTP.capabilities.has('shallow')) {\n    throw new RemoteCapabilityError('shallow', 'depth')\n  }\n  if (since !== null && !remoteHTTP.capabilities.has('deepen-since')) {\n    throw new RemoteCapabilityError('deepen-since', 'since')\n  }\n  if (exclude.length > 0 && !remoteHTTP.capabilities.has('deepen-not')) {\n    throw new RemoteCapabilityError('deepen-not', 'exclude')\n  }\n  if (relative === true && !remoteHTTP.capabilities.has('deepen-relative')) {\n    throw new RemoteCapabilityError('deepen-relative', 'relative')\n  }\n  // Figure out the SHA for the requested ref\n  const { oid, fullref } = GitRefManager.resolveAgainstMap({\n    ref: remoteRef,\n    map: remoteRefs,\n  });\n  // Filter out refs we want to ignore: only keep ref we're cloning, HEAD, branches, and tags (if we're keeping them)\n  for (const remoteRef of remoteRefs.keys()) {\n    if (\n      remoteRef === fullref ||\n      remoteRef === 'HEAD' ||\n      remoteRef.startsWith('refs/heads/') ||\n      (tags && remoteRef.startsWith('refs/tags/'))\n    ) {\n      continue\n    }\n    remoteRefs.delete(remoteRef);\n  }\n  // Assemble the application/x-git-upload-pack-request\n  const capabilities = filterCapabilities(\n    [...remoteHTTP.capabilities],\n    [\n      'multi_ack_detailed',\n      'no-done',\n      'side-band-64k',\n      // Note: I removed 'thin-pack' option since our code doesn't \"fatten\" packfiles,\n      // which is necessary for compatibility with git. It was the cause of mysterious\n      // 'fatal: pack has [x] unresolved deltas' errors that plagued us for some time.\n      // isomorphic-git is perfectly happy with thin packfiles in .git/objects/pack but\n      // canonical git it turns out is NOT.\n      'ofs-delta',\n      `agent=${pkg.agent}`,\n    ]\n  );\n  if (relative) capabilities.push('deepen-relative');\n  // Start figuring out which oids from the remote we want to request\n  const wants = singleBranch ? [oid] : remoteRefs.values();\n  // Come up with a reasonable list of oids to tell the remote we already have\n  // (preferably oids that are close ancestors of the branch heads we're fetching)\n  const haveRefs = singleBranch\n    ? [ref]\n    : await GitRefManager.listRefs({\n        fs,\n        gitdir,\n        filepath: `refs`,\n      });\n  let haves = [];\n  for (let ref of haveRefs) {\n    try {\n      ref = await GitRefManager.expand({ fs, gitdir, ref });\n      const oid = await GitRefManager.resolve({ fs, gitdir, ref });\n      if (await hasObject({ fs, cache, gitdir, oid })) {\n        haves.push(oid);\n      }\n    } catch (err) {}\n  }\n  haves = [...new Set(haves)];\n  const oids = await GitShallowManager.read({ fs, gitdir });\n  const shallows = remoteHTTP.capabilities.has('shallow') ? [...oids] : [];\n  const packstream = writeUploadPackRequest({\n    capabilities,\n    wants,\n    haves,\n    shallows,\n    depth,\n    since,\n    exclude,\n  });\n  // CodeCommit will hang up if we don't send a Content-Length header\n  // so we can't stream the body.\n  const packbuffer = Buffer.from(await collect(packstream));\n  const raw = await GitRemoteHTTP.connect({\n    http,\n    onProgress,\n    corsProxy,\n    service: 'git-upload-pack',\n    url,\n    auth,\n    body: [packbuffer],\n    headers,\n  });\n  const response = await parseUploadPackResponse(raw.body);\n  if (raw.headers) {\n    response.headers = raw.headers;\n  }\n  // Apply all the 'shallow' and 'unshallow' commands\n  for (const oid of response.shallows) {\n    if (!oids.has(oid)) {\n      // this is in a try/catch mostly because my old test fixtures are missing objects\n      try {\n        // server says it's shallow, but do we have the parents?\n        const { object } = await _readObject({ fs, cache, gitdir, oid });\n        const commit = new GitCommit(object);\n        const hasParents = await Promise.all(\n          commit\n            .headers()\n            .parent.map(oid => hasObject({ fs, cache, gitdir, oid }))\n        );\n        const haveAllParents =\n          hasParents.length === 0 || hasParents.every(has => has);\n        if (!haveAllParents) {\n          oids.add(oid);\n        }\n      } catch (err) {\n        oids.add(oid);\n      }\n    }\n  }\n  for (const oid of response.unshallows) {\n    oids.delete(oid);\n  }\n  await GitShallowManager.write({ fs, gitdir, oids });\n  // Update local remote refs\n  if (singleBranch) {\n    const refs = new Map([[fullref, oid]]);\n    // But wait, maybe it was a symref, like 'HEAD'!\n    // We need to save all the refs in the symref chain (sigh).\n    const symrefs = new Map();\n    let bail = 10;\n    let key = fullref;\n    while (bail--) {\n      const value = remoteHTTP.symrefs.get(key);\n      if (value === undefined) break\n      symrefs.set(key, value);\n      key = value;\n    }\n    // final value must not be a symref but a real ref\n    const realRef = remoteRefs.get(key);\n    // There may be no ref at all if we've fetched a specific commit hash\n    if (realRef) {\n      refs.set(key, realRef);\n    }\n    const { pruned } = await GitRefManager.updateRemoteRefs({\n      fs,\n      gitdir,\n      remote,\n      refs,\n      symrefs,\n      tags,\n      prune,\n    });\n    if (prune) {\n      response.pruned = pruned;\n    }\n  } else {\n    const { pruned } = await GitRefManager.updateRemoteRefs({\n      fs,\n      gitdir,\n      remote,\n      refs: remoteRefs,\n      symrefs: remoteHTTP.symrefs,\n      tags,\n      prune,\n      pruneTags,\n    });\n    if (prune) {\n      response.pruned = pruned;\n    }\n  }\n  // We need this value later for the `clone` command.\n  response.HEAD = remoteHTTP.symrefs.get('HEAD');\n  // AWS CodeCommit doesn't list HEAD as a symref, but we can reverse engineer it\n  // Find the SHA of the branch called HEAD\n  if (response.HEAD === undefined) {\n    const { oid } = GitRefManager.resolveAgainstMap({\n      ref: 'HEAD',\n      map: remoteRefs,\n    });\n    // Use the name of the first branch that's not called HEAD that has\n    // the same SHA as the branch called HEAD.\n    for (const [key, value] of remoteRefs.entries()) {\n      if (key !== 'HEAD' && value === oid) {\n        response.HEAD = key;\n        break\n      }\n    }\n  }\n  const noun = fullref.startsWith('refs/tags') ? 'tag' : 'branch';\n  response.FETCH_HEAD = {\n    oid,\n    description: `${noun} '${abbreviateRef(fullref)}' of ${url}`,\n  };\n\n  if (onProgress || onMessage) {\n    const lines = splitLines(response.progress);\n    forAwait(lines, async line => {\n      if (onMessage) await onMessage(line);\n      if (onProgress) {\n        const matches = line.match(/([^:]*).*\\((\\d+?)\\/(\\d+?)\\)/);\n        if (matches) {\n          await onProgress({\n            phase: matches[1].trim(),\n            loaded: parseInt(matches[2], 10),\n            total: parseInt(matches[3], 10),\n          });\n        }\n      }\n    });\n  }\n  const packfile = Buffer.from(await collect(response.packfile));\n  const packfileSha = packfile.slice(-20).toString('hex');\n  const res = {\n    defaultBranch: response.HEAD,\n    fetchHead: response.FETCH_HEAD.oid,\n    fetchHeadDescription: response.FETCH_HEAD.description,\n  };\n  if (response.headers) {\n    res.headers = response.headers;\n  }\n  if (prune) {\n    res.pruned = response.pruned;\n  }\n  // This is a quick fix for the empty .git/objects/pack/pack-.pack file error,\n  // which due to the way `git-list-pack` works causes the program to hang when it tries to read it.\n  // TODO: Longer term, we should actually:\n  // a) NOT concatenate the entire packfile into memory (line 78),\n  // b) compute the SHA of the stream except for the last 20 bytes, using the same library used in push.js, and\n  // c) compare the computed SHA with the last 20 bytes of the stream before saving to disk, and throwing a \"packfile got corrupted during download\" error if the SHA doesn't match.\n  if (packfileSha !== '' && !emptyPackfile(packfile)) {\n    res.packfile = `objects/pack/pack-${packfileSha}.pack`;\n    const fullpath = join(gitdir, res.packfile);\n    await fs.write(fullpath, packfile);\n    const getExternalRefDelta = oid => _readObject({ fs, cache, gitdir, oid });\n    const idx = await GitPackIndex.fromPack({\n      pack: packfile,\n      getExternalRefDelta,\n      onProgress,\n    });\n    await fs.write(fullpath.replace(/\\.pack$/, '.idx'), await idx.toBuffer());\n  }\n  return res\n}\n\n// @ts-check\n\n/**\n * Initialize a new repository\n *\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} [args.dir]\n * @param {string} [args.gitdir]\n * @param {boolean} [args.bare = false]\n * @param {string} [args.defaultBranch = 'master']\n * @returns {Promise<void>}\n */\nasync function _init({\n  fs,\n  bare = false,\n  dir,\n  gitdir = bare ? dir : join(dir, '.git'),\n  defaultBranch = 'master',\n}) {\n  // Don't overwrite an existing config\n  if (await fs.exists(gitdir + '/config')) return\n\n  let folders = [\n    'hooks',\n    'info',\n    'objects/info',\n    'objects/pack',\n    'refs/heads',\n    'refs/tags',\n  ];\n  folders = folders.map(dir => gitdir + '/' + dir);\n  for (const folder of folders) {\n    await fs.mkdir(folder);\n  }\n\n  await fs.write(\n    gitdir + '/config',\n    '[core]\\n' +\n      '\\trepositoryformatversion = 0\\n' +\n      '\\tfilemode = false\\n' +\n      `\\tbare = ${bare}\\n` +\n      (bare ? '' : '\\tlogallrefupdates = true\\n') +\n      '\\tsymlinks = false\\n' +\n      '\\tignorecase = true\\n'\n  );\n  await fs.write(gitdir + '/HEAD', `ref: refs/heads/${defaultBranch}\\n`);\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {HttpClient} args.http\n * @param {ProgressCallback} [args.onProgress]\n * @param {MessageCallback} [args.onMessage]\n * @param {AuthCallback} [args.onAuth]\n * @param {AuthFailureCallback} [args.onAuthFailure]\n * @param {AuthSuccessCallback} [args.onAuthSuccess]\n * @param {string} [args.dir]\n * @param {string} args.gitdir\n * @param {string} args.url\n * @param {string} args.corsProxy\n * @param {string} args.ref\n * @param {boolean} args.singleBranch\n * @param {boolean} args.noCheckout\n * @param {boolean} args.noTags\n * @param {string} args.remote\n * @param {number} args.depth\n * @param {Date} args.since\n * @param {string[]} args.exclude\n * @param {boolean} args.relative\n * @param {Object<string, string>} args.headers\n *\n * @returns {Promise<void>} Resolves successfully when clone completes\n *\n */\nasync function _clone({\n  fs,\n  cache,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  dir,\n  gitdir,\n  url,\n  corsProxy,\n  ref,\n  remote,\n  depth,\n  since,\n  exclude,\n  relative,\n  singleBranch,\n  noCheckout,\n  noTags,\n  headers,\n}) {\n  try {\n    await _init({ fs, gitdir });\n    await _addRemote({ fs, gitdir, remote, url, force: false });\n    if (corsProxy) {\n      const config = await GitConfigManager.get({ fs, gitdir });\n      await config.set(`http.corsProxy`, corsProxy);\n      await GitConfigManager.save({ fs, gitdir, config });\n    }\n    const { defaultBranch, fetchHead } = await _fetch({\n      fs,\n      cache,\n      http,\n      onProgress,\n      onMessage,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      gitdir,\n      ref,\n      remote,\n      corsProxy,\n      depth,\n      since,\n      exclude,\n      relative,\n      singleBranch,\n      headers,\n      tags: !noTags,\n    });\n    if (fetchHead === null) return\n    ref = ref || defaultBranch;\n    ref = ref.replace('refs/heads/', '');\n    // Checkout that branch\n    await _checkout({\n      fs,\n      cache,\n      onProgress,\n      dir,\n      gitdir,\n      ref,\n      remote,\n      noCheckout,\n    });\n  } catch (err) {\n    // Remove partial local repository, see #1283\n    // Ignore any error as we are already failing.\n    // The catch is necessary so the original error is not masked.\n    await fs\n      .rmdir(gitdir, { recursive: true, maxRetries: 10 })\n      .catch(() => undefined);\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Clone a repository\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {HttpClient} args.http - an HTTP client\n * @param {ProgressCallback} [args.onProgress] - optional progress event callback\n * @param {MessageCallback} [args.onMessage] - optional message event callback\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.url - The URL of the remote repository\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Value is stored in the git config file for that repo.\n * @param {string} [args.ref] - Which branch to checkout. By default this is the designated \"main branch\" of the repository.\n * @param {boolean} [args.singleBranch = false] - Instead of the default behavior of fetching all the branches, only fetch a single branch.\n * @param {boolean} [args.noCheckout = false] - If true, clone will only fetch the repo, not check out a branch. Skipping checkout can save a lot of time normally spent writing files to disk.\n * @param {boolean} [args.noTags = false] - By default clone will fetch all tags. `noTags` disables that behavior.\n * @param {string} [args.remote = 'origin'] - What to name the remote that is created.\n * @param {number} [args.depth] - Integer. Determines how much of the git repository's history to retrieve\n * @param {Date} [args.since] - Only fetch commits created after the given date. Mutually exclusive with `depth`.\n * @param {string[]} [args.exclude = []] - A list of branches or tags. Instructs the remote server not to send us any commits reachable from these refs.\n * @param {boolean} [args.relative = false] - Changes the meaning of `depth` to be measured from the current shallow depth rather than from the branch tip.\n * @param {Object<string, string>} [args.headers = {}] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully when clone completes\n *\n * @example\n * await git.clone({\n *   fs,\n *   http,\n *   dir: '/tutorial',\n *   corsProxy: 'https://cors.isomorphic-git.org',\n *   url: 'https://github.com/isomorphic-git/isomorphic-git',\n *   singleBranch: true,\n *   depth: 1\n * })\n * console.log('done')\n *\n */\nasync function clone({\n  fs,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  dir,\n  gitdir = join(dir, '.git'),\n  url,\n  corsProxy = undefined,\n  ref = undefined,\n  remote = 'origin',\n  depth = undefined,\n  since = undefined,\n  exclude = [],\n  relative = false,\n  singleBranch = false,\n  noCheckout = false,\n  noTags = false,\n  headers = {},\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('http', http);\n    assertParameter('gitdir', gitdir);\n    if (!noCheckout) {\n      assertParameter('dir', dir);\n    }\n    assertParameter('url', url);\n\n    return await _clone({\n      fs: new FileSystem(fs),\n      cache,\n      http,\n      onProgress,\n      onMessage,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      dir,\n      gitdir,\n      url,\n      corsProxy,\n      ref,\n      remote,\n      depth,\n      since,\n      exclude,\n      relative,\n      singleBranch,\n      noCheckout,\n      noTags,\n      headers,\n    })\n  } catch (err) {\n    err.caller = 'git.clone';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Create a new commit\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {SignCallback} [args.onSign] - a PGP signing implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.message - The commit message to use.\n * @param {Object} [args.author] - The details about the author.\n * @param {string} [args.author.name] - Default is `user.name` config.\n * @param {string} [args.author.email] - Default is `user.email` config.\n * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {Object} [args.committer = author] - The details about the commit committer, in the same format as the author parameter. If not specified, the author details are used.\n * @param {string} [args.committer.name] - Default is `user.name` config.\n * @param {string} [args.committer.email] - Default is `user.email` config.\n * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {string} [args.signingKey] - Sign the tag object using this private PGP key.\n * @param {boolean} [args.dryRun = false] - If true, simulates making a commit so you can test whether it would succeed. Implies `noUpdateBranch`.\n * @param {boolean} [args.noUpdateBranch = false] - If true, does not update the branch pointer after creating the commit.\n * @param {string} [args.ref] - The fully expanded name of the branch to commit to. Default is the current branch pointed to by HEAD. (TODO: fix it so it can expand branch names without throwing if the branch doesn't exist yet.)\n * @param {string[]} [args.parent] - The SHA-1 object ids of the commits to use as parents. If not specified, the commit pointed to by `ref` is used.\n * @param {string} [args.tree] - The SHA-1 object id of the tree to use. If not specified, a new tree object is created from the current git index.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly created commit.\n *\n * @example\n * let sha = await git.commit({\n *   fs,\n *   dir: '/tutorial',\n *   author: {\n *     name: 'Mr. Test',\n *     email: 'mrtest@example.com',\n *   },\n *   message: 'Added the a.txt file'\n * })\n * console.log(sha)\n *\n */\nasync function commit({\n  fs: _fs,\n  onSign,\n  dir,\n  gitdir = join(dir, '.git'),\n  message,\n  author: _author,\n  committer: _committer,\n  signingKey,\n  dryRun = false,\n  noUpdateBranch = false,\n  ref,\n  parent,\n  tree,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('message', message);\n    if (signingKey) {\n      assertParameter('onSign', onSign);\n    }\n    const fs = new FileSystem(_fs);\n\n    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });\n    if (!author) throw new MissingNameError('author')\n\n    const committer = await normalizeCommitterObject({\n      fs,\n      gitdir,\n      author,\n      committer: _committer,\n    });\n    if (!committer) throw new MissingNameError('committer')\n\n    return await _commit({\n      fs,\n      cache,\n      onSign,\n      gitdir,\n      message,\n      author,\n      committer,\n      signingKey,\n      dryRun,\n      noUpdateBranch,\n      ref,\n      parent,\n      tree,\n    })\n  } catch (err) {\n    err.caller = 'git.commit';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Get the name of the branch currently pointed to by .git/HEAD\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {boolean} [args.fullname = false] - Return the full path (e.g. \"refs/heads/main\") instead of the abbreviated form.\n * @param {boolean} [args.test = false] - If the current branch doesn't actually exist (such as right after git init) then return `undefined`.\n *\n * @returns {Promise<string|void>} The name of the current branch or undefined if the HEAD is detached.\n *\n * @example\n * // Get the current branch name\n * let branch = await git.currentBranch({\n *   fs,\n *   dir: '/tutorial',\n *   fullname: false\n * })\n * console.log(branch)\n *\n */\nasync function currentBranch({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  fullname = false,\n  test = false,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    return await _currentBranch({\n      fs: new FileSystem(fs),\n      gitdir,\n      fullname,\n      test,\n    })\n  } catch (err) {\n    err.caller = 'git.currentBranch';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.ref\n *\n * @returns {Promise<void>}\n */\nasync function _deleteBranch({ fs, gitdir, ref }) {\n  ref = ref.startsWith('refs/heads/') ? ref : `refs/heads/${ref}`;\n  const exist = await GitRefManager.exists({ fs, gitdir, ref });\n  if (!exist) {\n    throw new NotFoundError(ref)\n  }\n\n  const fullRef = await GitRefManager.expand({ fs, gitdir, ref });\n  const currentRef = await _currentBranch({ fs, gitdir, fullname: true });\n  if (fullRef === currentRef) {\n    // detach HEAD\n    const value = await GitRefManager.resolve({ fs, gitdir, ref: fullRef });\n    await GitRefManager.writeRef({ fs, gitdir, ref: 'HEAD', value });\n  }\n\n  // Delete a specified branch\n  await GitRefManager.deleteRef({ fs, gitdir, ref: fullRef });\n}\n\n// @ts-check\n\n/**\n * Delete a local branch\n *\n * > Note: This only deletes loose branches - it should be fixed in the future to delete packed branches as well.\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - The branch to delete\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.deleteBranch({ fs, dir: '/tutorial', ref: 'local-branch' })\n * console.log('done')\n *\n */\nasync function deleteBranch({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('ref', ref);\n    return await _deleteBranch({\n      fs: new FileSystem(fs),\n      gitdir,\n      ref,\n    })\n  } catch (err) {\n    err.caller = 'git.deleteBranch';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Delete a local ref\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - The ref to delete\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.deleteRef({ fs, dir: '/tutorial', ref: 'refs/tags/test-tag' })\n * console.log('done')\n *\n */\nasync function deleteRef({ fs, dir, gitdir = join(dir, '.git'), ref }) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('ref', ref);\n    await GitRefManager.deleteRef({ fs: new FileSystem(fs), gitdir, ref });\n  } catch (err) {\n    err.caller = 'git.deleteRef';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.remote\n *\n * @returns {Promise<void>}\n */\nasync function _deleteRemote({ fs, gitdir, remote }) {\n  const config = await GitConfigManager.get({ fs, gitdir });\n  await config.deleteSection('remote', remote);\n  await GitConfigManager.save({ fs, gitdir, config });\n}\n\n// @ts-check\n\n/**\n * Removes the local config entry for a given remote\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.remote - The name of the remote to delete\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.deleteRemote({ fs, dir: '/tutorial', remote: 'upstream' })\n * console.log('done')\n *\n */\nasync function deleteRemote({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  remote,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('remote', remote);\n    return await _deleteRemote({\n      fs: new FileSystem(fs),\n      gitdir,\n      remote,\n    })\n  } catch (err) {\n    err.caller = 'git.deleteRemote';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Delete a local tag ref\n *\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.ref - The tag to delete\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.deleteTag({ dir: '$input((/))', ref: '$input((test-tag))' })\n * console.log('done')\n *\n */\nasync function _deleteTag({ fs, gitdir, ref }) {\n  ref = ref.startsWith('refs/tags/') ? ref : `refs/tags/${ref}`;\n  await GitRefManager.deleteRef({ fs, gitdir, ref });\n}\n\n// @ts-check\n\n/**\n * Delete a local tag ref\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - The tag to delete\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.deleteTag({ fs, dir: '/tutorial', ref: 'test-tag' })\n * console.log('done')\n *\n */\nasync function deleteTag({ fs, dir, gitdir = join(dir, '.git'), ref }) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('ref', ref);\n    return await _deleteTag({\n      fs: new FileSystem(fs),\n      gitdir,\n      ref,\n    })\n  } catch (err) {\n    err.caller = 'git.deleteTag';\n    throw err\n  }\n}\n\nasync function expandOidLoose({ fs, gitdir, oid: short }) {\n  const prefix = short.slice(0, 2);\n  const objectsSuffixes = await fs.readdir(`${gitdir}/objects/${prefix}`);\n  return objectsSuffixes\n    .map(suffix => `${prefix}${suffix}`)\n    .filter(_oid => _oid.startsWith(short))\n}\n\nasync function expandOidPacked({\n  fs,\n  cache,\n  gitdir,\n  oid: short,\n  getExternalRefDelta,\n}) {\n  // Iterate through all the .pack files\n  const results = [];\n  let list = await fs.readdir(join(gitdir, 'objects/pack'));\n  list = list.filter(x => x.endsWith('.idx'));\n  for (const filename of list) {\n    const indexFile = `${gitdir}/objects/pack/${filename}`;\n    const p = await readPackIndex({\n      fs,\n      cache,\n      filename: indexFile,\n      getExternalRefDelta,\n    });\n    if (p.error) throw new InternalError(p.error)\n    // Search through the list of oids in the packfile\n    for (const oid of p.offsets.keys()) {\n      if (oid.startsWith(short)) results.push(oid);\n    }\n  }\n  return results\n}\n\nasync function _expandOid({ fs, cache, gitdir, oid: short }) {\n  // Curry the current read method so that the packfile un-deltification\n  // process can acquire external ref-deltas.\n  const getExternalRefDelta = oid => _readObject({ fs, cache, gitdir, oid });\n\n  const results = await expandOidLoose({ fs, gitdir, oid: short });\n  const packedOids = await expandOidPacked({\n    fs,\n    cache,\n    gitdir,\n    oid: short,\n    getExternalRefDelta,\n  });\n  // Objects can exist in a pack file as well as loose, make sure we only get a list of unique oids.\n  for (const packedOid of packedOids) {\n    if (results.indexOf(packedOid) === -1) {\n      results.push(packedOid);\n    }\n  }\n\n  if (results.length === 1) {\n    return results[0]\n  }\n  if (results.length > 1) {\n    throw new AmbiguousError('oids', short, results)\n  }\n  throw new NotFoundError(`an object matching \"${short}\"`)\n}\n\n// @ts-check\n\n/**\n * Expand and resolve a short oid into a full oid\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.oid - The shortened oid prefix to expand (like \"0414d2a\")\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<string>} Resolves successfully with the full oid (like \"0414d2a286d7bbc7a4a326a61c1f9f888a8ab87f\")\n *\n * @example\n * let oid = await git.expandOid({ fs, dir: '/tutorial', oid: '0414d2a'})\n * console.log(oid)\n *\n */\nasync function expandOid({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oid,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n    return await _expandOid({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      oid,\n    })\n  } catch (err) {\n    err.caller = 'git.expandOid';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Expand an abbreviated ref to its full name\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - The ref to expand (like \"v1.0.0\")\n *\n * @returns {Promise<string>} Resolves successfully with a full ref name (\"refs/tags/v1.0.0\")\n *\n * @example\n * let fullRef = await git.expandRef({ fs, dir: '/tutorial', ref: 'main'})\n * console.log(fullRef)\n *\n */\nasync function expandRef({ fs, dir, gitdir = join(dir, '.git'), ref }) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    return await GitRefManager.expand({\n      fs: new FileSystem(fs),\n      gitdir,\n      ref,\n    })\n  } catch (err) {\n    err.caller = 'git.expandRef';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string[]} args.oids\n *\n */\nasync function _findMergeBase({ fs, cache, gitdir, oids }) {\n  // Note: right now, the tests are geared so that the output should match that of\n  // `git merge-base --all --octopus`\n  // because without the --octopus flag, git's output seems to depend on the ORDER of the oids,\n  // and computing virtual merge bases is just too much for me to fathom right now.\n\n  // If we start N independent walkers, one at each of the given `oids`, and walk backwards\n  // through ancestors, eventually we'll discover a commit where each one of these N walkers\n  // has passed through. So we just need to keep track of which walkers have visited each commit\n  // until we find a commit that N distinct walkers has visited.\n  const visits = {};\n  const passes = oids.length;\n  let heads = oids.map((oid, index) => ({ index, oid }));\n  while (heads.length) {\n    // Count how many times we've passed each commit\n    const result = new Set();\n    for (const { oid, index } of heads) {\n      if (!visits[oid]) visits[oid] = new Set();\n      visits[oid].add(index);\n      if (visits[oid].size === passes) {\n        result.add(oid);\n      }\n    }\n    if (result.size > 0) {\n      return [...result]\n    }\n    // We haven't found a common ancestor yet\n    const newheads = new Map();\n    for (const { oid, index } of heads) {\n      try {\n        const { object } = await _readObject({ fs, cache, gitdir, oid });\n        const commit = GitCommit.from(object);\n        const { parent } = commit.parseHeaders();\n        for (const oid of parent) {\n          if (!visits[oid] || !visits[oid].has(index)) {\n            newheads.set(oid + ':' + index, { oid, index });\n          }\n        }\n      } catch (err) {\n        // do nothing\n      }\n    }\n    heads = Array.from(newheads.values());\n  }\n  return []\n}\n\nconst LINEBREAKS = /^.*(\\r?\\n|$)/gm;\n\nfunction mergeFile({ branches, contents }) {\n  const ourName = branches[1];\n  const theirName = branches[2];\n\n  const baseContent = contents[0];\n  const ourContent = contents[1];\n  const theirContent = contents[2];\n\n  const ours = ourContent.match(LINEBREAKS);\n  const base = baseContent.match(LINEBREAKS);\n  const theirs = theirContent.match(LINEBREAKS);\n\n  // Here we let the diff3 library do the heavy lifting.\n  const result = diff3Merge(ours, base, theirs);\n\n  const markerSize = 7;\n\n  // Here we note whether there are conflicts and format the results\n  let mergedText = '';\n  let cleanMerge = true;\n\n  for (const item of result) {\n    if (item.ok) {\n      mergedText += item.ok.join('');\n    }\n    if (item.conflict) {\n      cleanMerge = false;\n      mergedText += `${'<'.repeat(markerSize)} ${ourName}\\n`;\n      mergedText += item.conflict.a.join('');\n\n      mergedText += `${'='.repeat(markerSize)}\\n`;\n      mergedText += item.conflict.b.join('');\n      mergedText += `${'>'.repeat(markerSize)} ${theirName}\\n`;\n    }\n  }\n  return { cleanMerge, mergedText }\n}\n\n// @ts-check\n\n/**\n * Create a merged tree\n *\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ourOid - The SHA-1 object id of our tree\n * @param {string} args.baseOid - The SHA-1 object id of the base tree\n * @param {string} args.theirOid - The SHA-1 object id of their tree\n * @param {string} [args.ourName='ours'] - The name to use in conflicted files for our hunks\n * @param {string} [args.baseName='base'] - The name to use in conflicted files (in diff3 format) for the base hunks\n * @param {string} [args.theirName='theirs'] - The name to use in conflicted files for their hunks\n * @param {boolean} [args.dryRun=false]\n * @param {boolean} [args.abortOnConflict=false]\n * @param {MergeDriverCallback} [args.mergeDriver]\n *\n * @returns {Promise<string>} - The SHA-1 object id of the merged tree\n *\n */\nasync function mergeTree({\n  fs,\n  cache,\n  dir,\n  gitdir = join(dir, '.git'),\n  index,\n  ourOid,\n  baseOid,\n  theirOid,\n  ourName = 'ours',\n  baseName = 'base',\n  theirName = 'theirs',\n  dryRun = false,\n  abortOnConflict = true,\n  mergeDriver,\n}) {\n  const ourTree = TREE({ ref: ourOid });\n  const baseTree = TREE({ ref: baseOid });\n  const theirTree = TREE({ ref: theirOid });\n\n  const unmergedFiles = [];\n  const bothModified = [];\n  const deleteByUs = [];\n  const deleteByTheirs = [];\n\n  const results = await _walk({\n    fs,\n    cache,\n    dir,\n    gitdir,\n    trees: [ourTree, baseTree, theirTree],\n    map: async function(filepath, [ours, base, theirs]) {\n      const path = basename(filepath);\n      // What we did, what they did\n      const ourChange = await modified(ours, base);\n      const theirChange = await modified(theirs, base);\n      switch (`${ourChange}-${theirChange}`) {\n        case 'false-false': {\n          return {\n            mode: await base.mode(),\n            path,\n            oid: await base.oid(),\n            type: await base.type(),\n          }\n        }\n        case 'false-true': {\n          return theirs\n            ? {\n                mode: await theirs.mode(),\n                path,\n                oid: await theirs.oid(),\n                type: await theirs.type(),\n              }\n            : undefined\n        }\n        case 'true-false': {\n          return ours\n            ? {\n                mode: await ours.mode(),\n                path,\n                oid: await ours.oid(),\n                type: await ours.type(),\n              }\n            : undefined\n        }\n        case 'true-true': {\n          // Modifications\n          if (\n            ours &&\n            base &&\n            theirs &&\n            (await ours.type()) === 'blob' &&\n            (await base.type()) === 'blob' &&\n            (await theirs.type()) === 'blob'\n          ) {\n            return mergeBlobs({\n              fs,\n              gitdir,\n              path,\n              ours,\n              base,\n              theirs,\n              ourName,\n              baseName,\n              theirName,\n              mergeDriver,\n            }).then(async r => {\n              if (!r.cleanMerge) {\n                unmergedFiles.push(filepath);\n                bothModified.push(filepath);\n                if (!abortOnConflict) {\n                  const baseOid = await base.oid();\n                  const ourOid = await ours.oid();\n                  const theirOid = await theirs.oid();\n\n                  index.delete({ filepath });\n\n                  index.insert({ filepath, oid: baseOid, stage: 1 });\n                  index.insert({ filepath, oid: ourOid, stage: 2 });\n                  index.insert({ filepath, oid: theirOid, stage: 3 });\n                }\n              } else if (!abortOnConflict) {\n                index.insert({ filepath, oid: r.mergeResult.oid, stage: 0 });\n              }\n              return r.mergeResult\n            })\n          }\n\n          // deleted by us\n          if (\n            base &&\n            !ours &&\n            theirs &&\n            (await base.type()) === 'blob' &&\n            (await theirs.type()) === 'blob'\n          ) {\n            unmergedFiles.push(filepath);\n            deleteByUs.push(filepath);\n            if (!abortOnConflict) {\n              const baseOid = await base.oid();\n              const theirOid = await theirs.oid();\n\n              index.delete({ filepath });\n\n              index.insert({ filepath, oid: baseOid, stage: 1 });\n              index.insert({ filepath, oid: theirOid, stage: 3 });\n            }\n\n            return {\n              mode: await theirs.mode(),\n              oid: await theirs.oid(),\n              type: 'blob',\n              path,\n            }\n          }\n\n          // deleted by theirs\n          if (\n            base &&\n            ours &&\n            !theirs &&\n            (await base.type()) === 'blob' &&\n            (await ours.type()) === 'blob'\n          ) {\n            unmergedFiles.push(filepath);\n            deleteByTheirs.push(filepath);\n            if (!abortOnConflict) {\n              const baseOid = await base.oid();\n              const ourOid = await ours.oid();\n\n              index.delete({ filepath });\n\n              index.insert({ filepath, oid: baseOid, stage: 1 });\n              index.insert({ filepath, oid: ourOid, stage: 2 });\n            }\n\n            return {\n              mode: await ours.mode(),\n              oid: await ours.oid(),\n              type: 'blob',\n              path,\n            }\n          }\n\n          // deleted by both\n          if (base && !ours && !theirs && (await base.type()) === 'blob') {\n            return undefined\n          }\n\n          // all other types of conflicts fail\n          // TODO: Merge conflicts involving additions\n          throw new MergeNotSupportedError()\n        }\n      }\n    },\n    /**\n     * @param {TreeEntry} [parent]\n     * @param {Array<TreeEntry>} children\n     */\n    reduce:\n      unmergedFiles.length !== 0 && (!dir || abortOnConflict)\n        ? undefined\n        : async (parent, children) => {\n            const entries = children.filter(Boolean); // remove undefineds\n\n            // if the parent was deleted, the children have to go\n            if (!parent) return\n\n            // automatically delete directories if they have been emptied\n            if (parent && parent.type === 'tree' && entries.length === 0) return\n\n            if (entries.length > 0) {\n              const tree = new GitTree(entries);\n              const object = tree.toObject();\n              const oid = await _writeObject({\n                fs,\n                gitdir,\n                type: 'tree',\n                object,\n                dryRun,\n              });\n              parent.oid = oid;\n            }\n            return parent\n          },\n  });\n\n  if (unmergedFiles.length !== 0) {\n    if (dir && !abortOnConflict) {\n      await _walk({\n        fs,\n        cache,\n        dir,\n        gitdir,\n        trees: [TREE({ ref: results.oid })],\n        map: async function(filepath, [entry]) {\n          const path = `${dir}/${filepath}`;\n          if ((await entry.type()) === 'blob') {\n            const mode = await entry.mode();\n            const content = new TextDecoder().decode(await entry.content());\n            await fs.write(path, content, { mode });\n          }\n          return true\n        },\n      });\n    }\n    return new MergeConflictError(\n      unmergedFiles,\n      bothModified,\n      deleteByUs,\n      deleteByTheirs\n    )\n  }\n\n  return results.oid\n}\n\n/**\n *\n * @param {Object} args\n * @param {import('../models/FileSystem').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.path\n * @param {WalkerEntry} args.ours\n * @param {WalkerEntry} args.base\n * @param {WalkerEntry} args.theirs\n * @param {string} [args.ourName]\n * @param {string} [args.baseName]\n * @param {string} [args.theirName]\n * @param {boolean} [args.dryRun = false]\n * @param {MergeDriverCallback} [args.mergeDriver]\n *\n */\nasync function mergeBlobs({\n  fs,\n  gitdir,\n  path,\n  ours,\n  base,\n  theirs,\n  ourName,\n  theirName,\n  baseName,\n  dryRun,\n  mergeDriver = mergeFile,\n}) {\n  const type = 'blob';\n  // Compute the new mode.\n  // Since there are ONLY two valid blob modes ('100755' and '100644') it boils down to this\n  const mode =\n    (await base.mode()) === (await ours.mode())\n      ? await theirs.mode()\n      : await ours.mode();\n  // The trivial case: nothing to merge except maybe mode\n  if ((await ours.oid()) === (await theirs.oid())) {\n    return {\n      cleanMerge: true,\n      mergeResult: { mode, path, oid: await ours.oid(), type },\n    }\n  }\n  // if only one side made oid changes, return that side's oid\n  if ((await ours.oid()) === (await base.oid())) {\n    return {\n      cleanMerge: true,\n      mergeResult: { mode, path, oid: await theirs.oid(), type },\n    }\n  }\n  if ((await theirs.oid()) === (await base.oid())) {\n    return {\n      cleanMerge: true,\n      mergeResult: { mode, path, oid: await ours.oid(), type },\n    }\n  }\n  // if both sides made changes do a merge\n  const ourContent = Buffer.from(await ours.content()).toString('utf8');\n  const baseContent = Buffer.from(await base.content()).toString('utf8');\n  const theirContent = Buffer.from(await theirs.content()).toString('utf8');\n  const { mergedText, cleanMerge } = await mergeDriver({\n    branches: [baseName, ourName, theirName],\n    contents: [baseContent, ourContent, theirContent],\n    path,\n  });\n  const oid = await _writeObject({\n    fs,\n    gitdir,\n    type: 'blob',\n    object: Buffer.from(mergedText, 'utf8'),\n    dryRun,\n  });\n\n  return { cleanMerge, mergeResult: { mode, path, oid, type } }\n}\n\n// @ts-check\n\n// import diff3 from 'node-diff3'\n/**\n *\n * @typedef {Object} MergeResult - Returns an object with a schema like this:\n * @property {string} [oid] - The SHA-1 object id that is now at the head of the branch. Absent only if `dryRun` was specified and `mergeCommit` is true.\n * @property {boolean} [alreadyMerged] - True if the branch was already merged so no changes were made\n * @property {boolean} [fastForward] - True if it was a fast-forward merge\n * @property {boolean} [mergeCommit] - True if merge resulted in a merge commit\n * @property {string} [tree] - The SHA-1 object id of the tree resulting from a merge commit\n *\n */\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {string} args.gitdir\n * @param {string} [args.ours]\n * @param {string} args.theirs\n * @param {boolean} args.fastForward\n * @param {boolean} args.fastForwardOnly\n * @param {boolean} args.dryRun\n * @param {boolean} args.noUpdateBranch\n * @param {boolean} args.abortOnConflict\n * @param {string} [args.message]\n * @param {Object} args.author\n * @param {string} args.author.name\n * @param {string} args.author.email\n * @param {number} args.author.timestamp\n * @param {number} args.author.timezoneOffset\n * @param {Object} args.committer\n * @param {string} args.committer.name\n * @param {string} args.committer.email\n * @param {number} args.committer.timestamp\n * @param {number} args.committer.timezoneOffset\n * @param {string} [args.signingKey]\n * @param {SignCallback} [args.onSign] - a PGP signing implementation\n * @param {MergeDriverCallback} [args.mergeDriver]\n *\n * @returns {Promise<MergeResult>} Resolves to a description of the merge operation\n *\n */\nasync function _merge({\n  fs,\n  cache,\n  dir,\n  gitdir,\n  ours,\n  theirs,\n  fastForward = true,\n  fastForwardOnly = false,\n  dryRun = false,\n  noUpdateBranch = false,\n  abortOnConflict = true,\n  message,\n  author,\n  committer,\n  signingKey,\n  onSign,\n  mergeDriver,\n}) {\n  if (ours === undefined) {\n    ours = await _currentBranch({ fs, gitdir, fullname: true });\n  }\n  ours = await GitRefManager.expand({\n    fs,\n    gitdir,\n    ref: ours,\n  });\n  theirs = await GitRefManager.expand({\n    fs,\n    gitdir,\n    ref: theirs,\n  });\n  const ourOid = await GitRefManager.resolve({\n    fs,\n    gitdir,\n    ref: ours,\n  });\n  const theirOid = await GitRefManager.resolve({\n    fs,\n    gitdir,\n    ref: theirs,\n  });\n  // find most recent common ancestor of ref a and ref b\n  const baseOids = await _findMergeBase({\n    fs,\n    cache,\n    gitdir,\n    oids: [ourOid, theirOid],\n  });\n  if (baseOids.length !== 1) {\n    // TODO: Recursive Merge strategy\n    throw new MergeNotSupportedError()\n  }\n  const baseOid = baseOids[0];\n  // handle fast-forward case\n  if (baseOid === theirOid) {\n    return {\n      oid: ourOid,\n      alreadyMerged: true,\n    }\n  }\n  if (fastForward && baseOid === ourOid) {\n    if (!dryRun && !noUpdateBranch) {\n      await GitRefManager.writeRef({ fs, gitdir, ref: ours, value: theirOid });\n    }\n    return {\n      oid: theirOid,\n      fastForward: true,\n    }\n  } else {\n    // not a simple fast-forward\n    if (fastForwardOnly) {\n      throw new FastForwardError()\n    }\n    // try a fancier merge\n    const tree = await GitIndexManager.acquire(\n      { fs, gitdir, cache, allowUnmerged: false },\n      async index => {\n        return mergeTree({\n          fs,\n          cache,\n          dir,\n          gitdir,\n          index,\n          ourOid,\n          theirOid,\n          baseOid,\n          ourName: abbreviateRef(ours),\n          baseName: 'base',\n          theirName: abbreviateRef(theirs),\n          dryRun,\n          abortOnConflict,\n          mergeDriver,\n        })\n      }\n    );\n\n    // Defer throwing error until the index lock is relinquished and index is\n    // written to filsesystem\n    if (tree instanceof MergeConflictError) throw tree\n\n    if (!message) {\n      message = `Merge branch '${abbreviateRef(theirs)}' into ${abbreviateRef(\n        ours\n      )}`;\n    }\n    const oid = await _commit({\n      fs,\n      cache,\n      gitdir,\n      message,\n      ref: ours,\n      tree,\n      parent: [ourOid, theirOid],\n      author,\n      committer,\n      signingKey,\n      onSign,\n      dryRun,\n      noUpdateBranch,\n    });\n    return {\n      oid,\n      tree,\n      mergeCommit: true,\n    }\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {HttpClient} args.http\n * @param {ProgressCallback} [args.onProgress]\n * @param {MessageCallback} [args.onMessage]\n * @param {AuthCallback} [args.onAuth]\n * @param {AuthFailureCallback} [args.onAuthFailure]\n * @param {AuthSuccessCallback} [args.onAuthSuccess]\n * @param {string} args.dir\n * @param {string} args.gitdir\n * @param {string} args.ref\n * @param {string} [args.url]\n * @param {string} [args.remote]\n * @param {string} [args.remoteRef]\n * @param {boolean} [args.prune]\n * @param {boolean} [args.pruneTags]\n * @param {string} [args.corsProxy]\n * @param {boolean} args.singleBranch\n * @param {boolean} args.fastForward\n * @param {boolean} args.fastForwardOnly\n * @param {Object<string, string>} [args.headers]\n * @param {Object} args.author\n * @param {string} args.author.name\n * @param {string} args.author.email\n * @param {number} args.author.timestamp\n * @param {number} args.author.timezoneOffset\n * @param {Object} args.committer\n * @param {string} args.committer.name\n * @param {string} args.committer.email\n * @param {number} args.committer.timestamp\n * @param {number} args.committer.timezoneOffset\n * @param {string} [args.signingKey]\n *\n * @returns {Promise<void>} Resolves successfully when pull operation completes\n *\n */\nasync function _pull({\n  fs,\n  cache,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  dir,\n  gitdir,\n  ref,\n  url,\n  remote,\n  remoteRef,\n  prune,\n  pruneTags,\n  fastForward,\n  fastForwardOnly,\n  corsProxy,\n  singleBranch,\n  headers,\n  author,\n  committer,\n  signingKey,\n}) {\n  try {\n    // If ref is undefined, use 'HEAD'\n    if (!ref) {\n      const head = await _currentBranch({ fs, gitdir });\n      // TODO: use a better error.\n      if (!head) {\n        throw new MissingParameterError('ref')\n      }\n      ref = head;\n    }\n\n    const { fetchHead, fetchHeadDescription } = await _fetch({\n      fs,\n      cache,\n      http,\n      onProgress,\n      onMessage,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      gitdir,\n      corsProxy,\n      ref,\n      url,\n      remote,\n      remoteRef,\n      singleBranch,\n      headers,\n      prune,\n      pruneTags,\n    });\n    // Merge the remote tracking branch into the local one.\n    await _merge({\n      fs,\n      cache,\n      gitdir,\n      ours: ref,\n      theirs: fetchHead,\n      fastForward,\n      fastForwardOnly,\n      message: `Merge ${fetchHeadDescription}`,\n      author,\n      committer,\n      signingKey,\n      dryRun: false,\n      noUpdateBranch: false,\n    });\n    await _checkout({\n      fs,\n      cache,\n      onProgress,\n      dir,\n      gitdir,\n      ref,\n      remote,\n      noCheckout: false,\n    });\n  } catch (err) {\n    err.caller = 'git.pull';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Like `pull`, but hard-coded with `fastForward: true` so there is no need for an `author` parameter.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {HttpClient} args.http - an HTTP client\n * @param {ProgressCallback} [args.onProgress] - optional progress event callback\n * @param {MessageCallback} [args.onMessage] - optional message event callback\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - Which branch to merge into. By default this is the currently checked out branch.\n * @param {string} [args.url] - (Added in 1.1.0) The URL of the remote repository. The default is the value set in the git config for that remote.\n * @param {string} [args.remote] - (Added in 1.1.0) If URL is not specified, determines which remote to use.\n * @param {string} [args.remoteRef] - (Added in 1.1.0) The name of the branch on the remote to fetch. By default this is the configured remote tracking branch.\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.\n * @param {boolean} [args.singleBranch = false] - Instead of the default behavior of fetching all the branches, only fetch a single branch.\n * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully when pull operation completes\n *\n * @example\n * await git.fastForward({\n *   fs,\n *   http,\n *   dir: '/tutorial',\n *   ref: 'main',\n *   singleBranch: true\n * })\n * console.log('done')\n *\n */\nasync function fastForward({\n  fs,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  url,\n  remote,\n  remoteRef,\n  corsProxy,\n  singleBranch,\n  headers = {},\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('http', http);\n    assertParameter('gitdir', gitdir);\n\n    const thisWillNotBeUsed = {\n      name: '',\n      email: '',\n      timestamp: Date.now(),\n      timezoneOffset: 0,\n    };\n\n    return await _pull({\n      fs: new FileSystem(fs),\n      cache,\n      http,\n      onProgress,\n      onMessage,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      dir,\n      gitdir,\n      ref,\n      url,\n      remote,\n      remoteRef,\n      fastForwardOnly: true,\n      corsProxy,\n      singleBranch,\n      headers,\n      author: thisWillNotBeUsed,\n      committer: thisWillNotBeUsed,\n    })\n  } catch (err) {\n    err.caller = 'git.fastForward';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {object} FetchResult - The object returned has the following schema:\n * @property {string | null} defaultBranch - The branch that is cloned if no branch is specified\n * @property {string | null} fetchHead - The SHA-1 object id of the fetched head commit\n * @property {string | null} fetchHeadDescription - a textual description of the branch that was fetched\n * @property {Object<string, string>} [headers] - The HTTP response headers returned by the git server\n * @property {string[]} [pruned] - A list of branches that were pruned, if you provided the `prune` parameter\n *\n */\n\n/**\n * Fetch commits from a remote repository\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {HttpClient} args.http - an HTTP client\n * @param {ProgressCallback} [args.onProgress] - optional progress event callback\n * @param {MessageCallback} [args.onMessage] - optional message event callback\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.url] - The URL of the remote repository. The default is the value set in the git config for that remote.\n * @param {string} [args.remote] - If URL is not specified, determines which remote to use.\n * @param {boolean} [args.singleBranch = false] - Instead of the default behavior of fetching all the branches, only fetch a single branch.\n * @param {string} [args.ref] - Which branch to fetch if `singleBranch` is true. By default this is the current branch or the remote's default branch.\n * @param {string} [args.remoteRef] - The name of the branch on the remote to fetch if `singleBranch` is true. By default this is the configured remote tracking branch.\n * @param {boolean} [args.tags = false] - Also fetch tags\n * @param {number} [args.depth] - Integer. Determines how much of the git repository's history to retrieve\n * @param {boolean} [args.relative = false] - Changes the meaning of `depth` to be measured from the current shallow depth rather than from the branch tip.\n * @param {Date} [args.since] - Only fetch commits created after the given date. Mutually exclusive with `depth`.\n * @param {string[]} [args.exclude = []] - A list of branches or tags. Instructs the remote server not to send us any commits reachable from these refs.\n * @param {boolean} [args.prune = false] - Delete local remote-tracking branches that are not present on the remote\n * @param {boolean} [args.pruneTags = false] - Prune local tags that dont exist on the remote, and force-update those tags that differ\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.\n * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<FetchResult>} Resolves successfully when fetch completes\n * @see FetchResult\n *\n * @example\n * let result = await git.fetch({\n *   fs,\n *   http,\n *   dir: '/tutorial',\n *   corsProxy: 'https://cors.isomorphic-git.org',\n *   url: 'https://github.com/isomorphic-git/isomorphic-git',\n *   ref: 'main',\n *   depth: 1,\n *   singleBranch: true,\n *   tags: false\n * })\n * console.log(result)\n *\n */\nasync function fetch({\n  fs,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  remote,\n  remoteRef,\n  url,\n  corsProxy,\n  depth = null,\n  since = null,\n  exclude = [],\n  relative = false,\n  tags = false,\n  singleBranch = false,\n  headers = {},\n  prune = false,\n  pruneTags = false,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('http', http);\n    assertParameter('gitdir', gitdir);\n\n    return await _fetch({\n      fs: new FileSystem(fs),\n      cache,\n      http,\n      onProgress,\n      onMessage,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      gitdir,\n      ref,\n      remote,\n      remoteRef,\n      url,\n      corsProxy,\n      depth,\n      since,\n      exclude,\n      relative,\n      tags,\n      singleBranch,\n      headers,\n      prune,\n      pruneTags,\n    })\n  } catch (err) {\n    err.caller = 'git.fetch';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Find the merge base for a set of commits\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string[]} args.oids - Which commits\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n */\nasync function findMergeBase({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oids,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oids', oids);\n\n    return await _findMergeBase({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      oids,\n    })\n  } catch (err) {\n    err.caller = 'git.findMergeBase';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Find the root git directory\n *\n * Starting at `filepath`, walks upward until it finds a directory that contains a subdirectory called '.git'.\n *\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.filepath\n *\n * @returns {Promise<string>} Resolves successfully with a root git directory path\n */\nasync function _findRoot({ fs, filepath }) {\n  if (await fs.exists(join(filepath, '.git'))) {\n    return filepath\n  } else {\n    const parent = dirname(filepath);\n    if (parent === filepath) {\n      throw new NotFoundError(`git root for ${filepath}`)\n    }\n    return _findRoot({ fs, filepath: parent })\n  }\n}\n\n// @ts-check\n\n/**\n * Find the root git directory\n *\n * Starting at `filepath`, walks upward until it finds a directory that contains a subdirectory called '.git'.\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} args.filepath - The file directory to start searching in.\n *\n * @returns {Promise<string>} Resolves successfully with a root git directory path\n * @throws {NotFoundError}\n *\n * @example\n * let gitroot = await git.findRoot({\n *   fs,\n *   filepath: '/tutorial/src/utils'\n * })\n * console.log(gitroot)\n *\n */\nasync function findRoot({ fs, filepath }) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('filepath', filepath);\n\n    return await _findRoot({ fs: new FileSystem(fs), filepath })\n  } catch (err) {\n    err.caller = 'git.findRoot';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Read an entry from the git config files.\n *\n * *Caveats:*\n * - Currently only the local `$GIT_DIR/config` file can be read or written. However support for the global `~/.gitconfig` and system `$(prefix)/etc/gitconfig` will be added in the future.\n * - The current parser does not support the more exotic features of the git-config file format such as `[include]` and `[includeIf]`.\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.path - The key of the git config entry\n *\n * @returns {Promise<any>} Resolves with the config value\n *\n * @example\n * // Read config value\n * let value = await git.getConfig({\n *   fs,\n *   dir: '/tutorial',\n *   path: 'remote.origin.url'\n * })\n * console.log(value)\n *\n */\nasync function getConfig({ fs, dir, gitdir = join(dir, '.git'), path }) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('path', path);\n\n    return await _getConfig({\n      fs: new FileSystem(fs),\n      gitdir,\n      path,\n    })\n  } catch (err) {\n    err.caller = 'git.getConfig';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {Object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.path\n *\n * @returns {Promise<Array<any>>} Resolves with an array of the config value\n *\n */\nasync function _getConfigAll({ fs, gitdir, path }) {\n  const config = await GitConfigManager.get({ fs, gitdir });\n  return config.getall(path)\n}\n\n// @ts-check\n\n/**\n * Read a multi-valued entry from the git config files.\n *\n * *Caveats:*\n * - Currently only the local `$GIT_DIR/config` file can be read or written. However support for the global `~/.gitconfig` and system `$(prefix)/etc/gitconfig` will be added in the future.\n * - The current parser does not support the more exotic features of the git-config file format such as `[include]` and `[includeIf]`.\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.path - The key of the git config entry\n *\n * @returns {Promise<Array<any>>} Resolves with the config value\n *\n */\nasync function getConfigAll({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  path,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('path', path);\n\n    return await _getConfigAll({\n      fs: new FileSystem(fs),\n      gitdir,\n      path,\n    })\n  } catch (err) {\n    err.caller = 'git.getConfigAll';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} GetRemoteInfoResult - The object returned has the following schema:\n * @property {string[]} capabilities - The list of capabilities returned by the server (part of the Git protocol)\n * @property {Object} [refs]\n * @property {string} [HEAD] - The default branch of the remote\n * @property {Object<string, string>} [refs.heads] - The branches on the remote\n * @property {Object<string, string>} [refs.pull] - The special branches representing pull requests (non-standard)\n * @property {Object<string, string>} [refs.tags] - The tags on the remote\n *\n */\n\n/**\n * List a remote servers branches, tags, and capabilities.\n *\n * This is a rare command that doesn't require an `fs`, `dir`, or even `gitdir` argument.\n * It just communicates to a remote git server, using the first step of the `git-upload-pack` handshake, but stopping short of fetching the packfile.\n *\n * @param {object} args\n * @param {HttpClient} args.http - an HTTP client\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} args.url - The URL of the remote repository. Will be gotten from gitconfig if absent.\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.\n * @param {boolean} [args.forPush = false] - By default, the command queries the 'fetch' capabilities. If true, it will ask for the 'push' capabilities.\n * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n *\n * @returns {Promise<GetRemoteInfoResult>} Resolves successfully with an object listing the branches, tags, and capabilities of the remote.\n * @see GetRemoteInfoResult\n *\n * @example\n * let info = await git.getRemoteInfo({\n *   http,\n *   url:\n *     \"https://cors.isomorphic-git.org/github.com/isomorphic-git/isomorphic-git.git\"\n * });\n * console.log(info);\n *\n */\nasync function getRemoteInfo({\n  http,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  corsProxy,\n  url,\n  headers = {},\n  forPush = false,\n}) {\n  try {\n    assertParameter('http', http);\n    assertParameter('url', url);\n\n    const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({ url });\n    const remote = await GitRemoteHTTP.discover({\n      http,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      corsProxy,\n      service: forPush ? 'git-receive-pack' : 'git-upload-pack',\n      url,\n      headers,\n      protocolVersion: 1,\n    });\n\n    // Note: remote.capabilities, remote.refs, and remote.symrefs are Set and Map objects,\n    // but one of the objectives of the public API is to always return JSON-compatible objects\n    // so we must JSONify them.\n    const result = {\n      capabilities: [...remote.capabilities],\n    };\n    // Convert the flat list into an object tree, because I figure 99% of the time\n    // that will be easier to use.\n    for (const [ref, oid] of remote.refs) {\n      const parts = ref.split('/');\n      const last = parts.pop();\n      let o = result;\n      for (const part of parts) {\n        o[part] = o[part] || {};\n        o = o[part];\n      }\n      o[last] = oid;\n    }\n    // Merge symrefs on top of refs to more closely match actual git repo layouts\n    for (const [symref, ref] of remote.symrefs) {\n      const parts = symref.split('/');\n      const last = parts.pop();\n      let o = result;\n      for (const part of parts) {\n        o[part] = o[part] || {};\n        o = o[part];\n      }\n      o[last] = ref;\n    }\n    return result\n  } catch (err) {\n    err.caller = 'git.getRemoteInfo';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {any} remote\n * @param {string} prefix\n * @param {boolean} symrefs\n * @param {boolean} peelTags\n * @returns {ServerRef[]}\n */\nfunction formatInfoRefs(remote, prefix, symrefs, peelTags) {\n  const refs = [];\n  for (const [key, value] of remote.refs) {\n    if (prefix && !key.startsWith(prefix)) continue\n\n    if (key.endsWith('^{}')) {\n      if (peelTags) {\n        const _key = key.replace('^{}', '');\n        // Peeled tags are almost always listed immediately after the original tag\n        const last = refs[refs.length - 1];\n        const r = last.ref === _key ? last : refs.find(x => x.ref === _key);\n        if (r === undefined) {\n          throw new Error('I did not expect this to happen')\n        }\n        r.peeled = value;\n      }\n      continue\n    }\n    /** @type ServerRef */\n    const ref = { ref: key, oid: value };\n    if (symrefs) {\n      if (remote.symrefs.has(key)) {\n        ref.target = remote.symrefs.get(key);\n      }\n    }\n    refs.push(ref);\n  }\n  return refs\n}\n\n// @ts-check\n\n/**\n * @typedef {Object} GetRemoteInfo2Result - This object has the following schema:\n * @property {1 | 2} protocolVersion - Git protocol version the server supports\n * @property {Object<string, string | true>} capabilities - An object of capabilities represented as keys and values\n * @property {ServerRef[]} [refs] - Server refs (they get returned by protocol version 1 whether you want them or not)\n */\n\n/**\n * List a remote server's capabilities.\n *\n * This is a rare command that doesn't require an `fs`, `dir`, or even `gitdir` argument.\n * It just communicates to a remote git server, determining what protocol version, commands, and features it supports.\n *\n * > The successor to [`getRemoteInfo`](./getRemoteInfo.md), this command supports Git Wire Protocol Version 2.\n * > Therefore its return type is more complicated as either:\n * >\n * > - v1 capabilities (and refs) or\n * > - v2 capabilities (and no refs)\n * >\n * > are returned.\n * > If you just care about refs, use [`listServerRefs`](./listServerRefs.md)\n *\n * @param {object} args\n * @param {HttpClient} args.http - an HTTP client\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} args.url - The URL of the remote repository. Will be gotten from gitconfig if absent.\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.\n * @param {boolean} [args.forPush = false] - By default, the command queries the 'fetch' capabilities. If true, it will ask for the 'push' capabilities.\n * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n * @param {1 | 2} [args.protocolVersion = 2] - Which version of the Git Protocol to use.\n *\n * @returns {Promise<GetRemoteInfo2Result>} Resolves successfully with an object listing the capabilities of the remote.\n * @see GetRemoteInfo2Result\n * @see ServerRef\n *\n * @example\n * let info = await git.getRemoteInfo2({\n *   http,\n *   corsProxy: \"https://cors.isomorphic-git.org\",\n *   url: \"https://github.com/isomorphic-git/isomorphic-git.git\"\n * });\n * console.log(info);\n *\n */\nasync function getRemoteInfo2({\n  http,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  corsProxy,\n  url,\n  headers = {},\n  forPush = false,\n  protocolVersion = 2,\n}) {\n  try {\n    assertParameter('http', http);\n    assertParameter('url', url);\n\n    const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({ url });\n    const remote = await GitRemoteHTTP.discover({\n      http,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      corsProxy,\n      service: forPush ? 'git-receive-pack' : 'git-upload-pack',\n      url,\n      headers,\n      protocolVersion,\n    });\n\n    if (remote.protocolVersion === 2) {\n      /** @type GetRemoteInfo2Result */\n      return {\n        protocolVersion: remote.protocolVersion,\n        capabilities: remote.capabilities2,\n      }\n    }\n\n    // Note: remote.capabilities, remote.refs, and remote.symrefs are Set and Map objects,\n    // but one of the objectives of the public API is to always return JSON-compatible objects\n    // so we must JSONify them.\n    /** @type Object<string, true> */\n    const capabilities = {};\n    for (const cap of remote.capabilities) {\n      const [key, value] = cap.split('=');\n      if (value) {\n        capabilities[key] = value;\n      } else {\n        capabilities[key] = true;\n      }\n    }\n    /** @type GetRemoteInfo2Result */\n    return {\n      protocolVersion: 1,\n      capabilities,\n      refs: formatInfoRefs(remote, undefined, true, true),\n    }\n  } catch (err) {\n    err.caller = 'git.getRemoteInfo2';\n    throw err\n  }\n}\n\nasync function hashObject({\n  type,\n  object,\n  format = 'content',\n  oid = undefined,\n}) {\n  if (format !== 'deflated') {\n    if (format !== 'wrapped') {\n      object = GitObject.wrap({ type, object });\n    }\n    oid = await shasum(object);\n  }\n  return { oid, object }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {object} HashBlobResult - The object returned has the following schema:\n * @property {string} oid - The SHA-1 object id\n * @property {'blob'} type - The type of the object\n * @property {Uint8Array} object - The wrapped git object (the thing that is hashed)\n * @property {'wrapped'} format - The format of the object\n *\n */\n\n/**\n * Compute what the SHA-1 object id of a file would be\n *\n * @param {object} args\n * @param {Uint8Array|string} args.object - The object to write. If `object` is a String then it will be converted to a Uint8Array using UTF-8 encoding.\n *\n * @returns {Promise<HashBlobResult>} Resolves successfully with the SHA-1 object id and the wrapped object Uint8Array.\n * @see HashBlobResult\n *\n * @example\n * let { oid, type, object, format } = await git.hashBlob({\n *   object: 'Hello world!',\n * })\n *\n * console.log('oid', oid)\n * console.log('type', type)\n * console.log('object', object)\n * console.log('format', format)\n *\n */\nasync function hashBlob({ object }) {\n  try {\n    assertParameter('object', object);\n\n    // Convert object to buffer\n    if (typeof object === 'string') {\n      object = Buffer.from(object, 'utf8');\n    } else {\n      object = Buffer.from(object);\n    }\n\n    const type = 'blob';\n    const { oid, object: _object } = await hashObject({\n      type: 'blob',\n      format: 'content',\n      object,\n    });\n    return { oid, type, object: new Uint8Array(_object), format: 'wrapped' }\n  } catch (err) {\n    err.caller = 'git.hashBlob';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {ProgressCallback} [args.onProgress]\n * @param {string} args.dir\n * @param {string} args.gitdir\n * @param {string} args.filepath\n *\n * @returns {Promise<{oids: string[]}>}\n */\nasync function _indexPack({\n  fs,\n  cache,\n  onProgress,\n  dir,\n  gitdir,\n  filepath,\n}) {\n  try {\n    filepath = join(dir, filepath);\n    const pack = await fs.read(filepath);\n    const getExternalRefDelta = oid => _readObject({ fs, cache, gitdir, oid });\n    const idx = await GitPackIndex.fromPack({\n      pack,\n      getExternalRefDelta,\n      onProgress,\n    });\n    await fs.write(filepath.replace(/\\.pack$/, '.idx'), await idx.toBuffer());\n    return {\n      oids: [...idx.hashes],\n    }\n  } catch (err) {\n    err.caller = 'git.indexPack';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Create the .idx file for a given .pack file\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {ProgressCallback} [args.onProgress] - optional progress event callback\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.filepath - The path to the .pack file to index\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<{oids: string[]}>} Resolves with a list of the SHA-1 object ids contained in the packfile\n *\n * @example\n * let packfiles = await fs.promises.readdir('/tutorial/.git/objects/pack')\n * packfiles = packfiles.filter(name => name.endsWith('.pack'))\n * console.log('packfiles', packfiles)\n *\n * const { oids } = await git.indexPack({\n *   fs,\n *   dir: '/tutorial',\n *   filepath: `.git/objects/pack/${packfiles[0]}`,\n *   async onProgress (evt) {\n *     console.log(`${evt.phase}: ${evt.loaded} / ${evt.total}`)\n *   }\n * })\n * console.log(oids)\n *\n */\nasync function indexPack({\n  fs,\n  onProgress,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('dir', dir);\n    assertParameter('gitdir', dir);\n    assertParameter('filepath', filepath);\n\n    return await _indexPack({\n      fs: new FileSystem(fs),\n      cache,\n      onProgress,\n      dir,\n      gitdir,\n      filepath,\n    })\n  } catch (err) {\n    err.caller = 'git.indexPack';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Initialize a new repository\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {boolean} [args.bare = false] - Initialize a bare repository\n * @param {string} [args.defaultBranch = 'master'] - The name of the default branch (might be changed to a required argument in 2.0.0)\n * @returns {Promise<void>}  Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.init({ fs, dir: '/tutorial' })\n * console.log('done')\n *\n */\nasync function init({\n  fs,\n  bare = false,\n  dir,\n  gitdir = bare ? dir : join(dir, '.git'),\n  defaultBranch = 'master',\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    if (!bare) {\n      assertParameter('dir', dir);\n    }\n\n    return await _init({\n      fs: new FileSystem(fs),\n      bare,\n      dir,\n      gitdir,\n      defaultBranch,\n    })\n  } catch (err) {\n    err.caller = 'git.init';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} args.oid\n * @param {string} args.ancestor\n * @param {number} args.depth - Maximum depth to search before giving up. -1 means no maximum depth.\n *\n * @returns {Promise<boolean>}\n */\nasync function _isDescendent({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  ancestor,\n  depth,\n}) {\n  const shallows = await GitShallowManager.read({ fs, gitdir });\n  if (!oid) {\n    throw new MissingParameterError('oid')\n  }\n  if (!ancestor) {\n    throw new MissingParameterError('ancestor')\n  }\n  // If you don't like this behavior, add your own check.\n  // Edge cases are hard to define a perfect solution.\n  if (oid === ancestor) return false\n  // We do not use recursion here, because that would lead to depth-first traversal,\n  // and we want to maintain a breadth-first traversal to avoid hitting shallow clone depth cutoffs.\n  const queue = [oid];\n  const visited = new Set();\n  let searchdepth = 0;\n  while (queue.length) {\n    if (searchdepth++ === depth) {\n      throw new MaxDepthError(depth)\n    }\n    const oid = queue.shift();\n    const { type, object } = await _readObject({\n      fs,\n      cache,\n      gitdir,\n      oid,\n    });\n    if (type !== 'commit') {\n      throw new ObjectTypeError(oid, type, 'commit')\n    }\n    const commit = GitCommit.from(object).parse();\n    // Are any of the parents the sought-after ancestor?\n    for (const parent of commit.parent) {\n      if (parent === ancestor) return true\n    }\n    // If not, add them to heads (unless we know this is a shallow commit)\n    if (!shallows.has(oid)) {\n      for (const parent of commit.parent) {\n        if (!visited.has(parent)) {\n          queue.push(parent);\n          visited.add(parent);\n        }\n      }\n    }\n    // Eventually, we'll travel entire tree to the roots where all the parents are empty arrays,\n    // or hit the shallow depth and throw an error. Excluding the possibility of grafts, or\n    // different branches cloned to different depths, you would hit this error at the same time\n    // for all parents, so trying to continue is futile.\n  }\n  return false\n}\n\n// @ts-check\n\n/**\n * Check whether a git commit is descended from another\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.oid - The descendent commit\n * @param {string} args.ancestor - The (proposed) ancestor commit\n * @param {number} [args.depth = -1] - Maximum depth to search before giving up. -1 means no maximum depth.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<boolean>} Resolves to true if `oid` is a descendent of `ancestor`\n *\n * @example\n * let oid = await git.resolveRef({ fs, dir: '/tutorial', ref: 'main' })\n * let ancestor = await git.resolveRef({ fs, dir: '/tutorial', ref: 'v0.20.0' })\n * console.log(oid, ancestor)\n * await git.isDescendent({ fs, dir: '/tutorial', oid, ancestor, depth: -1 })\n *\n */\nasync function isDescendent({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oid,\n  ancestor,\n  depth = -1,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n    assertParameter('ancestor', ancestor);\n\n    return await _isDescendent({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      oid,\n      ancestor,\n      depth,\n    })\n  } catch (err) {\n    err.caller = 'git.isDescendent';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Test whether a filepath should be ignored (because of .gitignore or .git/exclude)\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.filepath - The filepath to test\n *\n * @returns {Promise<boolean>} Resolves to true if the file should be ignored\n *\n * @example\n * await git.isIgnored({ fs, dir: '/tutorial', filepath: 'docs/add.md' })\n *\n */\nasync function isIgnored({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('dir', dir);\n    assertParameter('gitdir', gitdir);\n    assertParameter('filepath', filepath);\n\n    return GitIgnoreManager.isIgnored({\n      fs: new FileSystem(fs),\n      dir,\n      gitdir,\n      filepath,\n    })\n  } catch (err) {\n    err.caller = 'git.isIgnored';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * List branches\n *\n * By default it lists local branches. If a 'remote' is specified, it lists the remote's branches. When listing remote branches, the HEAD branch is not filtered out, so it may be included in the list of results.\n *\n * Note that specifying a remote does not actually contact the server and update the list of branches.\n * If you want an up-to-date list, first do a `fetch` to that remote.\n * (Which branch you fetch doesn't matter - the list of branches available on the remote is updated during the fetch handshake.)\n *\n * Also note, that a branch is a reference to a commit. If you initialize a new repository it has no commits, so the\n * `listBranches` function will return an empty list, until you create the first commit.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.remote] - Instead of the branches in `refs/heads`, list the branches in `refs/remotes/${remote}`.\n *\n * @returns {Promise<Array<string>>} Resolves successfully with an array of branch names\n *\n * @example\n * let branches = await git.listBranches({ fs, dir: '/tutorial' })\n * console.log(branches)\n * let remoteBranches = await git.listBranches({ fs, dir: '/tutorial', remote: 'origin' })\n * console.log(remoteBranches)\n *\n */\nasync function listBranches({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  remote,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n\n    return GitRefManager.listBranches({\n      fs: new FileSystem(fs),\n      gitdir,\n      remote,\n    })\n  } catch (err) {\n    err.caller = 'git.listBranches';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {string} args.gitdir\n * @param {string} [args.ref]\n *\n * @returns {Promise<Array<string>>}\n */\nasync function _listFiles({ fs, gitdir, ref, cache }) {\n  if (ref) {\n    const oid = await GitRefManager.resolve({ gitdir, fs, ref });\n    const filenames = [];\n    await accumulateFilesFromOid({\n      fs,\n      cache,\n      gitdir,\n      oid,\n      filenames,\n      prefix: '',\n    });\n    return filenames\n  } else {\n    return GitIndexManager.acquire({ fs, gitdir, cache }, async function(\n      index\n    ) {\n      return index.entries.map(x => x.path)\n    })\n  }\n}\n\nasync function accumulateFilesFromOid({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  filenames,\n  prefix,\n}) {\n  const { tree } = await _readTree({ fs, cache, gitdir, oid });\n  // TODO: Use `walk` to do this. Should be faster.\n  for (const entry of tree) {\n    if (entry.type === 'tree') {\n      await accumulateFilesFromOid({\n        fs,\n        cache,\n        gitdir,\n        oid: entry.oid,\n        filenames,\n        prefix: join(prefix, entry.path),\n      });\n    } else {\n      filenames.push(join(prefix, entry.path));\n    }\n  }\n}\n\n// @ts-check\n\n/**\n * List all the files in the git index or a commit\n *\n * > Note: This function is efficient for listing the files in the staging area, but listing all the files in a commit requires recursively walking through the git object store.\n * > If you do not require a complete list of every file, better performance can be achieved by using [walk](./walk) and ignoring subdirectories you don't care about.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - Return a list of all the files in the commit at `ref` instead of the files currently in the git index (aka staging area)\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<Array<string>>} Resolves successfully with an array of filepaths\n *\n * @example\n * // All the files in the previous commit\n * let files = await git.listFiles({ fs, dir: '/tutorial', ref: 'HEAD' })\n * console.log(files)\n * // All the files in the current staging area\n * files = await git.listFiles({ fs, dir: '/tutorial' })\n * console.log(files)\n *\n */\nasync function listFiles({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n\n    return await _listFiles({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      ref,\n    })\n  } catch (err) {\n    err.caller = 'git.listFiles';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * List all the object notes\n *\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} args.ref\n *\n * @returns {Promise<Array<{target: string, note: string}>>}\n */\n\nasync function _listNotes({ fs, cache, gitdir, ref }) {\n  // Get the current note commit\n  let parent;\n  try {\n    parent = await GitRefManager.resolve({ gitdir, fs, ref });\n  } catch (err) {\n    if (err instanceof NotFoundError) {\n      return []\n    }\n  }\n\n  // Create the current note tree\n  const result = await _readTree({\n    fs,\n    cache,\n    gitdir,\n    oid: parent,\n  });\n\n  // Format the tree entries\n  const notes = result.tree.map(entry => ({\n    target: entry.path,\n    note: entry.oid,\n  }));\n  return notes\n}\n\n// @ts-check\n\n/**\n * List all the object notes\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - The notes ref to look under\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<Array<{target: string, note: string}>>} Resolves successfully with an array of entries containing SHA-1 object ids of the note and the object the note targets\n */\n\nasync function listNotes({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref = 'refs/notes/commits',\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n\n    return await _listNotes({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      ref,\n    })\n  } catch (err) {\n    err.caller = 'git.listNotes';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n *\n * @returns {Promise<Array<{remote: string, url: string}>>}\n */\nasync function _listRemotes({ fs, gitdir }) {\n  const config = await GitConfigManager.get({ fs, gitdir });\n  const remoteNames = await config.getSubsections('remote');\n  const remotes = Promise.all(\n    remoteNames.map(async remote => {\n      const url = await config.get(`remote.${remote}.url`);\n      return { remote, url }\n    })\n  );\n  return remotes\n}\n\n// @ts-check\n\n/**\n * List remotes\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n *\n * @returns {Promise<Array<{remote: string, url: string}>>} Resolves successfully with an array of `{remote, url}` objects\n *\n * @example\n * let remotes = await git.listRemotes({ fs, dir: '/tutorial' })\n * console.log(remotes)\n *\n */\nasync function listRemotes({ fs, dir, gitdir = join(dir, '.git') }) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n\n    return await _listRemotes({\n      fs: new FileSystem(fs),\n      gitdir,\n    })\n  } catch (err) {\n    err.caller = 'git.listRemotes';\n    throw err\n  }\n}\n\n/**\n * @typedef {Object} ServerRef - This object has the following schema:\n * @property {string} ref - The name of the ref\n * @property {string} oid - The SHA-1 object id the ref points to\n * @property {string} [target] - The target ref pointed to by a symbolic ref\n * @property {string} [peeled] - If the oid is the SHA-1 object id of an annotated tag, this is the SHA-1 object id that the annotated tag points to\n */\n\nasync function parseListRefsResponse(stream) {\n  const read = GitPktLine.streamReader(stream);\n\n  // TODO: when we re-write everything to minimize memory usage,\n  // we could make this a generator\n  const refs = [];\n\n  let line;\n  while (true) {\n    line = await read();\n    if (line === true) break\n    if (line === null) continue\n    line = line.toString('utf8').replace(/\\n$/, '');\n    const [oid, ref, ...attrs] = line.split(' ');\n    const r = { ref, oid };\n    for (const attr of attrs) {\n      const [name, value] = attr.split(':');\n      if (name === 'symref-target') {\n        r.target = value;\n      } else if (name === 'peeled') {\n        r.peeled = value;\n      }\n    }\n    refs.push(r);\n  }\n\n  return refs\n}\n\n/**\n * @param {object} args\n * @param {string} [args.prefix] - Only list refs that start with this prefix\n * @param {boolean} [args.symrefs = false] - Include symbolic ref targets\n * @param {boolean} [args.peelTags = false] - Include peeled tags values\n * @returns {Uint8Array[]}\n */\nasync function writeListRefsRequest({ prefix, symrefs, peelTags }) {\n  const packstream = [];\n  // command\n  packstream.push(GitPktLine.encode('command=ls-refs\\n'));\n  // capability-list\n  packstream.push(GitPktLine.encode(`agent=${pkg.agent}\\n`));\n  // [command-args]\n  if (peelTags || symrefs || prefix) {\n    packstream.push(GitPktLine.delim());\n  }\n  if (peelTags) packstream.push(GitPktLine.encode('peel'));\n  if (symrefs) packstream.push(GitPktLine.encode('symrefs'));\n  if (prefix) packstream.push(GitPktLine.encode(`ref-prefix ${prefix}`));\n  packstream.push(GitPktLine.flush());\n  return packstream\n}\n\n// @ts-check\n\n/**\n * Fetch a list of refs (branches, tags, etc) from a server.\n *\n * This is a rare command that doesn't require an `fs`, `dir`, or even `gitdir` argument.\n * It just requires an `http` argument.\n *\n * ### About `protocolVersion`\n *\n * There's a rather fun trade-off between Git Protocol Version 1 and Git Protocol Version 2.\n * Version 2 actually requires 2 HTTP requests instead of 1, making it similar to fetch or push in that regard.\n * However, version 2 supports server-side filtering by prefix, whereas that filtering is done client-side in version 1.\n * Which protocol is most efficient therefore depends on the number of refs on the remote, the latency of the server, and speed of the network connection.\n * For an small repos (or fast Internet connections), the requirement to make two trips to the server makes protocol 2 slower.\n * But for large repos (or slow Internet connections), the decreased payload size of the second request makes up for the additional request.\n *\n * Hard numbers vary by situation, but here's some numbers from my machine:\n *\n * Using isomorphic-git in a browser, with a CORS proxy, listing only the branches (refs/heads) of https://github.com/isomorphic-git/isomorphic-git\n * - Protocol Version 1 took ~300ms and transfered 84 KB.\n * - Protocol Version 2 took ~500ms and transfered 4.1 KB.\n *\n * Using isomorphic-git in a browser, with a CORS proxy, listing only the branches (refs/heads) of https://gitlab.com/gitlab-org/gitlab\n * - Protocol Version 1 took ~4900ms and transfered 9.41 MB.\n * - Protocol Version 2 took ~1280ms and transfered 433 KB.\n *\n * Finally, there is a fun quirk regarding the `symrefs` parameter.\n * Protocol Version 1 will generally only return the `HEAD` symref and not others.\n * Historically, this meant that servers don't use symbolic refs except for `HEAD`, which is used to point at the \"default branch\".\n * However Protocol Version 2 can return *all* the symbolic refs on the server.\n * So if you are running your own git server, you could take advantage of that I guess.\n *\n * #### TL;DR\n * If you are _not_ taking advantage of `prefix` I would recommend `protocolVersion: 1`.\n * Otherwise, I recommend to use the default which is `protocolVersion: 2`.\n *\n * @param {object} args\n * @param {HttpClient} args.http - an HTTP client\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} args.url - The URL of the remote repository. Will be gotten from gitconfig if absent.\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.\n * @param {boolean} [args.forPush = false] - By default, the command queries the 'fetch' capabilities. If true, it will ask for the 'push' capabilities.\n * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n * @param {1 | 2} [args.protocolVersion = 2] - Which version of the Git Protocol to use.\n * @param {string} [args.prefix] - Only list refs that start with this prefix\n * @param {boolean} [args.symrefs = false] - Include symbolic ref targets\n * @param {boolean} [args.peelTags = false] - Include annotated tag peeled targets\n *\n * @returns {Promise<ServerRef[]>} Resolves successfully with an array of ServerRef objects\n * @see ServerRef\n *\n * @example\n * // List all the branches on a repo\n * let refs = await git.listServerRefs({\n *   http,\n *   corsProxy: \"https://cors.isomorphic-git.org\",\n *   url: \"https://github.com/isomorphic-git/isomorphic-git.git\",\n *   prefix: \"refs/heads/\",\n * });\n * console.log(refs);\n *\n * @example\n * // Get the default branch on a repo\n * let refs = await git.listServerRefs({\n *   http,\n *   corsProxy: \"https://cors.isomorphic-git.org\",\n *   url: \"https://github.com/isomorphic-git/isomorphic-git.git\",\n *   prefix: \"HEAD\",\n *   symrefs: true,\n * });\n * console.log(refs);\n *\n * @example\n * // List all the tags on a repo\n * let refs = await git.listServerRefs({\n *   http,\n *   corsProxy: \"https://cors.isomorphic-git.org\",\n *   url: \"https://github.com/isomorphic-git/isomorphic-git.git\",\n *   prefix: \"refs/tags/\",\n *   peelTags: true,\n * });\n * console.log(refs);\n *\n * @example\n * // List all the pull requests on a repo\n * let refs = await git.listServerRefs({\n *   http,\n *   corsProxy: \"https://cors.isomorphic-git.org\",\n *   url: \"https://github.com/isomorphic-git/isomorphic-git.git\",\n *   prefix: \"refs/pull/\",\n * });\n * console.log(refs);\n *\n */\nasync function listServerRefs({\n  http,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  corsProxy,\n  url,\n  headers = {},\n  forPush = false,\n  protocolVersion = 2,\n  prefix,\n  symrefs,\n  peelTags,\n}) {\n  try {\n    assertParameter('http', http);\n    assertParameter('url', url);\n\n    const remote = await GitRemoteHTTP.discover({\n      http,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      corsProxy,\n      service: forPush ? 'git-receive-pack' : 'git-upload-pack',\n      url,\n      headers,\n      protocolVersion,\n    });\n\n    if (remote.protocolVersion === 1) {\n      return formatInfoRefs(remote, prefix, symrefs, peelTags)\n    }\n\n    // Protocol Version 2\n    const body = await writeListRefsRequest({ prefix, symrefs, peelTags });\n\n    const res = await GitRemoteHTTP.connect({\n      http,\n      auth: remote.auth,\n      headers,\n      corsProxy,\n      service: forPush ? 'git-receive-pack' : 'git-upload-pack',\n      url,\n      body,\n    });\n\n    return parseListRefsResponse(res.body)\n  } catch (err) {\n    err.caller = 'git.listServerRefs';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * List tags\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n *\n * @returns {Promise<Array<string>>} Resolves successfully with an array of tag names\n *\n * @example\n * let tags = await git.listTags({ fs, dir: '/tutorial' })\n * console.log(tags)\n *\n */\nasync function listTags({ fs, dir, gitdir = join(dir, '.git') }) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    return GitRefManager.listTags({ fs: new FileSystem(fs), gitdir })\n  } catch (err) {\n    err.caller = 'git.listTags';\n    throw err\n  }\n}\n\nasync function resolveCommit({ fs, cache, gitdir, oid }) {\n  const { type, object } = await _readObject({ fs, cache, gitdir, oid });\n  // Resolve annotated tag objects to whatever\n  if (type === 'tag') {\n    oid = GitAnnotatedTag.from(object).parse().object;\n    return resolveCommit({ fs, cache, gitdir, oid })\n  }\n  if (type !== 'commit') {\n    throw new ObjectTypeError(oid, type, 'commit')\n  }\n  return { commit: GitCommit.from(object), oid }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} args.oid\n *\n * @returns {Promise<ReadCommitResult>} Resolves successfully with a git commit object\n * @see ReadCommitResult\n * @see CommitObject\n *\n */\nasync function _readCommit({ fs, cache, gitdir, oid }) {\n  const { commit, oid: commitOid } = await resolveCommit({\n    fs,\n    cache,\n    gitdir,\n    oid,\n  });\n  const result = {\n    oid: commitOid,\n    commit: commit.parse(),\n    payload: commit.withoutSignature(),\n  };\n  // @ts-ignore\n  return result\n}\n\nfunction compareAge(a, b) {\n  return a.committer.timestamp - b.committer.timestamp\n}\n\n// @ts-check\n\n// the empty file content object id\nconst EMPTY_OID = 'e69de29bb2d1d6434b8b29ae775ad8c2e48c5391';\n\nasync function resolveFileIdInTree({ fs, cache, gitdir, oid, fileId }) {\n  if (fileId === EMPTY_OID) return\n  const _oid = oid;\n  let filepath;\n  const result = await resolveTree({ fs, cache, gitdir, oid });\n  const tree = result.tree;\n  if (fileId === result.oid) {\n    filepath = result.path;\n  } else {\n    filepath = await _resolveFileId({\n      fs,\n      cache,\n      gitdir,\n      tree,\n      fileId,\n      oid: _oid,\n    });\n    if (Array.isArray(filepath)) {\n      if (filepath.length === 0) filepath = undefined;\n      else if (filepath.length === 1) filepath = filepath[0];\n    }\n  }\n  return filepath\n}\n\nasync function _resolveFileId({\n  fs,\n  cache,\n  gitdir,\n  tree,\n  fileId,\n  oid,\n  filepaths = [],\n  parentPath = '',\n}) {\n  const walks = tree.entries().map(function(entry) {\n    let result;\n    if (entry.oid === fileId) {\n      result = join(parentPath, entry.path);\n      filepaths.push(result);\n    } else if (entry.type === 'tree') {\n      result = _readObject({\n        fs,\n        cache,\n        gitdir,\n        oid: entry.oid,\n      }).then(function({ object }) {\n        return _resolveFileId({\n          fs,\n          cache,\n          gitdir,\n          tree: GitTree.from(object),\n          fileId,\n          oid,\n          filepaths,\n          parentPath: join(parentPath, entry.path),\n        })\n      });\n    }\n    return result\n  });\n\n  await Promise.all(walks);\n  return filepaths\n}\n\n// @ts-check\n\n/**\n * Get commit descriptions from the git history\n *\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string=} args.filepath optional get the commit for the filepath only\n * @param {string} args.ref\n * @param {number|void} args.depth\n * @param {boolean=} [args.force=false] do not throw error if filepath is not exist (works only for a single file). defaults to false\n * @param {boolean=} [args.follow=false] Continue listing the history of a file beyond renames (works only for a single file). defaults to false\n * @param {boolean=} args.follow Continue listing the history of a file beyond renames (works only for a single file). defaults to false\n *\n * @returns {Promise<Array<ReadCommitResult>>} Resolves to an array of ReadCommitResult objects\n * @see ReadCommitResult\n * @see CommitObject\n *\n * @example\n * let commits = await git.log({ dir: '$input((/))', depth: $input((5)), ref: '$input((master))' })\n * console.log(commits)\n *\n */\nasync function _log({\n  fs,\n  cache,\n  gitdir,\n  filepath,\n  ref,\n  depth,\n  since,\n  force,\n  follow,\n}) {\n  const sinceTimestamp =\n    typeof since === 'undefined'\n      ? undefined\n      : Math.floor(since.valueOf() / 1000);\n  // TODO: In the future, we may want to have an API where we return a\n  // async iterator that emits commits.\n  const commits = [];\n  const shallowCommits = await GitShallowManager.read({ fs, gitdir });\n  const oid = await GitRefManager.resolve({ fs, gitdir, ref });\n  const tips = [await _readCommit({ fs, cache, gitdir, oid })];\n  let lastFileOid;\n  let lastCommit;\n  let isOk;\n\n  function endCommit(commit) {\n    if (isOk && filepath) commits.push(commit);\n  }\n\n  while (tips.length > 0) {\n    const commit = tips.pop();\n\n    // Stop the log if we've hit the age limit\n    if (\n      sinceTimestamp !== undefined &&\n      commit.commit.committer.timestamp <= sinceTimestamp\n    ) {\n      break\n    }\n\n    if (filepath) {\n      let vFileOid;\n      try {\n        vFileOid = await resolveFilepath({\n          fs,\n          cache,\n          gitdir,\n          oid: commit.commit.tree,\n          filepath,\n        });\n        if (lastCommit && lastFileOid !== vFileOid) {\n          commits.push(lastCommit);\n        }\n        lastFileOid = vFileOid;\n        lastCommit = commit;\n        isOk = true;\n      } catch (e) {\n        if (e instanceof NotFoundError) {\n          let found = follow && lastFileOid;\n          if (found) {\n            found = await resolveFileIdInTree({\n              fs,\n              cache,\n              gitdir,\n              oid: commit.commit.tree,\n              fileId: lastFileOid,\n            });\n            if (found) {\n              if (Array.isArray(found)) {\n                if (lastCommit) {\n                  const lastFound = await resolveFileIdInTree({\n                    fs,\n                    cache,\n                    gitdir,\n                    oid: lastCommit.commit.tree,\n                    fileId: lastFileOid,\n                  });\n                  if (Array.isArray(lastFound)) {\n                    found = found.filter(p => lastFound.indexOf(p) === -1);\n                    if (found.length === 1) {\n                      found = found[0];\n                      filepath = found;\n                      if (lastCommit) commits.push(lastCommit);\n                    } else {\n                      found = false;\n                      if (lastCommit) commits.push(lastCommit);\n                      break\n                    }\n                  }\n                }\n              } else {\n                filepath = found;\n                if (lastCommit) commits.push(lastCommit);\n              }\n            }\n          }\n          if (!found) {\n            if (isOk && lastFileOid) {\n              commits.push(lastCommit);\n              if (!force) break\n            }\n            if (!force && !follow) throw e\n          }\n          lastCommit = commit;\n          isOk = false;\n        } else throw e\n      }\n    } else {\n      commits.push(commit);\n    }\n\n    // Stop the loop if we have enough commits now.\n    if (depth !== undefined && commits.length === depth) {\n      endCommit(commit);\n      break\n    }\n\n    // If this is not a shallow commit...\n    if (!shallowCommits.has(commit.oid)) {\n      // Add the parents of this commit to the queue\n      // Note: for the case of a commit with no parents, it will concat an empty array, having no net effect.\n      for (const oid of commit.commit.parent) {\n        const commit = await _readCommit({ fs, cache, gitdir, oid });\n        if (!tips.map(commit => commit.oid).includes(commit.oid)) {\n          tips.push(commit);\n        }\n      }\n    }\n\n    // Stop the loop if there are no more commit parents\n    if (tips.length === 0) {\n      endCommit(commit);\n    }\n\n    // Process tips in order by age\n    tips.sort((a, b) => compareAge(a.commit, b.commit));\n  }\n  return commits\n}\n\n// @ts-check\n\n/**\n * Get commit descriptions from the git history\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string=} args.filepath optional get the commit for the filepath only\n * @param {string} [args.ref = 'HEAD'] - The commit to begin walking backwards through the history from\n * @param {number=} [args.depth] - Limit the number of commits returned. No limit by default.\n * @param {Date} [args.since] - Return history newer than the given date. Can be combined with `depth` to get whichever is shorter.\n * @param {boolean=} [args.force=false] do not throw error if filepath is not exist (works only for a single file). defaults to false\n * @param {boolean=} [args.follow=false] Continue listing the history of a file beyond renames (works only for a single file). defaults to false\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<Array<ReadCommitResult>>} Resolves to an array of ReadCommitResult objects\n * @see ReadCommitResult\n * @see CommitObject\n *\n * @example\n * let commits = await git.log({\n *   fs,\n *   dir: '/tutorial',\n *   depth: 5,\n *   ref: 'main'\n * })\n * console.log(commits)\n *\n */\nasync function log({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath,\n  ref = 'HEAD',\n  depth,\n  since, // Date\n  force,\n  follow,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n\n    return await _log({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      filepath,\n      ref,\n      depth,\n      since,\n      force,\n      follow,\n    })\n  } catch (err) {\n    err.caller = 'git.log';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} MergeResult - Returns an object with a schema like this:\n * @property {string} [oid] - The SHA-1 object id that is now at the head of the branch. Absent only if `dryRun` was specified and `mergeCommit` is true.\n * @property {boolean} [alreadyMerged] - True if the branch was already merged so no changes were made\n * @property {boolean} [fastForward] - True if it was a fast-forward merge\n * @property {boolean} [mergeCommit] - True if merge resulted in a merge commit\n * @property {string} [tree] - The SHA-1 object id of the tree resulting from a merge commit\n *\n */\n\n/**\n * Merge two branches\n *\n * Currently it will fail if multiple candidate merge bases are found. (It doesn't yet implement the recursive merge strategy.)\n *\n * Currently it does not support selecting alternative merge strategies.\n *\n * Currently it is not possible to abort an incomplete merge. To restore the worktree to a clean state, you will need to checkout an earlier commit.\n *\n * Currently it does not directly support the behavior of `git merge --continue`. To complete a merge after manual conflict resolution, you will need to add and commit the files manually, and specify the appropriate parent commits.\n *\n * ## Manually resolving merge conflicts\n * By default, if isomorphic-git encounters a merge conflict it cannot resolve using the builtin diff3 algorithm or provided merge driver, it will abort and throw a `MergeNotSupportedError`.\n * This leaves the index and working tree untouched.\n *\n * When `abortOnConflict` is set to `false`, and a merge conflict cannot be automatically resolved, a `MergeConflictError` is thrown and the results of the incomplete merge will be written to the working directory.\n * This includes conflict markers in files with unresolved merge conflicts.\n *\n * To complete the merge, edit the conflicting files as you see fit, and then add and commit the resolved merge.\n *\n * For a proper merge commit, be sure to specify the branches or commits you are merging in the `parent` argument to `git.commit`.\n * For example, say we are merging the branch `feature` into the branch `main` and there is a conflict we want to resolve manually.\n * The flow would look like this:\n *\n * ```\n * await git.merge({\n *   fs,\n *   dir,\n *   ours: 'main',\n *   theirs: 'feature',\n *   abortOnConflict: false,\n * }).catch(e => {\n *   if (e instanceof Errors.MergeConflictError) {\n *     console.log(\n *       'Automatic merge failed for the following files: '\n *       + `${e.data}. `\n *       + 'Resolve these conflicts and then commit your changes.'\n *     )\n *   } else throw e\n * })\n *\n * // This is the where we manually edit the files that have been written to the working directory\n * // ...\n * // Files have been edited and we are ready to commit\n *\n * await git.add({\n *   fs,\n *   dir,\n *   filepath: '.',\n * })\n *\n * await git.commit({\n *   fs,\n *   dir,\n *   ref: 'main',\n *   message: \"Merge branch 'feature' into main\",\n *   parent: ['main', 'feature'], // Be sure to specify the parents when creating a merge commit\n * })\n * ```\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {SignCallback} [args.onSign] - a PGP signing implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ours] - The branch receiving the merge. If undefined, defaults to the current branch.\n * @param {string} args.theirs - The branch to be merged\n * @param {boolean} [args.fastForward = true] - If false, create a merge commit in all cases.\n * @param {boolean} [args.fastForwardOnly = false] - If true, then non-fast-forward merges will throw an Error instead of performing a merge.\n * @param {boolean} [args.dryRun = false] - If true, simulates a merge so you can test whether it would succeed.\n * @param {boolean} [args.noUpdateBranch = false] - If true, does not update the branch pointer after creating the commit.\n * @param {boolean} [args.abortOnConflict = true] - If true, merges with conflicts will not update the worktree or index.\n * @param {string} [args.message] - Overrides the default auto-generated merge commit message\n * @param {Object} [args.author] - passed to [commit](commit.md) when creating a merge commit\n * @param {string} [args.author.name] - Default is `user.name` config.\n * @param {string} [args.author.email] - Default is `user.email` config.\n * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {Object} [args.committer] - passed to [commit](commit.md) when creating a merge commit\n * @param {string} [args.committer.name] - Default is `user.name` config.\n * @param {string} [args.committer.email] - Default is `user.email` config.\n * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {string} [args.signingKey] - passed to [commit](commit.md) when creating a merge commit\n * @param {object} [args.cache] - a [cache](cache.md) object\n * @param {MergeDriverCallback} [args.mergeDriver] - a [merge driver](mergeDriver.md) implementation\n *\n * @returns {Promise<MergeResult>} Resolves to a description of the merge operation\n * @see MergeResult\n *\n * @example\n * let m = await git.merge({\n *   fs,\n *   dir: '/tutorial',\n *   ours: 'main',\n *   theirs: 'remotes/origin/main'\n * })\n * console.log(m)\n *\n */\nasync function merge({\n  fs: _fs,\n  onSign,\n  dir,\n  gitdir = join(dir, '.git'),\n  ours,\n  theirs,\n  fastForward = true,\n  fastForwardOnly = false,\n  dryRun = false,\n  noUpdateBranch = false,\n  abortOnConflict = true,\n  message,\n  author: _author,\n  committer: _committer,\n  signingKey,\n  cache = {},\n  mergeDriver,\n}) {\n  try {\n    assertParameter('fs', _fs);\n    if (signingKey) {\n      assertParameter('onSign', onSign);\n    }\n    const fs = new FileSystem(_fs);\n\n    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });\n    if (!author && (!fastForwardOnly || !fastForward)) {\n      throw new MissingNameError('author')\n    }\n\n    const committer = await normalizeCommitterObject({\n      fs,\n      gitdir,\n      author,\n      committer: _committer,\n    });\n    if (!committer && (!fastForwardOnly || !fastForward)) {\n      throw new MissingNameError('committer')\n    }\n\n    return await _merge({\n      fs,\n      cache,\n      dir,\n      gitdir,\n      ours,\n      theirs,\n      fastForward,\n      fastForwardOnly,\n      dryRun,\n      noUpdateBranch,\n      abortOnConflict,\n      message,\n      author,\n      committer,\n      signingKey,\n      onSign,\n      mergeDriver,\n    })\n  } catch (err) {\n    err.caller = 'git.merge';\n    throw err\n  }\n}\n\n/**\n * @enum {number}\n */\nconst types = {\n  commit: 0b0010000,\n  tree: 0b0100000,\n  blob: 0b0110000,\n  tag: 0b1000000,\n  ofs_delta: 0b1100000,\n  ref_delta: 0b1110000,\n};\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string[]} args.oids\n */\nasync function _pack({\n  fs,\n  cache,\n  dir,\n  gitdir = join(dir, '.git'),\n  oids,\n}) {\n  const hash = new Hash();\n  const outputStream = [];\n  function write(chunk, enc) {\n    const buff = Buffer.from(chunk, enc);\n    outputStream.push(buff);\n    hash.update(buff);\n  }\n  async function writeObject({ stype, object }) {\n    // Object type is encoded in bits 654\n    const type = types[stype];\n    // The length encoding gets complicated.\n    let length = object.length;\n    // Whether the next byte is part of the variable-length encoded number\n    // is encoded in bit 7\n    let multibyte = length > 0b1111 ? 0b10000000 : 0b0;\n    // Last four bits of length is encoded in bits 3210\n    const lastFour = length & 0b1111;\n    // Discard those bits\n    length = length >>> 4;\n    // The first byte is then (1-bit multibyte?), (3-bit type), (4-bit least sig 4-bits of length)\n    let byte = (multibyte | type | lastFour).toString(16);\n    write(byte, 'hex');\n    // Now we keep chopping away at length 7-bits at a time until its zero,\n    // writing out the bytes in what amounts to little-endian order.\n    while (multibyte) {\n      multibyte = length > 0b01111111 ? 0b10000000 : 0b0;\n      byte = multibyte | (length & 0b01111111);\n      write(padHex(2, byte), 'hex');\n      length = length >>> 7;\n    }\n    // Lastly, we can compress and write the object.\n    write(Buffer.from(await deflate(object)));\n  }\n  write('PACK');\n  write('00000002', 'hex');\n  // Write a 4 byte (32-bit) int\n  write(padHex(8, oids.length), 'hex');\n  for (const oid of oids) {\n    const { type, object } = await _readObject({ fs, cache, gitdir, oid });\n    await writeObject({ write, object, stype: type });\n  }\n  // Write SHA1 checksum\n  const digest = hash.digest();\n  outputStream.push(digest);\n  return outputStream\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} PackObjectsResult The packObjects command returns an object with two properties:\n * @property {string} filename - The suggested filename for the packfile if you want to save it to disk somewhere. It includes the packfile SHA.\n * @property {Uint8Array} [packfile] - The packfile contents. Not present if `write` parameter was true, in which case the packfile was written straight to disk.\n */\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string[]} args.oids\n * @param {boolean} args.write\n *\n * @returns {Promise<PackObjectsResult>}\n * @see PackObjectsResult\n */\nasync function _packObjects({ fs, cache, gitdir, oids, write }) {\n  const buffers = await _pack({ fs, cache, gitdir, oids });\n  const packfile = Buffer.from(await collect(buffers));\n  const packfileSha = packfile.slice(-20).toString('hex');\n  const filename = `pack-${packfileSha}.pack`;\n  if (write) {\n    await fs.write(join(gitdir, `objects/pack/${filename}`), packfile);\n    return { filename }\n  }\n  return {\n    filename,\n    packfile: new Uint8Array(packfile),\n  }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} PackObjectsResult The packObjects command returns an object with two properties:\n * @property {string} filename - The suggested filename for the packfile if you want to save it to disk somewhere. It includes the packfile SHA.\n * @property {Uint8Array} [packfile] - The packfile contents. Not present if `write` parameter was true, in which case the packfile was written straight to disk.\n */\n\n/**\n * Create a packfile from an array of SHA-1 object ids\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string[]} args.oids - An array of SHA-1 object ids to be included in the packfile\n * @param {boolean} [args.write = false] - Whether to save the packfile to disk or not\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<PackObjectsResult>} Resolves successfully when the packfile is ready with the filename and buffer\n * @see PackObjectsResult\n *\n * @example\n * // Create a packfile containing only an empty tree\n * let { packfile } = await git.packObjects({\n *   fs,\n *   dir: '/tutorial',\n *   oids: ['4b825dc642cb6eb9a060e54bf8d69288fbee4904']\n * })\n * console.log(packfile)\n *\n */\nasync function packObjects({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oids,\n  write = false,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oids', oids);\n\n    return await _packObjects({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      oids,\n      write,\n    })\n  } catch (err) {\n    err.caller = 'git.packObjects';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Fetch and merge commits from a remote repository\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {HttpClient} args.http - an HTTP client\n * @param {ProgressCallback} [args.onProgress] - optional progress event callback\n * @param {MessageCallback} [args.onMessage] - optional message event callback\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - Which branch to merge into. By default this is the currently checked out branch.\n * @param {string} [args.url] - (Added in 1.1.0) The URL of the remote repository. The default is the value set in the git config for that remote.\n * @param {string} [args.remote] - (Added in 1.1.0) If URL is not specified, determines which remote to use.\n * @param {string} [args.remoteRef] - (Added in 1.1.0) The name of the branch on the remote to fetch. By default this is the configured remote tracking branch.\n * @param {boolean} [args.prune = false] - Delete local remote-tracking branches that are not present on the remote\n * @param {boolean} [args.pruneTags = false] - Prune local tags that dont exist on the remote, and force-update those tags that differ\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.\n * @param {boolean} [args.singleBranch = false] - Instead of the default behavior of fetching all the branches, only fetch a single branch.\n * @param {boolean} [args.fastForward = true] -  If false, only create merge commits.\n * @param {boolean} [args.fastForwardOnly = false] - Only perform simple fast-forward merges. (Don't create merge commits.)\n * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n * @param {Object} [args.author] - The details about the author.\n * @param {string} [args.author.name] - Default is `user.name` config.\n * @param {string} [args.author.email] - Default is `user.email` config.\n * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {Object} [args.committer = author] - The details about the commit committer, in the same format as the author parameter. If not specified, the author details are used.\n * @param {string} [args.committer.name] - Default is `user.name` config.\n * @param {string} [args.committer.email] - Default is `user.email` config.\n * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {string} [args.signingKey] - passed to [commit](commit.md) when creating a merge commit\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully when pull operation completes\n *\n * @example\n * await git.pull({\n *   fs,\n *   http,\n *   dir: '/tutorial',\n *   ref: 'main',\n *   singleBranch: true\n * })\n * console.log('done')\n *\n */\nasync function pull({\n  fs: _fs,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  url,\n  remote,\n  remoteRef,\n  prune = false,\n  pruneTags = false,\n  fastForward = true,\n  fastForwardOnly = false,\n  corsProxy,\n  singleBranch,\n  headers = {},\n  author: _author,\n  committer: _committer,\n  signingKey,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n\n    const fs = new FileSystem(_fs);\n\n    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });\n    if (!author) throw new MissingNameError('author')\n\n    const committer = await normalizeCommitterObject({\n      fs,\n      gitdir,\n      author,\n      committer: _committer,\n    });\n    if (!committer) throw new MissingNameError('committer')\n\n    return await _pull({\n      fs,\n      cache,\n      http,\n      onProgress,\n      onMessage,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      dir,\n      gitdir,\n      ref,\n      url,\n      remote,\n      remoteRef,\n      fastForward,\n      fastForwardOnly,\n      corsProxy,\n      singleBranch,\n      headers,\n      author,\n      committer,\n      signingKey,\n      prune,\n      pruneTags,\n    })\n  } catch (err) {\n    err.caller = 'git.pull';\n    throw err\n  }\n}\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} [args.dir]\n * @param {string} args.gitdir\n * @param {Iterable<string>} args.start\n * @param {Iterable<string>} args.finish\n * @returns {Promise<Set<string>>}\n */\nasync function listCommitsAndTags({\n  fs,\n  cache,\n  dir,\n  gitdir = join(dir, '.git'),\n  start,\n  finish,\n}) {\n  const shallows = await GitShallowManager.read({ fs, gitdir });\n  const startingSet = new Set();\n  const finishingSet = new Set();\n  for (const ref of start) {\n    startingSet.add(await GitRefManager.resolve({ fs, gitdir, ref }));\n  }\n  for (const ref of finish) {\n    // We may not have these refs locally so we must try/catch\n    try {\n      const oid = await GitRefManager.resolve({ fs, gitdir, ref });\n      finishingSet.add(oid);\n    } catch (err) {}\n  }\n  const visited = new Set();\n  // Because git commits are named by their hash, there is no\n  // way to construct a cycle. Therefore we won't worry about\n  // setting a default recursion limit.\n  async function walk(oid) {\n    visited.add(oid);\n    const { type, object } = await _readObject({ fs, cache, gitdir, oid });\n    // Recursively resolve annotated tags\n    if (type === 'tag') {\n      const tag = GitAnnotatedTag.from(object);\n      const commit = tag.headers().object;\n      return walk(commit)\n    }\n    if (type !== 'commit') {\n      throw new ObjectTypeError(oid, type, 'commit')\n    }\n    if (!shallows.has(oid)) {\n      const commit = GitCommit.from(object);\n      const parents = commit.headers().parent;\n      for (oid of parents) {\n        if (!finishingSet.has(oid) && !visited.has(oid)) {\n          await walk(oid);\n        }\n      }\n    }\n  }\n  // Let's go walking!\n  for (const oid of startingSet) {\n    await walk(oid);\n  }\n  return visited\n}\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} [args.dir]\n * @param {string} args.gitdir\n * @param {Iterable<string>} args.oids\n * @returns {Promise<Set<string>>}\n */\nasync function listObjects({\n  fs,\n  cache,\n  dir,\n  gitdir = join(dir, '.git'),\n  oids,\n}) {\n  const visited = new Set();\n  // We don't do the purest simplest recursion, because we can\n  // avoid reading Blob objects entirely since the Tree objects\n  // tell us which oids are Blobs and which are Trees.\n  async function walk(oid) {\n    if (visited.has(oid)) return\n    visited.add(oid);\n    const { type, object } = await _readObject({ fs, cache, gitdir, oid });\n    if (type === 'tag') {\n      const tag = GitAnnotatedTag.from(object);\n      const obj = tag.headers().object;\n      await walk(obj);\n    } else if (type === 'commit') {\n      const commit = GitCommit.from(object);\n      const tree = commit.headers().tree;\n      await walk(tree);\n    } else if (type === 'tree') {\n      const tree = GitTree.from(object);\n      for (const entry of tree) {\n        // add blobs to the set\n        // skip over submodules whose type is 'commit'\n        if (entry.type === 'blob') {\n          visited.add(entry.oid);\n        }\n        // recurse for trees\n        if (entry.type === 'tree') {\n          await walk(entry.oid);\n        }\n      }\n    }\n  }\n  // Let's go walking!\n  for (const oid of oids) {\n    await walk(oid);\n  }\n  return visited\n}\n\nasync function parseReceivePackResponse(packfile) {\n  /** @type PushResult */\n  const result = {};\n  let response = '';\n  const read = GitPktLine.streamReader(packfile);\n  let line = await read();\n  while (line !== true) {\n    if (line !== null) response += line.toString('utf8') + '\\n';\n    line = await read();\n  }\n\n  const lines = response.toString('utf8').split('\\n');\n  // We're expecting \"unpack {unpack-result}\"\n  line = lines.shift();\n  if (!line.startsWith('unpack ')) {\n    throw new ParseError('unpack ok\" or \"unpack [error message]', line)\n  }\n  result.ok = line === 'unpack ok';\n  if (!result.ok) {\n    result.error = line.slice('unpack '.length);\n  }\n  result.refs = {};\n  for (const line of lines) {\n    if (line.trim() === '') continue\n    const status = line.slice(0, 2);\n    const refAndMessage = line.slice(3);\n    let space = refAndMessage.indexOf(' ');\n    if (space === -1) space = refAndMessage.length;\n    const ref = refAndMessage.slice(0, space);\n    const error = refAndMessage.slice(space + 1);\n    result.refs[ref] = {\n      ok: status === 'ok',\n      error,\n    };\n  }\n  return result\n}\n\nasync function writeReceivePackRequest({\n  capabilities = [],\n  triplets = [],\n}) {\n  const packstream = [];\n  let capsFirstLine = `\\x00 ${capabilities.join(' ')}`;\n  for (const trip of triplets) {\n    packstream.push(\n      GitPktLine.encode(\n        `${trip.oldoid} ${trip.oid} ${trip.fullRef}${capsFirstLine}\\n`\n      )\n    );\n    capsFirstLine = '';\n  }\n  packstream.push(GitPktLine.flush());\n  return packstream\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {HttpClient} args.http\n * @param {ProgressCallback} [args.onProgress]\n * @param {MessageCallback} [args.onMessage]\n * @param {AuthCallback} [args.onAuth]\n * @param {AuthFailureCallback} [args.onAuthFailure]\n * @param {AuthSuccessCallback} [args.onAuthSuccess]\n * @param {string} args.gitdir\n * @param {string} [args.ref]\n * @param {string} [args.remoteRef]\n * @param {string} [args.remote]\n * @param {boolean} [args.force = false]\n * @param {boolean} [args.delete = false]\n * @param {string} [args.url]\n * @param {string} [args.corsProxy]\n * @param {Object<string, string>} [args.headers]\n *\n * @returns {Promise<PushResult>}\n */\nasync function _push({\n  fs,\n  cache,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  gitdir,\n  ref: _ref,\n  remoteRef: _remoteRef,\n  remote,\n  url: _url,\n  force = false,\n  delete: _delete = false,\n  corsProxy,\n  headers = {},\n}) {\n  const ref = _ref || (await _currentBranch({ fs, gitdir }));\n  if (typeof ref === 'undefined') {\n    throw new MissingParameterError('ref')\n  }\n  const config = await GitConfigManager.get({ fs, gitdir });\n  // Figure out what remote to use.\n  remote =\n    remote ||\n    (await config.get(`branch.${ref}.pushRemote`)) ||\n    (await config.get('remote.pushDefault')) ||\n    (await config.get(`branch.${ref}.remote`)) ||\n    'origin';\n  // Lookup the URL for the given remote.\n  const url =\n    _url ||\n    (await config.get(`remote.${remote}.pushurl`)) ||\n    (await config.get(`remote.${remote}.url`));\n  if (typeof url === 'undefined') {\n    throw new MissingParameterError('remote OR url')\n  }\n  // Figure out what remote ref to use.\n  const remoteRef = _remoteRef || (await config.get(`branch.${ref}.merge`));\n  if (typeof url === 'undefined') {\n    throw new MissingParameterError('remoteRef')\n  }\n\n  if (corsProxy === undefined) {\n    corsProxy = await config.get('http.corsProxy');\n  }\n\n  const fullRef = await GitRefManager.expand({ fs, gitdir, ref });\n  const oid = _delete\n    ? '0000000000000000000000000000000000000000'\n    : await GitRefManager.resolve({ fs, gitdir, ref: fullRef });\n\n  /** @type typeof import(\"../managers/GitRemoteHTTP\").GitRemoteHTTP */\n  const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({ url });\n  const httpRemote = await GitRemoteHTTP.discover({\n    http,\n    onAuth,\n    onAuthSuccess,\n    onAuthFailure,\n    corsProxy,\n    service: 'git-receive-pack',\n    url,\n    headers,\n    protocolVersion: 1,\n  });\n  const auth = httpRemote.auth; // hack to get new credentials from CredentialManager API\n  let fullRemoteRef;\n  if (!remoteRef) {\n    fullRemoteRef = fullRef;\n  } else {\n    try {\n      fullRemoteRef = await GitRefManager.expandAgainstMap({\n        ref: remoteRef,\n        map: httpRemote.refs,\n      });\n    } catch (err) {\n      if (err instanceof NotFoundError) {\n        // The remote reference doesn't exist yet.\n        // If it is fully specified, use that value. Otherwise, treat it as a branch.\n        fullRemoteRef = remoteRef.startsWith('refs/')\n          ? remoteRef\n          : `refs/heads/${remoteRef}`;\n      } else {\n        throw err\n      }\n    }\n  }\n  const oldoid =\n    httpRemote.refs.get(fullRemoteRef) ||\n    '0000000000000000000000000000000000000000';\n\n  // Remotes can always accept thin-packs UNLESS they specify the 'no-thin' capability\n  const thinPack = !httpRemote.capabilities.has('no-thin');\n\n  let objects = new Set();\n  if (!_delete) {\n    const finish = [...httpRemote.refs.values()];\n    let skipObjects = new Set();\n\n    // If remote branch is present, look for a common merge base.\n    if (oldoid !== '0000000000000000000000000000000000000000') {\n      // trick to speed up common force push scenarios\n      const mergebase = await _findMergeBase({\n        fs,\n        cache,\n        gitdir,\n        oids: [oid, oldoid],\n      });\n      for (const oid of mergebase) finish.push(oid);\n      if (thinPack) {\n        skipObjects = await listObjects({ fs, cache, gitdir, oids: mergebase });\n      }\n    }\n\n    // If remote does not have the commit, figure out the objects to send\n    if (!finish.includes(oid)) {\n      const commits = await listCommitsAndTags({\n        fs,\n        cache,\n        gitdir,\n        start: [oid],\n        finish,\n      });\n      objects = await listObjects({ fs, cache, gitdir, oids: commits });\n    }\n\n    if (thinPack) {\n      // If there's a default branch for the remote lets skip those objects too.\n      // Since this is an optional optimization, we just catch and continue if there is\n      // an error (because we can't find a default branch, or can't find a commit, etc)\n      try {\n        // Sadly, the discovery phase with 'forPush' doesn't return symrefs, so we have to\n        // rely on existing ones.\n        const ref = await GitRefManager.resolve({\n          fs,\n          gitdir,\n          ref: `refs/remotes/${remote}/HEAD`,\n          depth: 2,\n        });\n        const { oid } = await GitRefManager.resolveAgainstMap({\n          ref: ref.replace(`refs/remotes/${remote}/`, ''),\n          fullref: ref,\n          map: httpRemote.refs,\n        });\n        const oids = [oid];\n        for (const oid of await listObjects({ fs, cache, gitdir, oids })) {\n          skipObjects.add(oid);\n        }\n      } catch (e) {}\n\n      // Remove objects that we know the remote already has\n      for (const oid of skipObjects) {\n        objects.delete(oid);\n      }\n    }\n\n    if (oid === oldoid) force = true;\n    if (!force) {\n      // Is it a tag that already exists?\n      if (\n        fullRef.startsWith('refs/tags') &&\n        oldoid !== '0000000000000000000000000000000000000000'\n      ) {\n        throw new PushRejectedError('tag-exists')\n      }\n      // Is it a non-fast-forward commit?\n      if (\n        oid !== '0000000000000000000000000000000000000000' &&\n        oldoid !== '0000000000000000000000000000000000000000' &&\n        !(await _isDescendent({\n          fs,\n          cache,\n          gitdir,\n          oid,\n          ancestor: oldoid,\n          depth: -1,\n        }))\n      ) {\n        throw new PushRejectedError('not-fast-forward')\n      }\n    }\n  }\n  // We can only safely use capabilities that the server also understands.\n  // For instance, AWS CodeCommit aborts a push if you include the `agent`!!!\n  const capabilities = filterCapabilities(\n    [...httpRemote.capabilities],\n    ['report-status', 'side-band-64k', `agent=${pkg.agent}`]\n  );\n  const packstream1 = await writeReceivePackRequest({\n    capabilities,\n    triplets: [{ oldoid, oid, fullRef: fullRemoteRef }],\n  });\n  const packstream2 = _delete\n    ? []\n    : await _pack({\n        fs,\n        cache,\n        gitdir,\n        oids: [...objects],\n      });\n  const res = await GitRemoteHTTP.connect({\n    http,\n    onProgress,\n    corsProxy,\n    service: 'git-receive-pack',\n    url,\n    auth,\n    headers,\n    body: [...packstream1, ...packstream2],\n  });\n  const { packfile, progress } = await GitSideBand.demux(res.body);\n  if (onMessage) {\n    const lines = splitLines(progress);\n    forAwait(lines, async line => {\n      await onMessage(line);\n    });\n  }\n  // Parse the response!\n  const result = await parseReceivePackResponse(packfile);\n  if (res.headers) {\n    result.headers = res.headers;\n  }\n\n  // Update the local copy of the remote ref\n  if (remote && result.ok && result.refs[fullRemoteRef].ok) {\n    // TODO: I think this should actually be using a refspec transform rather than assuming 'refs/remotes/{remote}'\n    const ref = `refs/remotes/${remote}/${fullRemoteRef.replace(\n      'refs/heads',\n      ''\n    )}`;\n    if (_delete) {\n      await GitRefManager.deleteRef({ fs, gitdir, ref });\n    } else {\n      await GitRefManager.writeRef({ fs, gitdir, ref, value: oid });\n    }\n  }\n  if (result.ok && Object.values(result.refs).every(result => result.ok)) {\n    return result\n  } else {\n    const prettyDetails = Object.entries(result.refs)\n      .filter(([k, v]) => !v.ok)\n      .map(([k, v]) => `\\n  - ${k}: ${v.error}`)\n      .join('');\n    throw new GitPushError(prettyDetails, result)\n  }\n}\n\n// @ts-check\n\n/**\n * Push a branch or tag\n *\n * The push command returns an object that describes the result of the attempted push operation.\n * *Notes:* If there were no errors, then there will be no `errors` property. There can be a mix of `ok` messages and `errors` messages.\n *\n * | param  | type [= default] | description                                                                                                                                                                                                      |\n * | ------ | ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n * | ok     | Array\\<string\\>  | The first item is \"unpack\" if the overall operation was successful. The remaining items are the names of refs that were updated successfully.                                                                    |\n * | errors | Array\\<string\\>  | If the overall operation threw and error, the first item will be \"unpack {Overall error message}\". The remaining items are individual refs that failed to be updated in the format \"{ref name} {error message}\". |\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {HttpClient} args.http - an HTTP client\n * @param {ProgressCallback} [args.onProgress] - optional progress event callback\n * @param {MessageCallback} [args.onMessage] - optional message event callback\n * @param {AuthCallback} [args.onAuth] - optional auth fill callback\n * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback\n * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - Which branch to push. By default this is the currently checked out branch.\n * @param {string} [args.url] - The URL of the remote repository. The default is the value set in the git config for that remote.\n * @param {string} [args.remote] - If URL is not specified, determines which remote to use.\n * @param {string} [args.remoteRef] - The name of the receiving branch on the remote. By default this is the configured remote tracking branch.\n * @param {boolean} [args.force = false] - If true, behaves the same as `git push --force`\n * @param {boolean} [args.delete = false] - If true, delete the remote ref\n * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.\n * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<PushResult>} Resolves successfully when push completes with a detailed description of the operation from the server.\n * @see PushResult\n * @see RefUpdateStatus\n *\n * @example\n * let pushResult = await git.push({\n *   fs,\n *   http,\n *   dir: '/tutorial',\n *   remote: 'origin',\n *   ref: 'main',\n *   onAuth: () => ({ username: process.env.GITHUB_TOKEN }),\n * })\n * console.log(pushResult)\n *\n */\nasync function push({\n  fs,\n  http,\n  onProgress,\n  onMessage,\n  onAuth,\n  onAuthSuccess,\n  onAuthFailure,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  remoteRef,\n  remote = 'origin',\n  url,\n  force = false,\n  delete: _delete = false,\n  corsProxy,\n  headers = {},\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('http', http);\n    assertParameter('gitdir', gitdir);\n\n    return await _push({\n      fs: new FileSystem(fs),\n      cache,\n      http,\n      onProgress,\n      onMessage,\n      onAuth,\n      onAuthSuccess,\n      onAuthFailure,\n      gitdir,\n      ref,\n      remoteRef,\n      remote,\n      url,\n      force,\n      delete: _delete,\n      corsProxy,\n      headers,\n    })\n  } catch (err) {\n    err.caller = 'git.push';\n    throw err\n  }\n}\n\nasync function resolveBlob({ fs, cache, gitdir, oid }) {\n  const { type, object } = await _readObject({ fs, cache, gitdir, oid });\n  // Resolve annotated tag objects to whatever\n  if (type === 'tag') {\n    oid = GitAnnotatedTag.from(object).parse().object;\n    return resolveBlob({ fs, cache, gitdir, oid })\n  }\n  if (type !== 'blob') {\n    throw new ObjectTypeError(oid, type, 'blob')\n  }\n  return { oid, blob: new Uint8Array(object) }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} ReadBlobResult - The object returned has the following schema:\n * @property {string} oid\n * @property {Uint8Array} blob\n *\n */\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} args.oid\n * @param {string} [args.filepath]\n *\n * @returns {Promise<ReadBlobResult>} Resolves successfully with a blob object description\n * @see ReadBlobResult\n */\nasync function _readBlob({\n  fs,\n  cache,\n  gitdir,\n  oid,\n  filepath = undefined,\n}) {\n  if (filepath !== undefined) {\n    oid = await resolveFilepath({ fs, cache, gitdir, oid, filepath });\n  }\n  const blob = await resolveBlob({\n    fs,\n    cache,\n    gitdir,\n    oid,\n  });\n  return blob\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} ReadBlobResult - The object returned has the following schema:\n * @property {string} oid\n * @property {Uint8Array} blob\n *\n */\n\n/**\n * Read a blob object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.oid - The SHA-1 object id to get. Annotated tags, commits, and trees are peeled.\n * @param {string} [args.filepath] - Don't return the object with `oid` itself, but resolve `oid` to a tree and then return the blob object at that filepath.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<ReadBlobResult>} Resolves successfully with a blob object description\n * @see ReadBlobResult\n *\n * @example\n * // Get the contents of 'README.md' in the main branch.\n * let commitOid = await git.resolveRef({ fs, dir: '/tutorial', ref: 'main' })\n * console.log(commitOid)\n * let { blob } = await git.readBlob({\n *   fs,\n *   dir: '/tutorial',\n *   oid: commitOid,\n *   filepath: 'README.md'\n * })\n * console.log(Buffer.from(blob).toString('utf8'))\n *\n */\nasync function readBlob({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oid,\n  filepath,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n\n    return await _readBlob({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      oid,\n      filepath,\n    })\n  } catch (err) {\n    err.caller = 'git.readBlob';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Read a commit object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.oid - The SHA-1 object id to get. Annotated tags are peeled.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<ReadCommitResult>} Resolves successfully with a git commit object\n * @see ReadCommitResult\n * @see CommitObject\n *\n * @example\n * // Read a commit object\n * let sha = await git.resolveRef({ fs, dir: '/tutorial', ref: 'main' })\n * console.log(sha)\n * let commit = await git.readCommit({ fs, dir: '/tutorial', oid: sha })\n * console.log(commit)\n *\n */\nasync function readCommit({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oid,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n\n    return await _readCommit({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      oid,\n    })\n  } catch (err) {\n    err.caller = 'git.readCommit';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Read the contents of a note\n *\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} [args.ref] - The notes ref to look under\n * @param {string} args.oid\n *\n * @returns {Promise<Uint8Array>} Resolves successfully with note contents as a Buffer.\n */\n\nasync function _readNote({\n  fs,\n  cache,\n  gitdir,\n  ref = 'refs/notes/commits',\n  oid,\n}) {\n  const parent = await GitRefManager.resolve({ gitdir, fs, ref });\n  const { blob } = await _readBlob({\n    fs,\n    cache,\n    gitdir,\n    oid: parent,\n    filepath: oid,\n  });\n\n  return blob\n}\n\n// @ts-check\n\n/**\n * Read the contents of a note\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - The notes ref to look under\n * @param {string} args.oid - The SHA-1 object id of the object to get the note for.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<Uint8Array>} Resolves successfully with note contents as a Buffer.\n */\n\nasync function readNote({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref = 'refs/notes/commits',\n  oid,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    assertParameter('oid', oid);\n\n    return await _readNote({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      ref,\n      oid,\n    })\n  } catch (err) {\n    err.caller = 'git.readNote';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} DeflatedObject\n * @property {string} oid\n * @property {'deflated'} type\n * @property {'deflated'} format\n * @property {Uint8Array} object\n * @property {string} [source]\n *\n */\n\n/**\n *\n * @typedef {Object} WrappedObject\n * @property {string} oid\n * @property {'wrapped'} type\n * @property {'wrapped'} format\n * @property {Uint8Array} object\n * @property {string} [source]\n *\n */\n\n/**\n *\n * @typedef {Object} RawObject\n * @property {string} oid\n * @property {'blob'|'commit'|'tree'|'tag'} type\n * @property {'content'} format\n * @property {Uint8Array} object\n * @property {string} [source]\n *\n */\n\n/**\n *\n * @typedef {Object} ParsedBlobObject\n * @property {string} oid\n * @property {'blob'} type\n * @property {'parsed'} format\n * @property {string} object\n * @property {string} [source]\n *\n */\n\n/**\n *\n * @typedef {Object} ParsedCommitObject\n * @property {string} oid\n * @property {'commit'} type\n * @property {'parsed'} format\n * @property {CommitObject} object\n * @property {string} [source]\n *\n */\n\n/**\n *\n * @typedef {Object} ParsedTreeObject\n * @property {string} oid\n * @property {'tree'} type\n * @property {'parsed'} format\n * @property {TreeObject} object\n * @property {string} [source]\n *\n */\n\n/**\n *\n * @typedef {Object} ParsedTagObject\n * @property {string} oid\n * @property {'tag'} type\n * @property {'parsed'} format\n * @property {TagObject} object\n * @property {string} [source]\n *\n */\n\n/**\n *\n * @typedef {ParsedBlobObject | ParsedCommitObject | ParsedTreeObject | ParsedTagObject} ParsedObject\n */\n\n/**\n *\n * @typedef {DeflatedObject | WrappedObject | RawObject | ParsedObject } ReadObjectResult\n */\n\n/**\n * Read a git object directly by its SHA-1 object id\n *\n * Regarding `ReadObjectResult`:\n *\n * - `oid` will be the same as the `oid` argument unless the `filepath` argument is provided, in which case it will be the oid of the tree or blob being returned.\n * - `type` of deflated objects is `'deflated'`, and `type` of wrapped objects is `'wrapped'`\n * - `format` is usually, but not always, the format you requested. Packfiles do not store each object individually compressed so if you end up reading the object from a packfile it will be returned in format 'content' even if you requested 'deflated' or 'wrapped'.\n * - `object` will be an actual Object if format is 'parsed' and the object is a commit, tree, or annotated tag. Blobs are still formatted as Buffers unless an encoding is provided in which case they'll be strings. If format is anything other than 'parsed', object will be a Buffer.\n * - `source` is the name of the packfile or loose object file where the object was found.\n *\n * The `format` parameter can have the following values:\n *\n * | param      | description                                                                                                                                                                                               |\n * | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n * | 'deflated' | Return the raw deflate-compressed buffer for an object if possible. Useful for efficiently shuffling around loose objects when you don't care about the contents and can save time by not inflating them. |\n * | 'wrapped'  | Return the inflated object buffer wrapped in the git object header if possible. This is the raw data used when calculating the SHA-1 object id of a git object.                                           |\n * | 'content'  | Return the object buffer without the git header.                                                                                                                                                          |\n * | 'parsed'   | Returns a parsed representation of the object.                                                                                                                                                            |\n *\n * The result will be in one of the following schemas:\n *\n * ## `'deflated'` format\n *\n * {@link DeflatedObject typedef}\n *\n * ## `'wrapped'` format\n *\n * {@link WrappedObject typedef}\n *\n * ## `'content'` format\n *\n * {@link RawObject typedef}\n *\n * ## `'parsed'` format\n *\n * ### parsed `'blob'` type\n *\n * {@link ParsedBlobObject typedef}\n *\n * ### parsed `'commit'` type\n *\n * {@link ParsedCommitObject typedef}\n * {@link CommitObject typedef}\n *\n * ### parsed `'tree'` type\n *\n * {@link ParsedTreeObject typedef}\n * {@link TreeObject typedef}\n * {@link TreeEntry typedef}\n *\n * ### parsed `'tag'` type\n *\n * {@link ParsedTagObject typedef}\n * {@link TagObject typedef}\n *\n * @deprecated\n * > This command is overly complicated.\n * >\n * > If you know the type of object you are reading, use [`readBlob`](./readBlob.md), [`readCommit`](./readCommit.md), [`readTag`](./readTag.md), or [`readTree`](./readTree.md).\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.oid - The SHA-1 object id to get\n * @param {'deflated' | 'wrapped' | 'content' | 'parsed'} [args.format = 'parsed'] - What format to return the object in. The choices are described in more detail below.\n * @param {string} [args.filepath] - Don't return the object with `oid` itself, but resolve `oid` to a tree and then return the object at that filepath. To return the root directory of a tree set filepath to `''`\n * @param {string} [args.encoding] - A convenience argument that only affects blobs. Instead of returning `object` as a buffer, it returns a string parsed using the given encoding.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<ReadObjectResult>} Resolves successfully with a git object description\n * @see ReadObjectResult\n *\n * @example\n * // Given a ransom SHA-1 object id, figure out what it is\n * let { type, object } = await git.readObject({\n *   fs,\n *   dir: '/tutorial',\n *   oid: '0698a781a02264a6f37ba3ff41d78067eaf0f075'\n * })\n * switch (type) {\n *   case 'commit': {\n *     console.log(object)\n *     break\n *   }\n *   case 'tree': {\n *     console.log(object)\n *     break\n *   }\n *   case 'blob': {\n *     console.log(object)\n *     break\n *   }\n *   case 'tag': {\n *     console.log(object)\n *     break\n *   }\n * }\n *\n */\nasync function readObject({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oid,\n  format = 'parsed',\n  filepath = undefined,\n  encoding = undefined,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n\n    const fs = new FileSystem(_fs);\n    if (filepath !== undefined) {\n      oid = await resolveFilepath({\n        fs,\n        cache,\n        gitdir,\n        oid,\n        filepath,\n      });\n    }\n    // GitObjectManager does not know how to parse content, so we tweak that parameter before passing it.\n    const _format = format === 'parsed' ? 'content' : format;\n    const result = await _readObject({\n      fs,\n      cache,\n      gitdir,\n      oid,\n      format: _format,\n    });\n    result.oid = oid;\n    if (format === 'parsed') {\n      result.format = 'parsed';\n      switch (result.type) {\n        case 'commit':\n          result.object = GitCommit.from(result.object).parse();\n          break\n        case 'tree':\n          result.object = GitTree.from(result.object).entries();\n          break\n        case 'blob':\n          // Here we consider returning a raw Buffer as the 'content' format\n          // and returning a string as the 'parsed' format\n          if (encoding) {\n            result.object = result.object.toString(encoding);\n          } else {\n            result.object = new Uint8Array(result.object);\n            result.format = 'content';\n          }\n          break\n        case 'tag':\n          result.object = GitAnnotatedTag.from(result.object).parse();\n          break\n        default:\n          throw new ObjectTypeError(\n            result.oid,\n            result.type,\n            'blob|commit|tag|tree'\n          )\n      }\n    } else if (result.format === 'deflated' || result.format === 'wrapped') {\n      result.type = result.format;\n    }\n    return result\n  } catch (err) {\n    err.caller = 'git.readObject';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} ReadTagResult - The object returned has the following schema:\n * @property {string} oid - SHA-1 object id of this tag\n * @property {TagObject} tag - the parsed tag object\n * @property {string} payload - PGP signing payload\n */\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {any} args.cache\n * @param {string} args.gitdir\n * @param {string} args.oid\n *\n * @returns {Promise<ReadTagResult>}\n */\nasync function _readTag({ fs, cache, gitdir, oid }) {\n  const { type, object } = await _readObject({\n    fs,\n    cache,\n    gitdir,\n    oid,\n    format: 'content',\n  });\n  if (type !== 'tag') {\n    throw new ObjectTypeError(oid, type, 'tag')\n  }\n  const tag = GitAnnotatedTag.from(object);\n  const result = {\n    oid,\n    tag: tag.parse(),\n    payload: tag.payload(),\n  };\n  // @ts-ignore\n  return result\n}\n\n/**\n *\n * @typedef {Object} ReadTagResult - The object returned has the following schema:\n * @property {string} oid - SHA-1 object id of this tag\n * @property {TagObject} tag - the parsed tag object\n * @property {string} payload - PGP signing payload\n */\n\n/**\n * Read an annotated tag object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.oid - The SHA-1 object id to get\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<ReadTagResult>} Resolves successfully with a git object description\n * @see ReadTagResult\n * @see TagObject\n *\n */\nasync function readTag({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oid,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n\n    return await _readTag({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      oid,\n    })\n  } catch (err) {\n    err.caller = 'git.readTag';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n *\n * @typedef {Object} ReadTreeResult - The object returned has the following schema:\n * @property {string} oid - SHA-1 object id of this tree\n * @property {TreeObject} tree - the parsed tree object\n */\n\n/**\n * Read a tree object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.oid - The SHA-1 object id to get. Annotated tags and commits are peeled.\n * @param {string} [args.filepath] - Don't return the object with `oid` itself, but resolve `oid` to a tree and then return the tree object at that filepath.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<ReadTreeResult>} Resolves successfully with a git tree object\n * @see ReadTreeResult\n * @see TreeObject\n * @see TreeEntry\n *\n */\nasync function readTree({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  oid,\n  filepath = undefined,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n\n    return await _readTree({\n      fs: new FileSystem(fs),\n      cache,\n      gitdir,\n      oid,\n      filepath,\n    })\n  } catch (err) {\n    err.caller = 'git.readTree';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Remove a file from the git index (aka staging area)\n *\n * Note that this does NOT delete the file in the working directory.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.filepath - The path to the file to remove from the index\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully once the git index has been updated\n *\n * @example\n * await git.remove({ fs, dir: '/tutorial', filepath: 'README.md' })\n * console.log('done')\n *\n */\nasync function remove({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('filepath', filepath);\n\n    await GitIndexManager.acquire(\n      { fs: new FileSystem(_fs), gitdir, cache },\n      async function(index) {\n        index.delete({ filepath });\n      }\n    );\n  } catch (err) {\n    err.caller = 'git.remove';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {object} args.cache\n * @param {SignCallback} [args.onSign]\n * @param {string} [args.dir]\n * @param {string} [args.gitdir=join(dir,'.git')]\n * @param {string} [args.ref]\n * @param {string} args.oid\n * @param {Object} args.author\n * @param {string} args.author.name\n * @param {string} args.author.email\n * @param {number} args.author.timestamp\n * @param {number} args.author.timezoneOffset\n * @param {Object} args.committer\n * @param {string} args.committer.name\n * @param {string} args.committer.email\n * @param {number} args.committer.timestamp\n * @param {number} args.committer.timezoneOffset\n * @param {string} [args.signingKey]\n *\n * @returns {Promise<string>}\n */\n\nasync function _removeNote({\n  fs,\n  cache,\n  onSign,\n  gitdir,\n  ref = 'refs/notes/commits',\n  oid,\n  author,\n  committer,\n  signingKey,\n}) {\n  // Get the current note commit\n  let parent;\n  try {\n    parent = await GitRefManager.resolve({ gitdir, fs, ref });\n  } catch (err) {\n    if (!(err instanceof NotFoundError)) {\n      throw err\n    }\n  }\n\n  // I'm using the \"empty tree\" magic number here for brevity\n  const result = await _readTree({\n    fs,\n    gitdir,\n    oid: parent || '4b825dc642cb6eb9a060e54bf8d69288fbee4904',\n  });\n  let tree = result.tree;\n\n  // Remove the note blob entry from the tree\n  tree = tree.filter(entry => entry.path !== oid);\n\n  // Create the new note tree\n  const treeOid = await _writeTree({\n    fs,\n    gitdir,\n    tree,\n  });\n\n  // Create the new note commit\n  const commitOid = await _commit({\n    fs,\n    cache,\n    onSign,\n    gitdir,\n    ref,\n    tree: treeOid,\n    parent: parent && [parent],\n    message: `Note removed by 'isomorphic-git removeNote'\\n`,\n    author,\n    committer,\n    signingKey,\n  });\n\n  return commitOid\n}\n\n// @ts-check\n\n/**\n * Remove an object note\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {SignCallback} [args.onSign] - a PGP signing implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref] - The notes ref to look under\n * @param {string} args.oid - The SHA-1 object id of the object to remove the note from.\n * @param {Object} [args.author] - The details about the author.\n * @param {string} [args.author.name] - Default is `user.name` config.\n * @param {string} [args.author.email] - Default is `user.email` config.\n * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {Object} [args.committer = author] - The details about the note committer, in the same format as the author parameter. If not specified, the author details are used.\n * @param {string} [args.committer.name] - Default is `user.name` config.\n * @param {string} [args.committer.email] - Default is `user.email` config.\n * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).\n * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.\n * @param {string} [args.signingKey] - Sign the tag object using this private PGP key.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the commit object for the note removal.\n */\n\nasync function removeNote({\n  fs: _fs,\n  onSign,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref = 'refs/notes/commits',\n  oid,\n  author: _author,\n  committer: _committer,\n  signingKey,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('oid', oid);\n\n    const fs = new FileSystem(_fs);\n\n    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });\n    if (!author) throw new MissingNameError('author')\n\n    const committer = await normalizeCommitterObject({\n      fs,\n      gitdir,\n      author,\n      committer: _committer,\n    });\n    if (!committer) throw new MissingNameError('committer')\n\n    return await _removeNote({\n      fs,\n      cache,\n      onSign,\n      gitdir,\n      ref,\n      oid,\n      author,\n      committer,\n      signingKey,\n    })\n  } catch (err) {\n    err.caller = 'git.removeNote';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Rename a branch\n *\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {string} args.ref - The name of the new branch\n * @param {string} args.oldref - The name of the old branch\n * @param {boolean} [args.checkout = false]\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n */\nasync function _renameBranch({\n  fs,\n  gitdir,\n  oldref,\n  ref,\n  checkout = false,\n}) {\n  if (ref !== cleanGitRef.clean(ref)) {\n    throw new InvalidRefNameError(ref, cleanGitRef.clean(ref))\n  }\n\n  if (oldref !== cleanGitRef.clean(oldref)) {\n    throw new InvalidRefNameError(oldref, cleanGitRef.clean(oldref))\n  }\n\n  const fulloldref = `refs/heads/${oldref}`;\n  const fullnewref = `refs/heads/${ref}`;\n\n  const newexist = await GitRefManager.exists({ fs, gitdir, ref: fullnewref });\n\n  if (newexist) {\n    throw new AlreadyExistsError('branch', ref, false)\n  }\n\n  const value = await GitRefManager.resolve({\n    fs,\n    gitdir,\n    ref: fulloldref,\n    depth: 1,\n  });\n\n  await GitRefManager.writeRef({ fs, gitdir, ref: fullnewref, value });\n  await GitRefManager.deleteRef({ fs, gitdir, ref: fulloldref });\n\n  const fullCurrentBranchRef = await _currentBranch({\n    fs,\n    gitdir,\n    fullname: true,\n  });\n  const isCurrentBranch = fullCurrentBranchRef === fulloldref;\n\n  if (checkout || isCurrentBranch) {\n    // Update HEAD\n    await GitRefManager.writeSymbolicRef({\n      fs,\n      gitdir,\n      ref: 'HEAD',\n      value: fullnewref,\n    });\n  }\n}\n\n// @ts-check\n\n/**\n * Rename a branch\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - What to name the branch\n * @param {string} args.oldref - What the name of the branch was\n * @param {boolean} [args.checkout = false] - Update `HEAD` to point at the newly created branch\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.renameBranch({ fs, dir: '/tutorial', ref: 'main', oldref: 'master' })\n * console.log('done')\n *\n */\nasync function renameBranch({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  oldref,\n  checkout = false,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    assertParameter('oldref', oldref);\n    return await _renameBranch({\n      fs: new FileSystem(fs),\n      gitdir,\n      ref,\n      oldref,\n      checkout,\n    })\n  } catch (err) {\n    err.caller = 'git.renameBranch';\n    throw err\n  }\n}\n\nasync function hashObject$1({ gitdir, type, object }) {\n  return shasum(GitObject.wrap({ type, object }))\n}\n\n// @ts-check\n\n/**\n * Reset a file in the git index (aka staging area)\n *\n * Note that this does NOT modify the file in the working directory.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.filepath - The path to the file to reset in the index\n * @param {string} [args.ref = 'HEAD'] - A ref to the commit to use\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<void>} Resolves successfully once the git index has been updated\n *\n * @example\n * await git.resetIndex({ fs, dir: '/tutorial', filepath: 'README.md' })\n * console.log('done')\n *\n */\nasync function resetIndex({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath,\n  ref,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('filepath', filepath);\n\n    const fs = new FileSystem(_fs);\n\n    let oid;\n    let workdirOid;\n\n    try {\n      // Resolve commit\n      oid = await GitRefManager.resolve({ fs, gitdir, ref: ref || 'HEAD' });\n    } catch (e) {\n      if (ref) {\n        // Only throw the error if a ref is explicitly provided\n        throw e\n      }\n    }\n\n    // Not having an oid at this point means `resetIndex()` was called without explicit `ref` on a new git\n    // repository. If that happens, we can skip resolving the file path.\n    if (oid) {\n      try {\n        // Resolve blob\n        oid = await resolveFilepath({\n          fs,\n          cache,\n          gitdir,\n          oid,\n          filepath,\n        });\n      } catch (e) {\n        // This means we're resetting the file to a \"deleted\" state\n        oid = null;\n      }\n    }\n\n    // For files that aren't in the workdir use zeros\n    let stats = {\n      ctime: new Date(0),\n      mtime: new Date(0),\n      dev: 0,\n      ino: 0,\n      mode: 0,\n      uid: 0,\n      gid: 0,\n      size: 0,\n    };\n    // If the file exists in the workdir...\n    const object = dir && (await fs.read(join(dir, filepath)));\n    if (object) {\n      // ... and has the same hash as the desired state...\n      workdirOid = await hashObject$1({\n        gitdir,\n        type: 'blob',\n        object,\n      });\n      if (oid === workdirOid) {\n        // ... use the workdir Stats object\n        stats = await fs.lstat(join(dir, filepath));\n      }\n    }\n    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {\n      index.delete({ filepath });\n      if (oid) {\n        index.insert({ filepath, stats, oid });\n      }\n    });\n  } catch (err) {\n    err.caller = 'git.reset';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Get the value of a symbolic ref or resolve a ref to its SHA-1 object id\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - The ref to resolve\n * @param {number} [args.depth = undefined] - How many symbolic references to follow before returning\n *\n * @returns {Promise<string>} Resolves successfully with a SHA-1 object id or the value of a symbolic ref\n *\n * @example\n * let currentCommit = await git.resolveRef({ fs, dir: '/tutorial', ref: 'HEAD' })\n * console.log(currentCommit)\n * let currentBranch = await git.resolveRef({ fs, dir: '/tutorial', ref: 'HEAD', depth: 2 })\n * console.log(currentBranch)\n *\n */\nasync function resolveRef({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  depth,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n\n    const oid = await GitRefManager.resolve({\n      fs: new FileSystem(fs),\n      gitdir,\n      ref,\n      depth,\n    });\n    return oid\n  } catch (err) {\n    err.caller = 'git.resolveRef';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Write an entry to the git config files.\n *\n * *Caveats:*\n * - Currently only the local `$GIT_DIR/config` file can be read or written. However support for the global `~/.gitconfig` and system `$(prefix)/etc/gitconfig` will be added in the future.\n * - The current parser does not support the more exotic features of the git-config file format such as `[include]` and `[includeIf]`.\n *\n * @param {Object} args\n * @param {FsClient} args.fs - a file system implementation\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.path - The key of the git config entry\n * @param {string | boolean | number | void} args.value - A value to store at that path. (Use `undefined` as the value to delete a config entry.)\n * @param {boolean} [args.append = false] - If true, will append rather than replace when setting (use with multi-valued config options).\n *\n * @returns {Promise<void>} Resolves successfully when operation completed\n *\n * @example\n * // Write config value\n * await git.setConfig({\n *   fs,\n *   dir: '/tutorial',\n *   path: 'user.name',\n *   value: 'Mr. Test'\n * })\n *\n * // Print out config file\n * let file = await fs.promises.readFile('/tutorial/.git/config', 'utf8')\n * console.log(file)\n *\n * // Delete a config entry\n * await git.setConfig({\n *   fs,\n *   dir: '/tutorial',\n *   path: 'user.name',\n *   value: undefined\n * })\n *\n * // Print out config file\n * file = await fs.promises.readFile('/tutorial/.git/config', 'utf8')\n * console.log(file)\n */\nasync function setConfig({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  path,\n  value,\n  append = false,\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('path', path);\n    // assertParameter('value', value) // We actually allow 'undefined' as a value to unset/delete\n\n    const fs = new FileSystem(_fs);\n    const config = await GitConfigManager.get({ fs, gitdir });\n    if (append) {\n      await config.append(path, value);\n    } else {\n      await config.set(path, value);\n    }\n    await GitConfigManager.save({ fs, gitdir, config });\n  } catch (err) {\n    err.caller = 'git.setConfig';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Tell whether a file has been changed\n *\n * The possible resolve values are:\n *\n * | status                | description                                                                           |\n * | --------------------- | ------------------------------------------------------------------------------------- |\n * | `\"ignored\"`           | file ignored by a .gitignore rule                                                     |\n * | `\"unmodified\"`        | file unchanged from HEAD commit                                                       |\n * | `\"*modified\"`         | file has modifications, not yet staged                                                |\n * | `\"*deleted\"`          | file has been removed, but the removal is not yet staged                              |\n * | `\"*added\"`            | file is untracked, not yet staged                                                     |\n * | `\"absent\"`            | file not present in HEAD commit, staging area, or working dir                         |\n * | `\"modified\"`          | file has modifications, staged                                                        |\n * | `\"deleted\"`           | file has been removed, staged                                                         |\n * | `\"added\"`             | previously untracked file, staged                                                     |\n * | `\"*unmodified\"`       | working dir and HEAD commit match, but index differs                                  |\n * | `\"*absent\"`           | file not present in working dir or HEAD commit, but present in the index              |\n * | `\"*undeleted\"`        | file was deleted from the index, but is still in the working dir                      |\n * | `\"*undeletemodified\"` | file was deleted from the index, but is present with modifications in the working dir |\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.filepath - The path to the file to query\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<'ignored'|'unmodified'|'*modified'|'*deleted'|'*added'|'absent'|'modified'|'deleted'|'added'|'*unmodified'|'*absent'|'*undeleted'|'*undeletemodified'>} Resolves successfully with the file's git status\n *\n * @example\n * let status = await git.status({ fs, dir: '/tutorial', filepath: 'README.md' })\n * console.log(status)\n *\n */\nasync function status({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  filepath,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('filepath', filepath);\n\n    const fs = new FileSystem(_fs);\n    const ignored = await GitIgnoreManager.isIgnored({\n      fs,\n      gitdir,\n      dir,\n      filepath,\n    });\n    if (ignored) {\n      return 'ignored'\n    }\n    const headTree = await getHeadTree({ fs, cache, gitdir });\n    const treeOid = await getOidAtPath({\n      fs,\n      cache,\n      gitdir,\n      tree: headTree,\n      path: filepath,\n    });\n    const indexEntry = await GitIndexManager.acquire(\n      { fs, gitdir, cache },\n      async function(index) {\n        for (const entry of index) {\n          if (entry.path === filepath) return entry\n        }\n        return null\n      }\n    );\n    const stats = await fs.lstat(join(dir, filepath));\n\n    const H = treeOid !== null; // head\n    const I = indexEntry !== null; // index\n    const W = stats !== null; // working dir\n\n    const getWorkdirOid = async () => {\n      if (I && !compareStats(indexEntry, stats)) {\n        return indexEntry.oid\n      } else {\n        const object = await fs.read(join(dir, filepath));\n        const workdirOid = await hashObject$1({\n          gitdir,\n          type: 'blob',\n          object,\n        });\n        // If the oid in the index === working dir oid but stats differed update cache\n        if (I && indexEntry.oid === workdirOid) {\n          // and as long as our fs.stats aren't bad.\n          // size of -1 happens over a BrowserFS HTTP Backend that doesn't serve Content-Length headers\n          // (like the Karma webserver) because BrowserFS HTTP Backend uses HTTP HEAD requests to do fs.stat\n          if (stats.size !== -1) {\n            // We don't await this so we can return faster for one-off cases.\n            GitIndexManager.acquire({ fs, gitdir, cache }, async function(\n              index\n            ) {\n              index.insert({ filepath, stats, oid: workdirOid });\n            });\n          }\n        }\n        return workdirOid\n      }\n    };\n\n    if (!H && !W && !I) return 'absent' // ---\n    if (!H && !W && I) return '*absent' // -A-\n    if (!H && W && !I) return '*added' // --A\n    if (!H && W && I) {\n      const workdirOid = await getWorkdirOid();\n      // @ts-ignore\n      return workdirOid === indexEntry.oid ? 'added' : '*added' // -AA : -AB\n    }\n    if (H && !W && !I) return 'deleted' // A--\n    if (H && !W && I) {\n      // @ts-ignore\n      return treeOid === indexEntry.oid ? '*deleted' : '*deleted' // AA- : AB-\n    }\n    if (H && W && !I) {\n      const workdirOid = await getWorkdirOid();\n      return workdirOid === treeOid ? '*undeleted' : '*undeletemodified' // A-A : A-B\n    }\n    if (H && W && I) {\n      const workdirOid = await getWorkdirOid();\n      if (workdirOid === treeOid) {\n        // @ts-ignore\n        return workdirOid === indexEntry.oid ? 'unmodified' : '*unmodified' // AAA : ABA\n      } else {\n        // @ts-ignore\n        return workdirOid === indexEntry.oid ? 'modified' : '*modified' // ABB : AAB\n      }\n    }\n    /*\n    ---\n    -A-\n    --A\n    -AA\n    -AB\n    A--\n    AA-\n    AB-\n    A-A\n    A-B\n    AAA\n    ABA\n    ABB\n    AAB\n    */\n  } catch (err) {\n    err.caller = 'git.status';\n    throw err\n  }\n}\n\nasync function getOidAtPath({ fs, cache, gitdir, tree, path }) {\n  if (typeof path === 'string') path = path.split('/');\n  const dirname = path.shift();\n  for (const entry of tree) {\n    if (entry.path === dirname) {\n      if (path.length === 0) {\n        return entry.oid\n      }\n      const { type, object } = await _readObject({\n        fs,\n        cache,\n        gitdir,\n        oid: entry.oid,\n      });\n      if (type === 'tree') {\n        const tree = GitTree.from(object);\n        return getOidAtPath({ fs, cache, gitdir, tree, path })\n      }\n      if (type === 'blob') {\n        throw new ObjectTypeError(entry.oid, type, 'blob', path.join('/'))\n      }\n    }\n  }\n  return null\n}\n\nasync function getHeadTree({ fs, cache, gitdir }) {\n  // Get the tree from the HEAD commit.\n  let oid;\n  try {\n    oid = await GitRefManager.resolve({ fs, gitdir, ref: 'HEAD' });\n  } catch (e) {\n    // Handle fresh branches with no commits\n    if (e instanceof NotFoundError) {\n      return []\n    }\n  }\n  const { tree } = await _readTree({ fs, cache, gitdir, oid });\n  return tree\n}\n\n// @ts-check\n\n/**\n * Efficiently get the status of multiple files at once.\n *\n * The returned `StatusMatrix` is admittedly not the easiest format to read.\n * However it conveys a large amount of information in dense format that should make it easy to create reports about the current state of the repository;\n * without having to do multiple, time-consuming isomorphic-git calls.\n * My hope is that the speed and flexibility of the function will make up for the learning curve of interpreting the return value.\n *\n * ```js live\n * // get the status of all the files in 'src'\n * let status = await git.statusMatrix({\n *   fs,\n *   dir: '/tutorial',\n *   filter: f => f.startsWith('src/')\n * })\n * console.log(status)\n * ```\n *\n * ```js live\n * // get the status of all the JSON and Markdown files\n * let status = await git.statusMatrix({\n *   fs,\n *   dir: '/tutorial',\n *   filter: f => f.endsWith('.json') || f.endsWith('.md')\n * })\n * console.log(status)\n * ```\n *\n * The result is returned as a 2D array.\n * The outer array represents the files and/or blobs in the repo, in alphabetical order.\n * The inner arrays describe the status of the file:\n * the first value is the filepath, and the next three are integers\n * representing the HEAD status, WORKDIR status, and STAGE status of the entry.\n *\n * ```js\n * // example StatusMatrix\n * [\n *   [\"a.txt\", 0, 2, 0], // new, untracked\n *   [\"b.txt\", 0, 2, 2], // added, staged\n *   [\"c.txt\", 0, 2, 3], // added, staged, with unstaged changes\n *   [\"d.txt\", 1, 1, 1], // unmodified\n *   [\"e.txt\", 1, 2, 1], // modified, unstaged\n *   [\"f.txt\", 1, 2, 2], // modified, staged\n *   [\"g.txt\", 1, 2, 3], // modified, staged, with unstaged changes\n *   [\"h.txt\", 1, 0, 1], // deleted, unstaged\n *   [\"i.txt\", 1, 0, 0], // deleted, staged\n * ]\n * ```\n *\n * - The HEAD status is either absent (0) or present (1).\n * - The WORKDIR status is either absent (0), identical to HEAD (1), or different from HEAD (2).\n * - The STAGE status is either absent (0), identical to HEAD (1), identical to WORKDIR (2), or different from WORKDIR (3).\n *\n * ```ts\n * type Filename      = string\n * type HeadStatus    = 0 | 1\n * type WorkdirStatus = 0 | 1 | 2\n * type StageStatus   = 0 | 1 | 2 | 3\n *\n * type StatusRow     = [Filename, HeadStatus, WorkdirStatus, StageStatus]\n *\n * type StatusMatrix  = StatusRow[]\n * ```\n *\n * > Think of the natural progression of file modifications as being from HEAD (previous) -> WORKDIR (current) -> STAGE (next).\n * > Then HEAD is \"version 1\", WORKDIR is \"version 2\", and STAGE is \"version 3\".\n * > Then, imagine a \"version 0\" which is before the file was created.\n * > Then the status value in each column corresponds to the oldest version of the file it is identical to.\n * > (For a file to be identical to \"version 0\" means the file is deleted.)\n *\n * Here are some examples of queries you can answer using the result:\n *\n * #### Q: What files have been deleted?\n * ```js\n * const FILE = 0, WORKDIR = 2\n *\n * const filenames = (await statusMatrix({ dir }))\n *   .filter(row => row[WORKDIR] === 0)\n *   .map(row => row[FILE])\n * ```\n *\n * #### Q: What files have unstaged changes?\n * ```js\n * const FILE = 0, WORKDIR = 2, STAGE = 3\n *\n * const filenames = (await statusMatrix({ dir }))\n *   .filter(row => row[WORKDIR] !== row[STAGE])\n *   .map(row => row[FILE])\n * ```\n *\n * #### Q: What files have been modified since the last commit?\n * ```js\n * const FILE = 0, HEAD = 1, WORKDIR = 2\n *\n * const filenames = (await statusMatrix({ dir }))\n *   .filter(row => row[HEAD] !== row[WORKDIR])\n *   .map(row => row[FILE])\n * ```\n *\n * #### Q: What files will NOT be changed if I commit right now?\n * ```js\n * const FILE = 0, HEAD = 1, STAGE = 3\n *\n * const filenames = (await statusMatrix({ dir }))\n *   .filter(row => row[HEAD] === row[STAGE])\n *   .map(row => row[FILE])\n * ```\n *\n * For reference, here are all possible combinations:\n *\n * | HEAD | WORKDIR | STAGE | `git status --short` equivalent |\n * | ---- | ------- | ----- | ------------------------------- |\n * | 0    | 0       | 0     | ``                              |\n * | 0    | 0       | 3     | `AD`                            |\n * | 0    | 2       | 0     | `??`                            |\n * | 0    | 2       | 2     | `A `                            |\n * | 0    | 2       | 3     | `AM`                            |\n * | 1    | 0       | 0     | `D `                            |\n * | 1    | 0       | 1     | ` D`                            |\n * | 1    | 0       | 3     | `MD`                            |\n * | 1    | 1       | 0     | `D ` + `??`                     |\n * | 1    | 1       | 1     | ``                              |\n * | 1    | 1       | 3     | `MM`                            |\n * | 1    | 2       | 0     | `D ` + `??`                     |\n * | 1    | 2       | 1     | ` M`                            |\n * | 1    | 2       | 2     | `M `                            |\n * | 1    | 2       | 3     | `MM`                            |\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} [args.ref = 'HEAD'] - Optionally specify a different commit to compare against the workdir and stage instead of the HEAD\n * @param {string[]} [args.filepaths = ['.']] - Limit the query to the given files and directories\n * @param {function(string): boolean} [args.filter] - Filter the results to only those whose filepath matches a function.\n * @param {object} [args.cache] - a [cache](cache.md) object\n * @param {boolean} [args.ignored = false] - include ignored files in the result\n *\n * @returns {Promise<Array<StatusRow>>} Resolves with a status matrix, described below.\n * @see StatusRow\n */\nasync function statusMatrix({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref = 'HEAD',\n  filepaths = ['.'],\n  filter,\n  cache = {},\n  ignored: shouldIgnore = false,\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n\n    const fs = new FileSystem(_fs);\n    return await _walk({\n      fs,\n      cache,\n      dir,\n      gitdir,\n      trees: [TREE({ ref }), WORKDIR(), STAGE()],\n      map: async function(filepath, [head, workdir, stage]) {\n        // Ignore ignored files, but only if they are not already tracked.\n        if (!head && !stage && workdir) {\n          if (!shouldIgnore) {\n            const isIgnored = await GitIgnoreManager.isIgnored({\n              fs,\n              dir,\n              filepath,\n            });\n            if (isIgnored) {\n              return null\n            }\n          }\n        }\n        // match against base paths\n        if (!filepaths.some(base => worthWalking(filepath, base))) {\n          return null\n        }\n        // Late filter against file names\n        if (filter) {\n          if (!filter(filepath)) return\n        }\n\n        const [headType, workdirType, stageType] = await Promise.all([\n          head && head.type(),\n          workdir && workdir.type(),\n          stage && stage.type(),\n        ]);\n\n        const isBlob = [headType, workdirType, stageType].includes('blob');\n\n        // For now, bail on directories unless the file is also a blob in another tree\n        if ((headType === 'tree' || headType === 'special') && !isBlob) return\n        if (headType === 'commit') return null\n\n        if ((workdirType === 'tree' || workdirType === 'special') && !isBlob)\n          return\n\n        if (stageType === 'commit') return null\n        if ((stageType === 'tree' || stageType === 'special') && !isBlob) return\n\n        // Figure out the oids for files, using the staged oid for the working dir oid if the stats match.\n        const headOid = headType === 'blob' ? await head.oid() : undefined;\n        const stageOid = stageType === 'blob' ? await stage.oid() : undefined;\n        let workdirOid;\n        if (\n          headType !== 'blob' &&\n          workdirType === 'blob' &&\n          stageType !== 'blob'\n        ) {\n          // We don't actually NEED the sha. Any sha will do\n          // TODO: update this logic to handle N trees instead of just 3.\n          workdirOid = '42';\n        } else if (workdirType === 'blob') {\n          workdirOid = await workdir.oid();\n        }\n        const entry = [undefined, headOid, workdirOid, stageOid];\n        const result = entry.map(value => entry.indexOf(value));\n        result.shift(); // remove leading undefined entry\n        return [filepath, ...result]\n      },\n    })\n  } catch (err) {\n    err.caller = 'git.statusMatrix';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Create a lightweight tag\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - What to name the tag\n * @param {string} [args.object = 'HEAD'] - What oid the tag refers to. (Will resolve to oid if value is a ref.) By default, the commit object which is referred by the current `HEAD` is used.\n * @param {boolean} [args.force = false] - Instead of throwing an error if a tag named `ref` already exists, overwrite the existing tag.\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.tag({ fs, dir: '/tutorial', ref: 'test-tag' })\n * console.log('done')\n *\n */\nasync function tag({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  object,\n  force = false,\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n\n    const fs = new FileSystem(_fs);\n\n    if (ref === undefined) {\n      throw new MissingParameterError('ref')\n    }\n\n    ref = ref.startsWith('refs/tags/') ? ref : `refs/tags/${ref}`;\n\n    // Resolve passed object\n    const value = await GitRefManager.resolve({\n      fs,\n      gitdir,\n      ref: object || 'HEAD',\n    });\n\n    if (!force && (await GitRefManager.exists({ fs, gitdir, ref }))) {\n      throw new AlreadyExistsError('tag', ref)\n    }\n\n    await GitRefManager.writeRef({ fs, gitdir, ref, value });\n  } catch (err) {\n    err.caller = 'git.tag';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Register file contents in the working tree or object database to the git index (aka staging area).\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.filepath - File to act upon.\n * @param {string} [args.oid] - OID of the object in the object database to add to the index with the specified filepath.\n * @param {number} [args.mode = 100644] - The file mode to add the file to the index.\n * @param {boolean} [args.add] - Adds the specified file to the index if it does not yet exist in the index.\n * @param {boolean} [args.remove] - Remove the specified file from the index if it does not exist in the workspace anymore.\n * @param {boolean} [args.force] - Remove the specified file from the index, even if it still exists in the workspace.\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<string | void>} Resolves successfully with the SHA-1 object id of the object written or updated in the index, or nothing if the file was removed.\n *\n * @example\n * await git.updateIndex({\n *   fs,\n *   dir: '/tutorial',\n *   filepath: 'readme.md'\n * })\n *\n * @example\n * // Manually create a blob in the object database.\n * let oid = await git.writeBlob({\n *   fs,\n *   dir: '/tutorial',\n *   blob: new Uint8Array([])\n * })\n *\n * // Write the object in the object database to the index.\n * await git.updateIndex({\n *   fs,\n *   dir: '/tutorial',\n *   add: true,\n *   filepath: 'readme.md',\n *   oid\n * })\n */\nasync function updateIndex({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  cache = {},\n  filepath,\n  oid,\n  mode,\n  add,\n  remove,\n  force,\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('filepath', filepath);\n\n    const fs = new FileSystem(_fs);\n\n    if (remove) {\n      return await GitIndexManager.acquire(\n        { fs, gitdir, cache },\n        async function(index) {\n          let fileStats;\n\n          if (!force) {\n            // Check if the file is still present in the working directory\n            fileStats = await fs.lstat(join(dir, filepath));\n\n            if (fileStats) {\n              if (fileStats.isDirectory()) {\n                // Removing directories should not work\n                throw new InvalidFilepathError('directory')\n              }\n\n              // Do nothing if we don't force and the file still exists in the workdir\n              return\n            }\n          }\n\n          // Directories are not allowed, so we make sure the provided filepath exists in the index\n          if (index.has({ filepath })) {\n            index.delete({\n              filepath,\n            });\n          }\n        }\n      )\n    }\n\n    // Test if it is a file and exists on disk if `remove` is not provided, only of no oid is provided\n    let fileStats;\n\n    if (!oid) {\n      fileStats = await fs.lstat(join(dir, filepath));\n\n      if (!fileStats) {\n        throw new NotFoundError(\n          `file at \"${filepath}\" on disk and \"remove\" not set`\n        )\n      }\n\n      if (fileStats.isDirectory()) {\n        throw new InvalidFilepathError('directory')\n      }\n    }\n\n    return await GitIndexManager.acquire({ fs, gitdir, cache }, async function(\n      index\n    ) {\n      if (!add && !index.has({ filepath })) {\n        // If the index does not contain the filepath yet and `add` is not set, we should throw\n        throw new NotFoundError(\n          `file at \"${filepath}\" in index and \"add\" not set`\n        )\n      }\n\n      // By default we use 0 for the stats of the index file\n      let stats = {\n        ctime: new Date(0),\n        mtime: new Date(0),\n        dev: 0,\n        ino: 0,\n        mode,\n        uid: 0,\n        gid: 0,\n        size: 0,\n      };\n\n      if (!oid) {\n        stats = fileStats;\n\n        // Write the file to the object database\n        const object = stats.isSymbolicLink()\n          ? await fs.readlink(join(dir, filepath))\n          : await fs.read(join(dir, filepath));\n\n        oid = await _writeObject({\n          fs,\n          gitdir,\n          type: 'blob',\n          format: 'content',\n          object,\n        });\n      }\n\n      index.insert({\n        filepath,\n        oid: oid,\n        stats,\n      });\n\n      return oid\n    })\n  } catch (err) {\n    err.caller = 'git.updateIndex';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Return the version number of isomorphic-git\n *\n * I don't know why you might need this. I added it just so I could check that I was getting\n * the correct version of the library and not a cached version.\n *\n * @returns {string} the version string taken from package.json at publication time\n *\n * @example\n * console.log(git.version())\n *\n */\nfunction version() {\n  try {\n    return pkg.version\n  } catch (err) {\n    err.caller = 'git.version';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @callback WalkerMap\n * @param {string} filename\n * @param {Array<WalkerEntry | null>} entries\n * @returns {Promise<any>}\n */\n\n/**\n * @callback WalkerReduce\n * @param {any} parent\n * @param {any[]} children\n * @returns {Promise<any>}\n */\n\n/**\n * @callback WalkerIterateCallback\n * @param {WalkerEntry[]} entries\n * @returns {Promise<any[]>}\n */\n\n/**\n * @callback WalkerIterate\n * @param {WalkerIterateCallback} walk\n * @param {IterableIterator<WalkerEntry[]>} children\n * @returns {Promise<any[]>}\n */\n\n/**\n * A powerful recursive tree-walking utility.\n *\n * The `walk` API simplifies gathering detailed information about a tree or comparing all the filepaths in two or more trees.\n * Trees can be git commits, the working directory, or the or git index (staging area).\n * As long as a file or directory is present in at least one of the trees, it will be traversed.\n * Entries are traversed in alphabetical order.\n *\n * The arguments to `walk` are the `trees` you want to traverse, and 3 optional transform functions:\n *  `map`, `reduce`, and `iterate`.\n *\n * ## `TREE`, `WORKDIR`, and `STAGE`\n *\n * Tree walkers are represented by three separate functions that can be imported:\n *\n * ```js\n * import { TREE, WORKDIR, STAGE } from 'isomorphic-git'\n * ```\n *\n * These functions return opaque handles called `Walker`s.\n * The only thing that `Walker` objects are good for is passing into `walk`.\n * Here are the three `Walker`s passed into `walk` by the `statusMatrix` command for example:\n *\n * ```js\n * let ref = 'HEAD'\n *\n * let trees = [TREE({ ref }), WORKDIR(), STAGE()]\n * ```\n *\n * For the arguments, see the doc pages for [TREE](./TREE.md), [WORKDIR](./WORKDIR.md), and [STAGE](./STAGE.md).\n *\n * `map`, `reduce`, and `iterate` allow you control the recursive walk by pruning and transforming `WalkerEntry`s into the desired result.\n *\n * ## WalkerEntry\n *\n * {@link WalkerEntry typedef}\n *\n * `map` receives an array of `WalkerEntry[]` as its main argument, one `WalkerEntry` for each `Walker` in the `trees` argument.\n * The methods are memoized per `WalkerEntry` so calling them multiple times in a `map` function does not adversely impact performance.\n * By only computing these values if needed, you build can build lean, mean, efficient walking machines.\n *\n * ### WalkerEntry#type()\n *\n * Returns the kind as a string. This is normally either `tree` or `blob`.\n *\n * `TREE`, `STAGE`, and `WORKDIR` walkers all return a string.\n *\n * Possible values:\n *\n * - `'tree'` directory\n * - `'blob'` file\n * - `'special'` used by `WORKDIR` to represent irregular files like sockets and FIFOs\n * - `'commit'` used by `TREE` to represent submodules\n *\n * ```js\n * await entry.type()\n * ```\n *\n * ### WalkerEntry#mode()\n *\n * Returns the file mode as a number. Use this to distinguish between regular files, symlinks, and executable files.\n *\n * `TREE`, `STAGE`, and `WORKDIR` walkers all return a number for all `type`s of entries.\n *\n * It has been normalized to one of the 4 values that are allowed in git commits:\n *\n * - `0o40000` directory\n * - `0o100644` file\n * - `0o100755` file (executable)\n * - `0o120000` symlink\n *\n * Tip: to make modes more readable, you can print them to octal using `.toString(8)`.\n *\n * ```js\n * await entry.mode()\n * ```\n *\n * ### WalkerEntry#oid()\n *\n * Returns the SHA-1 object id for blobs and trees.\n *\n * `TREE` walkers return a string for `blob` and `tree` entries.\n *\n * `STAGE` and `WORKDIR` walkers return a string for `blob` entries and `undefined` for `tree` entries.\n *\n * ```js\n * await entry.oid()\n * ```\n *\n * ### WalkerEntry#content()\n *\n * Returns the file contents as a Buffer.\n *\n * `TREE` and `WORKDIR` walkers return a Buffer for `blob` entries and `undefined` for `tree` entries.\n *\n * `STAGE` walkers always return `undefined` since the file contents are never stored in the stage.\n *\n * ```js\n * await entry.content()\n * ```\n *\n * ### WalkerEntry#stat()\n *\n * Returns a normalized subset of filesystem Stat data.\n *\n * `WORKDIR` walkers return a `Stat` for `blob` and `tree` entries.\n *\n * `STAGE` walkers return a `Stat` for `blob` entries and `undefined` for `tree` entries.\n *\n * `TREE` walkers return `undefined` for all entry types.\n *\n * ```js\n * await entry.stat()\n * ```\n *\n * {@link Stat typedef}\n *\n * ## map(string, Array<WalkerEntry|null>) => Promise<any>\n *\n * {@link WalkerMap typedef}\n *\n * This is the function that is called once per entry BEFORE visiting the children of that node.\n *\n * If you return `null` for a `tree` entry, then none of the children of that `tree` entry will be walked.\n *\n * This is a good place for query logic, such as examining the contents of a file.\n * Ultimately, compare all the entries and return any values you are interested in.\n * If you do not return a value (or return undefined) that entry will be filtered from the results.\n *\n * Example 1: Find all the files containing the word 'foo'.\n * ```js\n * async function map(filepath, [head, workdir]) {\n *   let content = (await workdir.content()).toString('utf8')\n *   if (content.contains('foo')) {\n *     return {\n *       filepath,\n *       content\n *     }\n *   }\n * }\n * ```\n *\n * Example 2: Return the difference between the working directory and the HEAD commit\n * ```js\n * const map = async (filepath, [head, workdir]) => {\n *   return {\n *     filepath,\n *     oid: await head?.oid(),\n *     diff: diff(\n *       (await head?.content())?.toString('utf8') || '',\n *       (await workdir?.content())?.toString('utf8') || ''\n *     )\n *   }\n * }\n * ```\n *\n * Example 3:\n * ```js\n * let path = require('path')\n * // Only examine files in the directory `cwd`\n * let cwd = 'src/app'\n * async function map (filepath, [head, workdir, stage]) {\n *   if (\n *     // don't skip the root directory\n *     head.fullpath !== '.' &&\n *     // return true for 'src' and 'src/app'\n *     !cwd.startsWith(filepath) &&\n *     // return true for 'src/app/*'\n *     path.dirname(filepath) !== cwd\n *   ) {\n *     return null\n *   } else {\n *     return filepath\n *   }\n * }\n * ```\n *\n * ## reduce(parent, children)\n *\n * {@link WalkerReduce typedef}\n *\n * This is the function that is called once per entry AFTER visiting the children of that node.\n *\n * Default: `async (parent, children) => parent === undefined ? children.flat() : [parent, children].flat()`\n *\n * The default implementation of this function returns all directories and children in a giant flat array.\n * You can define a different accumulation method though.\n *\n * Example: Return a hierarchical structure\n * ```js\n * async function reduce (parent, children) {\n *   return Object.assign(parent, { children })\n * }\n * ```\n *\n * ## iterate(walk, children)\n *\n * {@link WalkerIterate typedef}\n *\n * {@link WalkerIterateCallback typedef}\n *\n * Default: `(walk, children) => Promise.all([...children].map(walk))`\n *\n * The default implementation recurses all children concurrently using Promise.all.\n * However you could use a custom function to traverse children serially or use a global queue to throttle recursion.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {Walker[]} args.trees - The trees you want to traverse\n * @param {WalkerMap} [args.map] - Transform `WalkerEntry`s into a result form\n * @param {WalkerReduce} [args.reduce] - Control how mapped entries are combined with their parent result\n * @param {WalkerIterate} [args.iterate] - Fine-tune how entries within a tree are iterated over\n * @param {object} [args.cache] - a [cache](cache.md) object\n *\n * @returns {Promise<any>} The finished tree-walking result\n */\nasync function walk({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  trees,\n  map,\n  reduce,\n  iterate,\n  cache = {},\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('trees', trees);\n\n    return await _walk({\n      fs: new FileSystem(fs),\n      cache,\n      dir,\n      gitdir,\n      trees,\n      map,\n      reduce,\n      iterate,\n    })\n  } catch (err) {\n    err.caller = 'git.walk';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Write a blob object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {Uint8Array} args.blob - The blob object to write\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object\n *\n * @example\n * // Manually create a blob.\n * let oid = await git.writeBlob({\n *   fs,\n *   dir: '/tutorial',\n *   blob: new Uint8Array([])\n * })\n *\n * console.log('oid', oid) // should be 'e69de29bb2d1d6434b8b29ae775ad8c2e48c5391'\n *\n */\nasync function writeBlob({ fs, dir, gitdir = join(dir, '.git'), blob }) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('blob', blob);\n\n    return await _writeObject({\n      fs: new FileSystem(fs),\n      gitdir,\n      type: 'blob',\n      object: blob,\n      format: 'content',\n    })\n  } catch (err) {\n    err.caller = 'git.writeBlob';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {CommitObject} args.commit\n *\n * @returns {Promise<string>}\n * @see CommitObject\n *\n */\nasync function _writeCommit({ fs, gitdir, commit }) {\n  // Convert object to buffer\n  const object = GitCommit.from(commit).toObject();\n  const oid = await _writeObject({\n    fs,\n    gitdir,\n    type: 'commit',\n    object,\n    format: 'content',\n  });\n  return oid\n}\n\n// @ts-check\n\n/**\n * Write a commit object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {CommitObject} args.commit - The object to write\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object\n * @see CommitObject\n *\n */\nasync function writeCommit({\n  fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  commit,\n}) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('commit', commit);\n\n    return await _writeCommit({\n      fs: new FileSystem(fs),\n      gitdir,\n      commit,\n    })\n  } catch (err) {\n    err.caller = 'git.writeCommit';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Write a git object directly\n *\n * `format` can have the following values:\n *\n * | param      | description                                                                                                                                                      |\n * | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n * | 'deflated' | Treat `object` as the raw deflate-compressed buffer for an object, meaning can be written to `.git/objects/**` as-is.                                           |\n * | 'wrapped'  | Treat `object` as the inflated object buffer wrapped in the git object header. This is the raw buffer used when calculating the SHA-1 object id of a git object. |\n * | 'content'  | Treat `object` as the object buffer without the git header.                                                                                                      |\n * | 'parsed'   | Treat `object` as a parsed representation of the object.                                                                                                         |\n *\n * If `format` is `'parsed'`, then `object` must match one of the schemas for `CommitObject`, `TreeObject`, `TagObject`, or a `string` (for blobs).\n *\n * {@link CommitObject typedef}\n *\n * {@link TreeObject typedef}\n *\n * {@link TagObject typedef}\n *\n * If `format` is `'content'`, `'wrapped'`, or `'deflated'`, `object` should be a `Uint8Array`.\n *\n * @deprecated\n * > This command is overly complicated.\n * >\n * > If you know the type of object you are writing, use [`writeBlob`](./writeBlob.md), [`writeCommit`](./writeCommit.md), [`writeTag`](./writeTag.md), or [`writeTree`](./writeTree.md).\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string | Uint8Array | CommitObject | TreeObject | TagObject} args.object - The object to write.\n * @param {'blob'|'tree'|'commit'|'tag'} [args.type] - The kind of object to write.\n * @param {'deflated' | 'wrapped' | 'content' | 'parsed'} [args.format = 'parsed'] - What format the object is in. The possible choices are listed below.\n * @param {string} [args.oid] - If `format` is `'deflated'` then this param is required. Otherwise it is calculated.\n * @param {string} [args.encoding] - If `type` is `'blob'` then `object` will be converted to a Uint8Array using `encoding`.\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object.\n *\n * @example\n * // Manually create an annotated tag.\n * let sha = await git.resolveRef({ fs, dir: '/tutorial', ref: 'HEAD' })\n * console.log('commit', sha)\n *\n * let oid = await git.writeObject({\n *   fs,\n *   dir: '/tutorial',\n *   type: 'tag',\n *   object: {\n *     object: sha,\n *     type: 'commit',\n *     tag: 'my-tag',\n *     tagger: {\n *       name: 'your name',\n *       email: 'email@example.com',\n *       timestamp: Math.floor(Date.now()/1000),\n *       timezoneOffset: new Date().getTimezoneOffset()\n *     },\n *     message: 'Optional message'\n *   }\n * })\n *\n * console.log('tag', oid)\n *\n */\nasync function writeObject({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  type,\n  object,\n  format = 'parsed',\n  oid,\n  encoding = undefined,\n}) {\n  try {\n    const fs = new FileSystem(_fs);\n    // Convert object to buffer\n    if (format === 'parsed') {\n      switch (type) {\n        case 'commit':\n          object = GitCommit.from(object).toObject();\n          break\n        case 'tree':\n          object = GitTree.from(object).toObject();\n          break\n        case 'blob':\n          object = Buffer.from(object, encoding);\n          break\n        case 'tag':\n          object = GitAnnotatedTag.from(object).toObject();\n          break\n        default:\n          throw new ObjectTypeError(oid || '', type, 'blob|commit|tag|tree')\n      }\n      // GitObjectManager does not know how to serialize content, so we tweak that parameter before passing it.\n      format = 'content';\n    }\n    oid = await _writeObject({\n      fs,\n      gitdir,\n      type,\n      object,\n      oid,\n      format,\n    });\n    return oid\n  } catch (err) {\n    err.caller = 'git.writeObject';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Write a ref which refers to the specified SHA-1 object id, or a symbolic ref which refers to the specified ref.\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {string} args.ref - The name of the ref to write\n * @param {string} args.value - When `symbolic` is false, a ref or an SHA-1 object id. When true, a ref starting with `refs/`.\n * @param {boolean} [args.force = false] - Instead of throwing an error if a ref named `ref` already exists, overwrite the existing ref.\n * @param {boolean} [args.symbolic = false] - Whether the ref is symbolic or not.\n *\n * @returns {Promise<void>} Resolves successfully when filesystem operations are complete\n *\n * @example\n * await git.writeRef({\n *   fs,\n *   dir: '/tutorial',\n *   ref: 'refs/heads/another-branch',\n *   value: 'HEAD'\n * })\n * await git.writeRef({\n *   fs,\n *   dir: '/tutorial',\n *   ref: 'HEAD',\n *   value: 'refs/heads/another-branch',\n *   force: true,\n *   symbolic: true\n * })\n * console.log('done')\n *\n */\nasync function writeRef({\n  fs: _fs,\n  dir,\n  gitdir = join(dir, '.git'),\n  ref,\n  value,\n  force = false,\n  symbolic = false,\n}) {\n  try {\n    assertParameter('fs', _fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('ref', ref);\n    assertParameter('value', value);\n\n    const fs = new FileSystem(_fs);\n\n    if (ref !== cleanGitRef.clean(ref)) {\n      throw new InvalidRefNameError(ref, cleanGitRef.clean(ref))\n    }\n\n    if (!force && (await GitRefManager.exists({ fs, gitdir, ref }))) {\n      throw new AlreadyExistsError('ref', ref)\n    }\n\n    if (symbolic) {\n      await GitRefManager.writeSymbolicRef({\n        fs,\n        gitdir,\n        ref,\n        value,\n      });\n    } else {\n      value = await GitRefManager.resolve({\n        fs,\n        gitdir,\n        ref: value,\n      });\n      await GitRefManager.writeRef({\n        fs,\n        gitdir,\n        ref,\n        value,\n      });\n    }\n  } catch (err) {\n    err.caller = 'git.writeRef';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * @param {object} args\n * @param {import('../models/FileSystem.js').FileSystem} args.fs\n * @param {string} args.gitdir\n * @param {TagObject} args.tag\n *\n * @returns {Promise<string>}\n */\nasync function _writeTag({ fs, gitdir, tag }) {\n  // Convert object to buffer\n  const object = GitAnnotatedTag.from(tag).toObject();\n  const oid = await _writeObject({\n    fs,\n    gitdir,\n    type: 'tag',\n    object,\n    format: 'content',\n  });\n  return oid\n}\n\n// @ts-check\n\n/**\n * Write an annotated tag object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {TagObject} args.tag - The object to write\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object\n * @see TagObject\n *\n * @example\n * // Manually create an annotated tag.\n * let sha = await git.resolveRef({ fs, dir: '/tutorial', ref: 'HEAD' })\n * console.log('commit', sha)\n *\n * let oid = await git.writeTag({\n *   fs,\n *   dir: '/tutorial',\n *   tag: {\n *     object: sha,\n *     type: 'commit',\n *     tag: 'my-tag',\n *     tagger: {\n *       name: 'your name',\n *       email: 'email@example.com',\n *       timestamp: Math.floor(Date.now()/1000),\n *       timezoneOffset: new Date().getTimezoneOffset()\n *     },\n *     message: 'Optional message'\n *   }\n * })\n *\n * console.log('tag', oid)\n *\n */\nasync function writeTag({ fs, dir, gitdir = join(dir, '.git'), tag }) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('tag', tag);\n\n    return await _writeTag({\n      fs: new FileSystem(fs),\n      gitdir,\n      tag,\n    })\n  } catch (err) {\n    err.caller = 'git.writeTag';\n    throw err\n  }\n}\n\n// @ts-check\n\n/**\n * Write a tree object directly\n *\n * @param {object} args\n * @param {FsClient} args.fs - a file system client\n * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path\n * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path\n * @param {TreeObject} args.tree - The object to write\n *\n * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object.\n * @see TreeObject\n * @see TreeEntry\n *\n */\nasync function writeTree({ fs, dir, gitdir = join(dir, '.git'), tree }) {\n  try {\n    assertParameter('fs', fs);\n    assertParameter('gitdir', gitdir);\n    assertParameter('tree', tree);\n\n    return await _writeTree({\n      fs: new FileSystem(fs),\n      gitdir,\n      tree,\n    })\n  } catch (err) {\n    err.caller = 'git.writeTree';\n    throw err\n  }\n}\n\n// default export\nvar index = {\n  Errors,\n  STAGE,\n  TREE,\n  WORKDIR,\n  add,\n  abortMerge,\n  addNote,\n  addRemote,\n  annotatedTag,\n  branch,\n  checkout,\n  clone,\n  commit,\n  getConfig,\n  getConfigAll,\n  setConfig,\n  currentBranch,\n  deleteBranch,\n  deleteRef,\n  deleteRemote,\n  deleteTag,\n  expandOid,\n  expandRef,\n  fastForward,\n  fetch,\n  findMergeBase,\n  findRoot,\n  getRemoteInfo,\n  getRemoteInfo2,\n  hashBlob,\n  indexPack,\n  init,\n  isDescendent,\n  isIgnored,\n  listBranches,\n  listFiles,\n  listNotes,\n  listRemotes,\n  listServerRefs,\n  listTags,\n  log,\n  merge,\n  packObjects,\n  pull,\n  push,\n  readBlob,\n  readCommit,\n  readNote,\n  readObject,\n  readTag,\n  readTree,\n  remove,\n  removeNote,\n  renameBranch,\n  resetIndex,\n  updateIndex,\n  resolveRef,\n  status,\n  statusMatrix,\n  tag,\n  version,\n  walk,\n  writeBlob,\n  writeCommit,\n  writeObject,\n  writeRef,\n  writeTag,\n  writeTree,\n};\n\nexport default index;\nexport { Errors, STAGE, TREE, WORKDIR, abortMerge, add, addNote, addRemote, annotatedTag, branch, checkout, clone, commit, currentBranch, deleteBranch, deleteRef, deleteRemote, deleteTag, expandOid, expandRef, fastForward, fetch, findMergeBase, findRoot, getConfig, getConfigAll, getRemoteInfo, getRemoteInfo2, hashBlob, indexPack, init, isDescendent, isIgnored, listBranches, listFiles, listNotes, listRemotes, listServerRefs, listTags, log, merge, packObjects, pull, push, readBlob, readCommit, readNote, readObject, readTag, readTree, remove, removeNote, renameBranch, resetIndex, resolveRef, setConfig, status, statusMatrix, tag, updateIndex, version, walk, writeBlob, writeCommit, writeObject, writeRef, writeTag, writeTree };\n"],"mappings":"AAAA,OAAOA,SAAS,MAAM,YAAY;AAClC,OAAOC,IAAI,MAAM,gBAAgB;AACjC,OAAOC,KAAK,MAAM,QAAQ;AAC1B,OAAOC,IAAI,MAAM,MAAM;AACvB,OAAOC,IAAI,MAAM,MAAM;AACvB,OAAOC,MAAM,MAAM,QAAQ;AAC3B,OAAOC,WAAW,MAAM,eAAe;AACvC,OAAOC,UAAU,MAAM,OAAO;;AAE9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAE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AAI,CAACmqB,UAAU,CAACG,MAAM,CAAC,SAAS,CAAC,CAAC;EAC1D,IAAIyH,MAAM,EAAErC,UAAU,CAAC1vB,IAAI,CAACmqB,UAAU,CAACG,MAAM,CAAE,cAAayH,MAAO,EAAC,CAAC,CAAC;EACtErC,UAAU,CAAC1vB,IAAI,CAACmqB,UAAU,CAACC,KAAK,CAAC,CAAC,CAAC;EACnC,OAAOsF,UAAU;AACnB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAegI,cAAcA,CAAC;EAC5B5L,IAAI;EACJC,MAAM;EACNC,aAAa;EACbC,aAAa;EACbT,SAAS;EACThR,GAAG;EACHmC,OAAO,GAAG,CAAC,CAAC;EACZ+Y,OAAO,GAAG,KAAK;EACf/K,eAAe,GAAG,CAAC;EACnBoH,MAAM;EACNrlB,OAAO;EACPopB;AACF,CAAC,EAAE;EACD,IAAI;IACF5S,eAAe,CAAC,MAAM,EAAE4I,IAAI,CAAC;IAC7B5I,eAAe,CAAC,KAAK,EAAE1I,GAAG,CAAC;IAE3B,MAAM3V,MAAM,GAAG,MAAM+mB,aAAa,CAACC,QAAQ,CAAC;MAC1CC,IAAI;MACJC,MAAM;MACNC,aAAa;MACbC,aAAa;MACbT,SAAS;MACTX,OAAO,EAAE6K,OAAO,GAAG,kBAAkB,GAAG,iBAAiB;MACzDlb,GAAG;MACHmC,OAAO;M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MACN5K,QAAQ;MACR2O,GAAG;MACH0I,KAAK;MACLuhB,KAAK;MACL5pB,KAAK;MACLyyB;IACF,CAAC,CAAC;EACJ,CAAC,CAAC,OAAO7pB,GAAG,EAAE;IACZA,GAAG,CAAC3Y,MAAM,GAAG,SAAS;IACtB,MAAM2Y,GAAG;EACX;AACF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeyqB,KAAKA,CAAC;EACnBn4B,EAAE,EAAEsiB,GAAG;EACP2C,MAAM;EACNxjB,GAAG;EACHf,MAAM,GAAGnC,IAAI,CAACkD,GAAG,EAAE,MAAM,CAAC;EAC1B6wB,IAAI;EACJC,MAAM;EACNsB,WAAW,GAAG,IAAI;EAClBC,eAAe,GAAG,KAAK;EACvBzP,MAAM,GAAG,KAAK;EACdc,cAAc,GAAG,KAAK;EACtB+N,eAAe,GAAG,IAAI;EACtBp+B,OAAO;EACPomB,MAAM,EAAEqL,OAAO;EACfvK,SAAS,EAAEwK,UAAU;EACrBtB,UAAU;EACVjlB,KAAK,GAAG,CAAC,CAAC;EACVkzB;AACF,CAAC,EAAE;EACD,IAAI;IACF/Q,eAAe,CAAC,IAAI,EAAEE,GAAG,CAAC;IAC1B,IAAI4C,UAAU,EAAE;MAC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ACFC,KAAK;IACLS,MAAM;IACN5D,GAAG,EAAE+E,MAAM;IACX/L,QAAQ,EAAEgH;EACZ,CAAC,CAAC;EAEF,OAAOs7B,IAAI;AACb;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAeyC,QAAQA,CAAC;EACtB76B,EAAE;EACFyB,GAAG;EACHf,MAAM,GAAGnC,IAAI,CAACkD,GAAG,EAAE,MAAM,CAAC;EAC1BgD,GAAG,GAAG,oBAAoB;EAC1B3H,GAAG;EACHmD,KAAK,GAAG,CAAC;AACX,CAAC,EAAE;EACD,IAAI;IACFmiB,eAAe,CAAC,IAAI,EAAEpiB,EAAE,CAAC;IACzBoiB,eAAe,CAAC,QAAQ,EAAE1hB,MAAM,CAAC;IACjC0hB,eAAe,CAAC,KAAK,EAAE3d,GAAG,CAAC;IAC3B2d,eAAe,CAAC,KAAK,EAAEtlB,GAAG,CAAC;IAE3B,OAAO,MAAM89B,SAAS,CAAC;MACrB56B,EAAE,EAAE,IAAIygB,UAAU,CAACzgB,EAAE,CAAC;MACtBC,KAAK;MACLS,MAAM;MACN+D,GAAG;MACH3H;IACF,CAAC,CAAC;EACJ,CAAC,CAAC,OAAO4Q,GAAG,EAAE;IACZA,GAAG,CAAC3Y,MAAM,GAAG,cAAc;IAC3B,MAAM2Y,GAAG;EACX;AACF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeotB,UAAUA,CAAC;EACxB96B,EAAE,EAAEsiB,GAAG;EACP7gB,GAAG;EACHf,MAAM,GAAGnC,IAAI,CAACkD,GAAG,EAAE,MAAM,CAAC;EAC1B3E,GAAG;EACHsS,MAAM,GAAG,QAAQ;EACjBtZ,QAAQ,GAAGuC,SAAS;EACpBiT,QAAQ,GAAGjT,SAAS;EACpB4H,KAAK,GAAG,CAAC;AACX,CAAC,EAAE;EACD,IAAI;IACFmiB,eAAe,CAAC,IAAI,EAAEE,GAAG,CAAC;IAC1BF,eAAe,CAAC,QAAQ,EAAE1hB,MAAM,CAAC;IACjC0hB,eAAe,CAAC,KAAK,EAAEtlB,GAAG,CAAC;IAE3B,MAAMkD,EAAE,GAAG,IAAIygB,UAAU,CAAC6B,GAAG,CAAC;IAC9B,IAAIxsB,QAAQ,KAAKuC,SAAS,EAAE;MAC1ByE,GAAG,GAAG,MAAMwoB,eAAe,CAAC;QAC1BtlB,EAAE;QACFC,KAAK;QACLS,MAAM;QACN5D,GAAG;QACHhH;MACF,CAAC,CAAC;IACJ;IACA;IACA,MAAMilC,OAAO,GAAG3rB,MAAM,KAAK,QAAQ,GAAG,SAAS,GAAGA,MAAM;IACxD,MAAMrO,MAAM,GAAG,MAAMkW,WAAW,CAAC;MAC/BjX,EAAE;MACFC,KAAK;MACLS,MAAM;MACN5D,GAAG;MACHsS,MAAM,EA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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeoR,IAAIA,CAAC;EAClB9e,EAAE;EACFyB,GAAG;EACHf,MAAM,GAAGnC,IAAI,CAACkD,GAAG,EAAE,MAAM,CAAC;EAC1Bkd,KAAK;EACLrgB,GAAG;EACHuK,MAAM;EACNgW,OAAO;EACP5e,KAAK,GAAG,CAAC;AACX,CAAC,EAAE;EACD,IAAI;IACFmiB,eAAe,CAAC,IAAI,EAAEpiB,EAAE,CAAC;IACzBoiB,eAAe,CAAC,QAAQ,EAAE1hB,MAAM,CAAC;IACjC0hB,eAAe,CAAC,OAAO,EAAEzD,KAAK,CAAC;IAE/B,OAAO,MAAMD,KAAK,CAAC;MA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}